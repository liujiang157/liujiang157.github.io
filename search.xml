<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>那些年我们学过的设计模式，你还记得几个（一）</title>
      <link href="2020/09/25/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E5%AD%A6%E8%BF%87%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E8%BF%98%E8%AE%B0%E5%BE%97%E5%87%A0%E4%B8%AA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2020/09/25/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E5%AD%A6%E8%BF%87%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E8%BF%98%E8%AE%B0%E5%BE%97%E5%87%A0%E4%B8%AA%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="那些年我们学过的设计模式，你还记得几个（一）"><a href="#那些年我们学过的设计模式，你还记得几个（一）" class="headerlink" title="那些年我们学过的设计模式，你还记得几个（一）"></a>那些年我们学过的设计模式，你还记得几个（一）</h1><p>最近在忙着面试，趁着没工作的空闲期，想把设计模式好好整理一遍。话不多说，我们之间上第一个设计模式—-<code>单例模式</code></p><h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>这也是面试时面试官经常问我的问题，什么是单例模式？脑海中是不是立即浮现出两种单例模式。然后准备滔滔不绝的说给面试官听？面试官在问我们这个问题的时候，我们最好不要答非所问。最好根据单例模式的定义去正面回答面试官。</p><p>单例模式是指在内存中只会创建且仅创建一次对象的设计模式。在程序中多次使用同一个对象且作用相同时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中创建一个对象，让所有需要调用的地方都共享这一单例对象。</p><p><img src="dlms1.jpg" alt="单例模式定义"></p><h2 id="单例模式创建类型"><a href="#单例模式创建类型" class="headerlink" title="单例模式创建类型"></a>单例模式创建类型</h2><ul><li><p><code>懒汉式</code>：在被程序第一次调用的时候才初始化该单例对象</p></li><li><p><code>饿汉式</code>：在类加载的时候就已经创建好该单例对象</p></li></ul><h3 id="懒汉式创建单例对象"><a href="#懒汉式创建单例对象" class="headerlink" title="懒汉式创建单例对象"></a>懒汉式创建单例对象</h3><p>懒汉式只在程序第一次调用的时候创建对象，所以需要调用的时候需要判断是否已经实例化该对象，如果未实例化，则实例化该对象。</p><p><img src="lhs.png" alt="懒汉式"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleTon singleTon;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon==<span class="keyword">null</span>)&#123;</span><br><span class="line">            singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面再讲这段代码的优化，我们先来看第二种单例模式的实现。</p><h3 id="饿汉式创建单例对象"><a href="#饿汉式创建单例对象" class="headerlink" title="饿汉式创建单例对象"></a>饿汉式创建单例对象</h3><p>饿汉式在类加载的时候就已经初始化好该对象，后续程序调用的都是该对象。</p><p><img src="ehs.png" alt="饿汉式"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleTon singleTon = <span class="keyword">new</span> HungrySingleTon();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样类在加载时会在堆内存中创建一个HungrySingleTon对象，当类被卸载时，HungrySingleTon对象也就会被随之死亡了。</p><h3 id="懒汉式代码如何优化"><a href="#懒汉式代码如何优化" class="headerlink" title="懒汉式代码如何优化"></a>懒汉式代码如何优化</h3><p>因为上述懒汉式的实现并不能保证在多线程环境下，对象只被创建一次的问题。因此存在存在一个线程安全的问题。我们回顾一下上面懒汉式创建的主要函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon==<span class="keyword">null</span>)&#123;</span><br><span class="line">            singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果同时存在多个线程，线程1在判断了<code>singleTon==null</code>后让出了cpu的使用权，而线程二这时候获取到了cpu的使用权，也判断了一次<code>singleTon==null</code>那么线程2就会执行<code>singleTon = new LazySingleTon()</code>,当线程1重新获取到cpu的使用权之后，因为他刚判断了<code>singleTon</code>是null，所以线程1也会创建一个LazySingleTon的实例。所以就存在了<code>线程安全</code>的问题。</p><hr><p>我们最容易想到的办法就是加锁，给类对象加锁或者给方法加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给方法加锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(singleTon==<span class="keyword">null</span>)&#123;</span><br><span class="line">singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleTon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给类对象加锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon==<span class="keyword">null</span>)&#123;</span><br><span class="line">singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleTon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但上面两种方法都存在一个问题，在获取对象之前都要先获取锁，所以并发性能就显得尤其的低下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon ==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleTon<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleTon == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的实现方式，就完美的解决了性能低下和锁资源的问题。</p><ul><li><strong>line2:</strong>当singleTon已经被实例化的时候,直接返回对象，不再获取锁资源</li><li><strong>line3</strong>:当多个线程进入第一个if时，施加同步锁，每次仅允许一个线程进去当前代码块。</li><li><strong>line4</strong>:锁内再次进行判断，因为多个线程抢夺一个资源时只有一个获取到，后进入的线程所要获取的对象已经被第一个线程实例化过。所以需要再次判断。</li></ul><p>这就是典型的DCL型懒汉单例，<code>Double Check and Lock</code>双重校验加锁。但是我们在写DCL的时候都会加入<code>volatile</code>关键词修饰singleTon。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleTon singleTon;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon ==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleTon<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleTon == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是因为JVM在创建对象的时候，可以对指令进行重排序以提高程序性能。JVM在创建对象的时候，一般会经过以下三个步骤：</p><ul><li>分配内存空间</li><li>初始化对象</li><li>将对象指向分配好的内存空间</li></ul><p>但是在2和3的时候有可能出现指令重排。比如多个线程，当线程1执行了1-3而正在初始化对象，而线程2获取对象时，就获取到了一个未初始化的对象。就会出现空指针异常了。而volatile就是为了在JVM创建对象的时候进行<code>禁止指令重排</code>的。</p><h2 id="还有其他的形式吗"><a href="#还有其他的形式吗" class="headerlink" title="还有其他的形式吗"></a>还有其他的形式吗</h2><h3 id="静态内部类实现单例"><a href="#静态内部类实现单例" class="headerlink" title="静态内部类实现单例"></a>静态内部类实现单例</h3><p>静态内部类相对于DCL模式实现更简单，对<code>静态域</code>使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在<code>实例域</code>需要延迟初始化时使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingleTon INSTANCE = <span class="keyword">new</span> SingleTon();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SingleTon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举类实现单例"><a href="#枚举类实现单例" class="headerlink" title="枚举类实现单例"></a>枚举类实现单例</h3><p>在JDK1.5中，java引入了枚举类型。枚举是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是《 Effective Java》 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象。</p><p>优点不言而喻：</p><ul><li>实现更简单</li><li>天然的线程安全</li><li>可以防止反射、反序列化创建多个枚举对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="破坏单例模式"><a href="#破坏单例模式" class="headerlink" title="破坏单例模式"></a>破坏单例模式</h2><p>枚举本身自带防止反射和反序列化的特性，那懒汉式和饿汉式又是如何被破坏的呢</p><h3 id="反射破坏单例模式"><a href="#反射破坏单例模式" class="headerlink" title="反射破坏单例模式"></a>反射破坏单例模式</h3><p>下面我们就可以用反射直接强制访问私有构造器，去创建实例对象破坏单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取类的显式构造器</span></span><br><span class="line">    Constructor&lt;HungrySingleTon&gt; construct = HungrySingleTon<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>()</span>;</span><br><span class="line">    <span class="comment">// 可访问私有构造器</span></span><br><span class="line">    construct.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 利用反射构造新对象</span></span><br><span class="line">    HungrySingleTon obj1 = construct.newInstance();</span><br><span class="line">    <span class="comment">// 通过正常方式获取单例对象</span></span><br><span class="line">    HungrySingleTon obj2 = HungrySingleTon.getInstance();</span><br><span class="line">    System.out.println(obj1 == obj2); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那如何防止单例模式被反射破坏呢，因为反射是强制访问私有构造器，对于饿汉式，在类加载的时候对象已经初始化，所以我们可以在私有构造器对当前对象进行判断来规避反射破坏单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleTon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleTon singleTon = <span class="keyword">new</span> HungrySingleTon();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleTon</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"禁止通过反射实例化对象"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化和反序列化破坏单例模式"><a href="#序列化和反序列化破坏单例模式" class="headerlink" title="序列化和反序列化破坏单例模式"></a>序列化和反序列化破坏单例模式</h3><p>下面是一个序列化和反序列化去破坏单例的例子，但是使用序列化和反序列化破坏单例时，单例对象的类必须实现Serializable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleTon</span> <span class="keyword">implements</span>  <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 创建输出流</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"Singleton.file"</span>));</span><br><span class="line">        <span class="comment">// 将单例对象写到文件中</span></span><br><span class="line">        oos.writeObject(HungrySingleTon.getInstance());</span><br><span class="line">        <span class="comment">// 从文件中读取单例对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"Singleton.file"</span>);</span><br><span class="line">        ObjectInputStream ois =  <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        HungrySingleTon newInstance = (HungrySingleTon) ois.readObject();</span><br><span class="line">        <span class="comment">// 判断是否是同一个对象</span></span><br><span class="line">        System.out.println(newInstance == HungrySingleTon.getInstance()); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleTon singleTon = <span class="keyword">new</span> HungrySingleTon();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>单例模式主要实现方式为懒汉式、饿汉式、静态内部类和枚举</li><li>大部分的单例模式可以被反射和序列化和反序列化破坏</li><li>我们可以通过人为干预来避免反射或系列化攻击</li><li>枚举自带天然的线程安全和单一实例以及防反射和防序列化和反序列破坏的特性</li><li>对于懒汉式最优雅的写法应该是DCL加volatile修饰</li><li>对内存要求高的时候我们可以选择<code>懒加载</code>的单例实现方式</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客，记录我的絮絮叨叨</title>
      <link href="2020/09/23/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%EF%BC%8C%E8%AE%B0%E5%BD%95%E6%88%91%E7%9A%84%E7%B5%AE%E7%B5%AE%E5%8F%A8%E5%8F%A8/"/>
      <url>2020/09/23/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%EF%BC%8C%E8%AE%B0%E5%BD%95%E6%88%91%E7%9A%84%E7%B5%AE%E7%B5%AE%E5%8F%A8%E5%8F%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="第一篇博客，记录我的絮絮叨叨"><a href="#第一篇博客，记录我的絮絮叨叨" class="headerlink" title="第一篇博客，记录我的絮絮叨叨"></a>第一篇博客，记录我的絮絮叨叨</h1><p>今天是脱口秀大会第三季的收官期，这个主题也和我想发的牢骚很契合吧。脱口秀决赛期的主题是<code>新的终点，也是新的起点</code>。</p><p><a href="https://v.qq.com/x/cover/mzc0020026ss8r8.html" target="_blank" rel="noopener">脱口秀大会收官决赛 &#10174;</a></p><p>第三季脱口秀大会我没有每期都看，但是今天的主题对我来说也有特别的意义。</p><h2 id="学校-社会"><a href="#学校-社会" class="headerlink" title="学校-社会"></a>学校-社会</h2><h3 id="毕业"><a href="#毕业" class="headerlink" title="毕业"></a>毕业</h3><p>就在两个月之前，我刚从学校拿到了我的学位证书，告别了我的<code>校园生活</code>。其实今年离开大学，没有很难舍的情怀在里面，可能是因为疫情的缘故吧，在毕业之前已经将近8个月不在校园，就连毕业也只是匆匆领证。天公不作美，毕业那天又刚好一直在下雨，以至于毕业照甚至没有一点仪式感。没有太多的小合影，没有太多时间给我留念。我就告别了我的大学，和李佳鑫一起赶当天下午的高铁一起回南京。</p><p><img src="byhz.jpg" alt="毕业合照"></p><h3 id="社会"><a href="#社会" class="headerlink" title="社会"></a>社会</h3><p>在我还没有拿到毕业证的时候，我相当于已经是一个<code>准社会人</code>了，春招的时候其实已经有很强的危机感了，想找一份待遇还不错，自己也满意的工作。其实秋招的时候，我拿到过一些公司的offer，但是秋招的时候当时都没有选择去签订三方，想等等看春招会不会有更好的机会，春招的时候面了几家，但是总体待遇都不是很好。我最后还是选择去了华宇信息去入职。最后因为工资待遇问题提出了离职。就这样我新的起点，又变成了终点。</p><hr><h2 id="工作-工作"><a href="#工作-工作" class="headerlink" title="工作-工作"></a>工作-工作</h2><p>好像做IT行业，给人的工作就是一份工作最多干个两三年。而我的第一份正式工作，却只坚持了短短三个月。</p><h3 id="第一份工作"><a href="#第一份工作" class="headerlink" title="第一份工作"></a>第一份工作</h3><p>上面所提到的，我的第一份正式工作选择了华宇这个平台。而我也因为生活成本和劳动回报比的问题和公司产生了分歧。最终在和领导沟通的过程中，领导说转正重新定薪的可能性很小。我只想和自己比，当时的我连房租都付不起，我和领导沟通的时候，希望涨1k，我不管其他跟我一起入职的比我高多少，我只想先生存下来，领导说重新定薪基本不可能。后来几天我思考之后选择离职，领导又突然说帮我跟上级沟通，应该可以涨2k，我想了一下前几天的话，突然像个笑话。没有留恋，没有回头。从此，你我江湖是路人。</p><h3 id="第二份工作"><a href="#第二份工作" class="headerlink" title="第二份工作"></a>第二份工作</h3><p>因为选择的裸辞，压力还是挺大的，又加上我8月工资扣了7、8、9、10四个月的社保和7、8、9三个月的公积金，所以到手工资只有<code>1.3k</code>,让我本不富裕的生活又更加窘迫起来，需要在短时间内找到工作。应届生裸辞带来的第一个风险就是简历社招很难过，没有工作经验。所幸，过简历的都成功拿到了offer。也拒绝了一部分offer。以后日子再苦，都要坚持吧，未来可期。有点毒鸡汤，也是对自己的激励。</p><h1 id="新的终点，新的起点"><a href="#新的终点，新的起点" class="headerlink" title="新的终点，新的起点"></a>新的终点，新的起点</h1><p>我写这篇博客之前，重新搭建了一下自己的博客，把以前的文章删掉。也是之前颓废的自己的一个终点吧，立一个flag，至少每周记录一下自己所学，有所文字产出。未来还很长，大家都需要努力。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
