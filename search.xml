<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>不要再盲目使用parallelStream啦</title>
      <link href="2021/12/31/%E4%B8%8D%E8%A6%81%E5%86%8D%E7%9B%B2%E7%9B%AE%E4%BD%BF%E7%94%A8parallelStream%E5%95%A6/"/>
      <url>2021/12/31/%E4%B8%8D%E8%A6%81%E5%86%8D%E7%9B%B2%E7%9B%AE%E4%BD%BF%E7%94%A8parallelStream%E5%95%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JAVA8 的特性相信许多开发者都已经非常了解了，其中很重要的一个特性— <code>Stream</code> ，这个特性让我们能够以声明性的方式在集合上构建复杂的查询。并且，<code>Stream API</code> 为并行执行也提供了一种简单的方法。只需添加 <code>parallel()</code> 语句或使用 <code>parallelStream()</code> 函数。但是如果开发者盲目的使用并行流，不仅不会提高性能，反而会引发致命的错误。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>现在给你一组指定的数组，需要你计算出每个数字的乘积。这种情况我们采用 stream 可以用一个链式代码直接一步到位，省去了写 <code>for</code> 循环的这样臃肿的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span>[] array = <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">3</span>, <span class="number">123</span>, <span class="number">1</span>, <span class="number">31</span>, <span class="number">56</span>, <span class="number">61</span>, <span class="number">22</span>&#125;;</span><br><span class="line">       <span class="keyword">long</span> total = Arrays.stream(array)</span><br><span class="line">               .reduce(<span class="number">1</span>, (acc, next) -&gt; acc * next);</span><br><span class="line">       System.out.println(total);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果我们拿到的结果还需要乘以一个固定的数字 m ，那么我们只需要修改代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> total = Arrays.stream(array)</span><br><span class="line">               .reduce(m, (acc, next) -&gt; acc * next);</span><br></pre></td></tr></table></figure><p>如果数字过多串行流的顺序执行会不会导致效率很低呢？于是我又尝试采用 <code>parallel()</code> 来执行程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span>[] array = <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">3</span>, <span class="number">123</span>, <span class="number">1</span>, <span class="number">31</span>, <span class="number">56</span>, <span class="number">61</span>, <span class="number">22</span>&#125;;</span><br><span class="line">       <span class="keyword">long</span> total = Arrays.stream(array)</span><br><span class="line">               .parallel()</span><br><span class="line">               .reduce(<span class="number">1</span>, (acc, next) -&gt; acc * next);</span><br><span class="line">       System.out.println(total);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我意外的发现，当 <code>m=1</code> 的时候，串行流和并行流取得的结果是一致的，而当 m 不为 1 时，两者的结果并不匹配。比如当 <code>m=3</code> 的时候，串行流的运算结果为 <code>2578991184</code> 而并行流的运算结果为 <code>1880084573136</code> 。是什么导致了这样的误差呢？</p><h2 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h2><p>Java Streams 默认使用同一个 <code>ForkJoinPool</code> 执行并行流。 ForkJoinPool 主要就是将任务递归拆分为多个块，然后可以独立地计算每个块。</p><p><code>Stream.reduce</code> 顺序执行的时候是这样的：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40c3b318a03e4490b3fb3753a2d0e78f~tplv-k3u1fbpfcp-watermark.image" alt="未命名文件 (6).png"></p><p>并行流的算法其实也非常简单，我们假设任务仅被分成 2 部分：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc97c5dceef24e599ba5ecb96669eace~tplv-k3u1fbpfcp-watermark.image" alt="未命名文件 (8).png"></p><p>每个块都多乘了一次 m ，并行流给每个任务块都应用了给定的标识 m 。知道了这个刚刚的 bug 我们也就可以解决了。我们可以将每个标识 m 都采用 1 ，乘 1 并不会影响程序结果，然后得到最后的结果只会再乘以 m ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span>[] array = <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">3</span>, <span class="number">123</span>, <span class="number">1</span>, <span class="number">31</span>, <span class="number">56</span>, <span class="number">61</span>, <span class="number">22</span>&#125;;</span><br><span class="line">       <span class="keyword">long</span> total = Arrays.stream(array)</span><br><span class="line">               .parallel()</span><br><span class="line">               .reduce(<span class="number">1</span>, (acc, next) -&gt; acc * next) * m;</span><br><span class="line">       System.out.println(total);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过这个示例，我们再使用流的时候，有哪些小细节应该注意呢？</p><h3 id="Reduce-应当可拆分"><a href="#Reduce-应当可拆分" class="headerlink" title="Reduce 应当可拆分"></a>Reduce 应当可拆分</h3><p>如果不确定流是串行流（比如它作为函数参数来提供），则 reduce 函数的 <code>identity</code> 不应影响单个任务块的结果。即求和函数的 identity 必须为 0 ，而求乘积的 identity 必须为 1。</p><h3 id="合理采用并行流"><a href="#合理采用并行流" class="headerlink" title="合理采用并行流"></a>合理采用并行流</h3><p>并不是所有流操作都应该并行化。例如 <code>map</code> ，<code>flatMap</code> 和 <code>filter</code> 是无状态的，因此我们可以采用并行流的做法。而 <code>sort</code> ，<code>distinct</code> 和 <code>limit</code> 不但不会带来性能提升，反而可能会引发错误。</p><p>并且，并行化的有效性在很大程度上取决于流的来源。 <code>ArrayList</code> ，<code>array</code> 或<code>IntStream.range</code> 支持随机访问，这意味着它们可以轻松拆分。但是 <code>LinkedList</code> 分解需要 O(n) 时间。还有 <code>Stream.iterate</code> 和 <code>BufferedReader</code> 也要尽量避免采用并行流，因为它们的开头都有未知的长度，因此很难估算拆分来源。</p><h3 id="编写单元测试"><a href="#编写单元测试" class="headerlink" title="编写单元测试"></a>编写单元测试</h3><p>并行流虽然具备潜在的性能优势，但是同时也可能带来一些致命的错误，因此，每次将串行流替换为并行流时，为了确保功能未被破坏。需要编写一定的单元侧试。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天主要介绍了并行流一些使用上的小细节，但是对 <code>ForkJoinPool</code> 并没有做具体解析。觉得写的不错的小伙伴点个赞支持一下吧。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stream </tag>
            
            <tag> JAVA8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单实现一下断点续传</title>
      <link href="2021/12/31/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%8B%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/"/>
      <url>2021/12/31/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%8B%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在上传文件的时候，如果文件内容较小，我们可以直接采用将文件转化为字节流传输到服务端。但是如果遇到大文件，这样的方式是非常折磨用户的，而且万一中途传输中断，又要重新从 <code>0</code> 开始。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d878a1af3a6e45fea209e8b2faddd519~tplv-k3u1fbpfcp-watermark.image" alt="0_jVvFr4qLr4YQ48xo.gif"></p><p>所以我们需要采用分片上传/断点续传来优化用户的使用体验。</p><hr><h2 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h2><p><code>断点续传</code> 就是将跳过上一次上传的文件内容，采用 <code>Blob.slice</code> 方法分割文件内容，直接上传剩余的字节数。</p><h2 id="监听进度"><a href="#监听进度" class="headerlink" title="监听进度"></a>监听进度</h2><p>如果要实现断点续传，我们就需要知道我们之前上传了多少进度。我们采用 <code>XMLHttpRequest</code> 来进行上传，因为 <code>fetch</code> 是无法监听 <code>progress</code> 事件的（也可能是怪我菜）。</p><p>我们采用 <code>xhr.upload.onprogress</code> 来实现进度监听。要实现断点续传，我们就需要知道服务端接收的字节数。所以除了上传请求，我们还需要增加一个请求来询问服务器上传了多少字节。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p> 首先我们先创建一个唯一的标识 <code>id</code> 来标识我们要上传的文件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fileId = file.name + <span class="string">'-'</span> + file.size + <span class="string">'-'</span> + file.lastModified;</span><br></pre></td></tr></table></figure><br>我们这里简单判定一下，当文件名，大小，最近修改日期发生更改的话，断点续传的时候就会判定这个文件就是一个新的文件，重新生成一个新的 <code>fileId</code> 。也就是说不会进行续传。</p><p> 向服务端发送一个请求，请求服务端已经接收了多少个字节。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">'status'</span>, &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'X-File-Id'</span>: fileId</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端已有的字节数</span></span><br><span class="line"><span class="keyword">let</span> startByte = +<span class="keyword">await</span> response.text();</span><br></pre></td></tr></table></figure><br>服务器通过获取 <code>X-File-Id</code> 头信息获取我们刚刚设定的 <code>fileId</code> 来处理当前文件，当服务器中没有文件的时候，响应应为 <code>0</code> 。</p><p>然后我们采用 <code>Blob.slice</code> 方法发送 <code>startByte</code> 之后的文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">"POST"</span>, <span class="string">"upload"</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件唯一标识</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">'X-File-Id'</span>, fileId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传开始的字节数</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">'X-Start-Byte'</span>, startByte);</span><br><span class="line"></span><br><span class="line">xhr.upload.onprogress = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Uploaded <span class="subst">$&#123;startByte + e.loaded&#125;</span> of <span class="subst">$&#123;startByte + e.total&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xhr.send(file.slice(startByte));</span><br></pre></td></tr></table></figure><p>在这里，我们将文件唯一标识 <code>fileId</code> 作为 <code>X-File-Id</code> 发送给服务端，这样它就知道我们要上传的文件，并且将 <code>startByte</code> 作为 <code>X-Start-Byte</code> 告知服务器，我们是最初上传还是在续传，主要取决于 <code>startByte</code> 是否为 <code>0</code> 。</p><p>服务端如果发现 <code>startByte</code> 不为 0 ,应该向 field 文件追加字节流。</p><blockquote><p>这里的核心代码引用了一下 <a href="https://github.com/javascript-tutorial/zh.javascript.info/blob/master/5-network/09-resume-upload" target="_blank" rel="noopener">GiHub</a> 中的代码。</p></blockquote><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"uploader.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"upload"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span> <span class="attr">action</span>=<span class="string">"/upload"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"myfile"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Upload (Resumes automatically)"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"uploader.stop()"</span>&gt;</span>Stop upload<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"log"</span>&gt;</span>Progress indication<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="function"><span class="keyword">function</span> <span class="title">log</span><span class="params">(html)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'log'</span>).innerHTML = html;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(html);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">  <span class="function"><span class="keyword">function</span> <span class="title">onProgress</span><span class="params">(loaded, total)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    log(<span class="string">"progress "</span> + loaded + <span class="string">' / '</span> + total);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> uploader;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.forms.upload.onsubmit = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> file = <span class="keyword">this</span>.elements.myfile.files[<span class="number">0</span>];</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">if</span> (!file) <span class="keyword">return</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    uploader = <span class="keyword">new</span> Uploader(&#123;file, onProgress&#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> uploaded = <span class="keyword">await</span> uploader.upload();</span></span><br><span class="line"></span><br><span class="line">      if (uploaded) &#123;</span><br><span class="line"><span class="actionscript">        log(<span class="string">'success'</span>);</span></span><br><span class="line"><span class="actionscript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">        log(<span class="string">'stopped'</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    &#125; <span class="keyword">catch</span>(err) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.error(err);</span></span><br><span class="line"><span class="actionscript">      log(<span class="string">'error'</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>uploader.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uploader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(&#123;file, onProgress&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.file = file;</span><br><span class="line">    <span class="keyword">this</span>.onProgress = onProgress;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create fileId that uniquely identifies the file</span></span><br><span class="line">    <span class="comment">// we could also add user session identifier (if had one), to make it even more unique</span></span><br><span class="line">    <span class="keyword">this</span>.fileId = file.name + <span class="string">'-'</span> + file.size + <span class="string">'-'</span> + file.lastModified;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> getUploadedBytes() &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">'status'</span>, &#123;</span><br><span class="line">      headers: &#123;</span><br><span class="line">        <span class="string">'X-File-Id'</span>: <span class="keyword">this</span>.fileId</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response.status != <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Can't get uploaded bytes: "</span> + response.statusText);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> text = <span class="keyword">await</span> response.text();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> +text;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> upload() &#123;</span><br><span class="line">    <span class="keyword">this</span>.startByte = <span class="keyword">await</span> <span class="keyword">this</span>.getUploadedBytes();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">this</span>.xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">"POST"</span>, <span class="string">"upload"</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send file id, so that the server knows which file to resume</span></span><br><span class="line">    xhr.setRequestHeader(<span class="string">'X-File-Id'</span>, <span class="keyword">this</span>.fileId);</span><br><span class="line">    <span class="comment">// send the byte we're resuming from, so the server knows we're resuming</span></span><br><span class="line">    xhr.setRequestHeader(<span class="string">'X-Start-Byte'</span>, <span class="keyword">this</span>.startByte);</span><br><span class="line"></span><br><span class="line">    xhr.upload.onprogress = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.onProgress(<span class="keyword">this</span>.startByte + e.loaded, <span class="keyword">this</span>.startByte + e.total);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"send the file, starting from"</span>, <span class="keyword">this</span>.startByte);</span><br><span class="line">    xhr.send(<span class="keyword">this</span>.file.slice(<span class="keyword">this</span>.startByte));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return</span></span><br><span class="line">    <span class="comment">//   true if upload was successful,</span></span><br><span class="line">    <span class="comment">//   false if aborted</span></span><br><span class="line">    <span class="comment">// throw in case of an error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">      xhr.onload = xhr.onerror = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"upload end status:"</span> + xhr.status + <span class="string">" text:"</span> + xhr.statusText);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">          resolve(<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Upload failed: "</span> + xhr.statusText));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// onabort triggers only when xhr.abort() is called</span></span><br><span class="line">      xhr.onabort = <span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stop() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.xhr) &#123;</span><br><span class="line">      <span class="keyword">this</span>.xhr.abort();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这种断点续传的方式在传输大文件的时候，其实依然有一些缺点，比如当服务器如果有上传大小限制的时候，还是会无法上传。</p><p>既然采用了 <code>Blob.slice</code> 方法，干脆直接就对文件进行分块。并为每个文件块添加规则的文件头，然后分别上传。</p><p>在全部分块发送完成之后发送一个 <code>merge</code> 请求，让服务端拼接这些文件块。在这里也整理了几个比较好用的上传组件分享一下：</p><ul><li><a href="https://github.com/rajneeshraghav/resumable-file-uploads" target="_blank" rel="noopener">resumable-file-uploads</a></li><li><a href="https://www.npmjs.com/package/vue-simple-uploader" target="_blank" rel="noopener">vue simple uploader</a></li><li><a href="https://github.com/devin87/web-uploader" target="_blank" rel="noopener">web-uploader</a></li><li><a href="http://resumablejs.com/" target="_blank" rel="noopener">Resumable.js</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Fronted </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吃透 JAVA8 -- Optional 特性全部用法</title>
      <link href="2021/12/31/%E5%90%83%E9%80%8F-JAVA8-Optional-%E7%89%B9%E6%80%A7%E5%85%A8%E9%83%A8%E7%94%A8%E6%B3%95/"/>
      <url>2021/12/31/%E5%90%83%E9%80%8F-JAVA8-Optional-%E7%89%B9%E6%80%A7%E5%85%A8%E9%83%A8%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前整理了一下关于 JAVA8 特性— Stream 的用法，今天我们来介绍一下另一个特性 <code>Optional</code> 。 Optional API 提供了足够的方法方便开发者能够以更安全的方式处理 null 的情况。在 JAVA8 之前一般某个函数应该返回非空对象但是偶尔却可能返回了 null ，而在 JAVA8 中，不推荐你返回 null 而是返回 Optional 。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>在传统的写法中，当我们通过其他函数获取到一个对象，我们并不知道这个对象是不是一个null对象，我们的写法往往是通过一个 if 逻辑语句来判断这个对象是否是一个空对象，从而避免出现运行时异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String value = getValue();</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        value = <span class="string">"NO VALUE"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        value = value..toUpperCase();</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRandomBoolean() ? <span class="keyword">null</span> : <span class="string">"VERY GOOD"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getRandomBoolean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//0 为 true ，1为 false</span></span><br><span class="line">    <span class="keyword">return</span> random.nextInt(<span class="number">2</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将 getValue() 重构一下，将返回类型由 String 变成 <code>Optional&lt;String&gt;</code> ，这时候的代码就变成了一个链式结构。不但降低了之前的复杂度，也提高了可读性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String value = getValue().map(String::toUpperCase)</span><br><span class="line">            .orElse(<span class="string">"NO VALUE"</span>);</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Optional&lt;String&gt; <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRandomBoolean() ? Optional.empty() : Optional.of(<span class="string">"VERY GOOD"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="其他常见用法示例"><a href="#其他常见用法示例" class="headerlink" title="其他常见用法示例"></a>其他常见用法示例</h3><p>ifPresent&lt;/br&gt;<br>如果存在值，请使用该值调用指定的 Consumer ，否则不做处理。依然引用上面的代码，这里就只会打印 VERY GOOD 或者不打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestExample2_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;String&gt; name = getValue();</span><br><span class="line">    name.ifPresent(x -&gt; &#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>orElseGet&lt;/br&gt;<br>orElseGet 与上面用到的 orElse 方法大致类似。区别在于得到的默认值。orElse 方法将传入的字符串作为默认值，orElseGet 方法可以接受 Supplier 接口的实现用来生成默认值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestExample2_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String value = getValue().map(String::toUpperCase)</span><br><span class="line">            .orElseGet(()-&gt;<span class="string">"NO VALUE"</span>);</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>flatMap&lt;/br&gt;<br>这个方法也与上面 map 的用法类似，区别在于 map 的会将结果转为 Optional ,即 result-&gt;Optional.of(result) ,而 flatmap 的结果必须就是 Optional 类型，即 Optional -&gt; Optional：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestExample2_3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;Flight&gt; flight = Optional.of(<span class="keyword">new</span> Flight());</span><br><span class="line">    String value = flight.flatMap(Flight::getDeparture)</span><br><span class="line">            .map(Location::getName)</span><br><span class="line">            .get();</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flight</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Location departure;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里返回 Optional，看 flatMap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;Location&gt; <span class="title">getDeparture</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> Optional.of(departure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里返回 String，看 map</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>filter&lt;/br&gt;<br>如果值存在，并且该值与给定的条件过滤，返回过滤后描述该值的 Optional ，否则返回一个空的 Optional ,这里直接接着刚刚 flatMap 示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestExample2_4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;Flight&gt; flight = Optional.of(<span class="keyword">new</span> Flight());</span><br><span class="line">    String value = flight.flatMap(Flight::getDeparture)</span><br><span class="line">            .map(Location::getName)</span><br><span class="line">            .filter(item-&gt;<span class="string">"Good"</span>.equals(item))</span><br><span class="line">            .get();</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Optional 提供了许多方法方便开发者更平滑的处理 null 情况，并且 Optional 的 api 支持我们以函数式的方法或通过 lambda 语句来调用。这样的代码看起来更简洁，可读性也更高。但是将原始值包装到 Optional 实例中，在紧密循环中的性能问题就有待考究。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>还在过滤替换字符来防止 XSS 注入？利用一下浏览器特性！</title>
      <link href="2021/12/31/%E8%BF%98%E5%9C%A8%E8%BF%87%E6%BB%A4%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E6%9D%A5%E9%98%B2%E6%AD%A2-XSS-%E6%B3%A8%E5%85%A5%EF%BC%9F%E5%88%A9%E7%94%A8%E4%B8%80%E4%B8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%B9%E6%80%A7%EF%BC%81/"/>
      <url>2021/12/31/%E8%BF%98%E5%9C%A8%E8%BF%87%E6%BB%A4%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E6%9D%A5%E9%98%B2%E6%AD%A2-XSS-%E6%B3%A8%E5%85%A5%EF%BC%9F%E5%88%A9%E7%94%A8%E4%B8%80%E4%B8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%B9%E6%80%A7%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-XSS-攻击"><a href="#什么是-XSS-攻击" class="headerlink" title="什么是 XSS 攻击"></a>什么是 XSS 攻击</h2><p>在跨站脚本（XSS）攻击中，攻击者可以在受害者的浏览器中执行恶意脚本。这种攻击通常是通过在网页中插入恶意代码 (JavaScript) 来完成的。攻击者在使用攻击后一般能够：</p><ul><li>修改网页内容</li><li>将用户重定向到其他网站</li><li>访问用户的 Cookie 并利用此信息来冒充用户</li><li>访问有关用户系统的关键信息，例如地理位置，网络摄像头，文件系统</li><li>将木马功能注入应用程序</li></ul><p>如果被攻击的用户在应用程序中具有更高的权限。攻击者可以完全控制应用程序，并破坏所有用户及其数据。</p><h2 id="XSS-攻击类型"><a href="#XSS-攻击类型" class="headerlink" title="XSS 攻击类型"></a>XSS 攻击类型</h2><p>常见的 XSS 攻击主要有三种：存储型 XSS 攻击，反射型 XSS 攻击和 DOM-based 型 XSS 攻击。</p><ul><li>存储型主要是将 XSS 代码保存在服务端（数据库、文件系统等），当用户以后再次请求该资源时重新解析该 XSS 代码，从而出现攻击。</li><li>反射型主要发生在一个应用程序使用动态页面向用户显示错误消息时，如果消息中注入了恶意代码就会造成 XSS 反射型攻击。</li><li>DOM-based 主要是通过脚本直接修改客户端的 DOM 结构，一般这种都是属于前端 JavaScript 的漏洞。</li></ul><h2 id="如何阻止-XSS-注入"><a href="#如何阻止-XSS-注入" class="headerlink" title="如何阻止 XSS 注入"></a>如何阻止 XSS 注入</h2><p>下面是一个简单的POST方法，模拟创建 Book 并将其保存到数据库中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/books"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    IBookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveBook</span><span class="params">(@RequestBody Book book)</span> </span>&#123;</span><br><span class="line">        bookService.save(book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在保存的时候，对 type 值做一段 js 注入，来模拟存储型 XSS 攻击。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27ad49ce74f24a6a8ef8ab5156ec9fff~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>现在我们来请求一下，这里的 JavaScript 只会 alert 一个语句，但这种漏洞就有可能被别人利用来注入一些其他的恶意代码：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1910a2a1930e459db51066b455b848e9~tplv-k3u1fbpfcp-watermark.image" alt="http_get1.gif"></p><h3 id="X-XSS-Protection-响应头"><a href="#X-XSS-Protection-响应头" class="headerlink" title="X-XSS-Protection 响应头"></a>X-XSS-Protection 响应头</h3><p>一些浏览器内置了对过滤反射型 XSS 攻击的支持。在一定程度上有助于 XSS 保护。 我们需要在 HTTP 响应头添加如下内容确保已启用该功能，并指示浏览器在检测到 XSS 攻击时进行阻止。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-XSS-Protection: 1; mode=block</span><br></pre></td></tr></table></figure><p>如果你的项目引入了 <code>Spring Security</code> ,那么默认情况下就会自动添加此标头。</p><h3 id="添加Content-Security-Policy响应标头"><a href="#添加Content-Security-Policy响应标头" class="headerlink" title="添加Content-Security-Policy响应标头"></a>添加Content-Security-Policy响应标头</h3><p>兼容 <a href="https://juejin.cn/post/6844904006733529096" target="_blank" rel="noopener">内容安全策略（CSP）</a> 浏览器将仅执行从我们的“允许”列出的域接收的源文件中加载的脚本，而忽略所有其他脚本，例如内联脚本。我们可以添加以下标头来启用浏览器的内容安全策略功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity httpSecurity)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        httpSecurity</span><br><span class="line">                .csrf().disable()<span class="comment">//为了简化示例并更清楚地说明XSS注入，此处禁用了CSRF保护。真实情况请勿使用。</span></span><br><span class="line">                .authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                .and().httpBasic()</span><br><span class="line">                .and()</span><br><span class="line">                .headers().contentSecurityPolicy(<span class="string">"script-src 'self'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是所有支持 CSP 的浏览器：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1193d4a15f6a48eda62f70a3f88e6014~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="入参验证"><a href="#入参验证" class="headerlink" title="入参验证"></a>入参验证</h3><p>我们知道该字段仅需要中文英文和数字字符，因此我们可以使用 Spring 的 Validator 在字段中添加@Pattern注解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="meta">@Pattern</span>(message=<span class="string">"种类只能支持中文英文数字"</span>, regexp = <span class="string">"[\u4e00-\u9fa5_a-zA-Z0-9]+"</span>)</span><br><span class="line"><span class="keyword">private</span> String type;</span><br></pre></td></tr></table></figure></p><p>然后将 @Valid 添加到接收 Book 的方法中，这样当发生请求时就会自动验证：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveBook</span><span class="params">(@RequestBody @Valid Book book)</span> </span>&#123;</span><br><span class="line">    bookService.save(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>现在主流的几种前端框架，像 Angular 、 React 、 Vue 也可以避免传统开发可能带来的问题：</p><ul><li>为了系统地阻止 XSS 错误，默认情况下，Angular 将所有值视为不可信。当通过属性，属性，样式，类绑定或插值将值从模板插入 DOM 时，Angular 会清理并转义不受信任的值。</li><li>使用 JSX(React) 可以传递一个函数作为事件处理程序，而不是传递可能包含恶意代码的字符串。</li><li>React 视图中的字符串变量将自动转义。</li><li>Vue 的官方文档也有说明， <code>v-html</code> 动态的渲染任意 html 是十分危险的，容易引发 XSS 注入，所以 v-html 永远不要用于用户提交的信息上。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>防止 XSS 漏洞主要涉及以下措施的组合：</p><ul><li>利用 X-XSS-Protection 响应头，利用浏览器的支持来限制反射的 XSS 攻击。</li><li>利用 Content-Security-Policy 响应头来启用浏览器的 CSP 功能。</li><li>使用 Validator 对输入信息做相关校验。</li><li>客户端方面 React 使用 JSX 传递函数作为事件处理程序，Vue 只在可信内容上使用 v-html ，对用户输入的信息，一定要禁止使用 v-html 。 </li></ul>]]></content>
      
      
      <categories>
          
          <category> Fronted </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[译]垃圾收集器算法--ZGC</title>
      <link href="2021/12/31/%E8%AF%91-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%AE%97%E6%B3%95-ZGC/"/>
      <url>2021/12/31/%E8%AF%91-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%AE%97%E6%B3%95-ZGC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="https://medium.com/globant/the-z-garbage-collector-algorithm-jdk-15-version-ca6da00b5281" target="_blank" rel="noopener">The Z Garbage Collector algorithm</a><br>原文作者：<a href="https://medium.com/@jenaiz" target="_blank" rel="noopener">Jesús Navarrete</a><br>译者：<a href="https://juejin.cn/user/3175045312547640" target="_blank" rel="noopener">maybelence</a></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://openjdk.java.net/jeps/333" target="_blank" rel="noopener">ZGC</a> 最早作为 JDK11 中的预览特性发布， 去年 9 月 15 号，<br>随着 JDK 15 的正式发布，也带来了 ZGC 的<a href="https://openjdk.java.net/jeps/377" target="_blank" rel="noopener">正式版本</a>。</p><p>ZGC 是可伸缩的低延迟垃圾收集器，最大 GC 暂停时间为 10 毫秒，能够处理从几兆字节到几 TB 的堆，最大吞吐量降低了 15％。</p><h2 id="JVM-垃圾收集器"><a href="#JVM-垃圾收集器" class="headerlink" title="JVM 垃圾收集器"></a>JVM 垃圾收集器</h2><p>截止目前，JVM 已经引入了一系列有趣的垃圾收集算法。下面列出了几个最重要的垃圾收集算法:</p><ul><li>串行（低内存占用）：使用单线程来工作，适用于单处理器计算机，并且针对内存不足（嵌入式系统）进行了优化。</li><li>并行（吞吐量收集器）：并行进行次要收集，以减少垃圾收集的开销。适用于多处理器硬件上运行的中型到大型数据集应用程序。</li><li>CMS（并发标记扫描收集器）：具有较短的垃圾收集器暂停时间。专为具有大量长寿命对象或大量使用期限的应用程序而设计。</li><li>G1（吞吐量/等待时间平衡）：Garbage-First 是服务器样式的垃圾收集器，适用于具有大内存的多处理器计算机。它试图以高概率满足 GC 暂停时间目标，同时实现高吞吐量。全堆操作（例如全局标记）与应用程序线程同时执行。这样可以防止与堆或活动数据大小成比例的中断。</li><li>ZGC（低延迟）</li></ul><blockquote><p>串行和并行称为 <em>stop of the world</em> 算法。 CMS 在 JDK 9 中已弃用，用 G1 代替。</p></blockquote><p>这里要强调 ZGC 可以并行处理所有繁重的操作，而其他算法却无法做到（具体细节见下文）。</p><hr><h2 id="深入了解-ZGC"><a href="#深入了解-ZGC" class="headerlink" title="深入了解 ZGC"></a>深入了解 ZGC</h2><p>ZGC 是一种并发的低延迟算法，除了线程堆栈扫描外，它所有其他操作（标记，压缩，参考处理，重定位集选择，StringTable 清理，JNI WeakRef 清理，JNI GlobalRefs 扫描和类卸载）都是并行的。所以该算法对于低延迟确实非常有用。</p><p>ZGC 暂停时间并不随堆或活动大小而增加，而是与根集合的一个子集的大小相关（您的应用程序正在使用的Java线程数）。也就是仍然在 <em>Stop-The-World</em> 阶段扫描线程栈。<code>但是从 JDK 16 开始，对线程栈的扫描是并行处理的，也就是说在扫描栈的时候应用程序可以同时运行。</code></p><blockquote><p>原作者写的时候是 JDK15 ,这里我补充了一下 JDK 16 对 ZGC 的变化</p></blockquote><p>从算法的角度来看，它是一个并发收集器，它在 Java 线程继续执行的同时完成了所有繁重的工作。它是一个基于区域的收集器，这意味着将堆划分为较小的区域，并且压缩工作将集中于这些区域的子集，即那些垃圾最多的区域。它是 <a href="https://www.ibm.com/docs/zh/sdk-java-technology/7?topic=bgcp-numa-awareness" target="_blank" rel="noopener">NUMA感知</a> 的，由于 CPU 具有本地内存，因此可以减少延迟。它使用彩色指针和负载屏障，将在以下各节中进行详细介绍。而且它是一个单一的一代收集器，它没有以前回收机制的年轻代或老年代。</p><h3 id="ZGC-阶段"><a href="#ZGC-阶段" class="headerlink" title="ZGC 阶段"></a>ZGC 阶段</h3><p>ZGC 的 GC 周期分为三个阶段。</p><p>在第一阶段（暂停标记开始）中，ZGC遍历对象图以将对象标记为活动或无用。此阶段还包括重新映射实时数据。</p><p>第二阶段是“暂停标记结束”，此阶段完成参考预处理。在该阶段还完成了类卸载和重定位集的选择。</p><p>暂停重定位启动是最后一个阶段，在此阶段要进行大量的压缩堆工作。</p><h3 id="彩色指针"><a href="#彩色指针" class="headerlink" title="彩色指针"></a>彩色指针</h3><p>这是 ZGC 中的核心设计概念。该算法使用 64 位对象指针中的一些未使用的位来存储一些元数据，从而可以查找，标记，定位和重新映射对象。下图显示了 64 位对象指针和每个位的含义。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50bbf2c577e34151a2ea76a20125e718~tplv-k3u1fbpfcp-watermark.image" alt="Colored pointers diagram"></p><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>它是 JAVA 即时编译器在某些重要位置注入的代码。目的是检查加载的对象引用是否具有不良的颜色。当线程从堆中加载对象引用时，将运行负载屏障代码。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a63e77d1acc4b868406d3b857afa7e2~tplv-k3u1fbpfcp-watermark.image" alt="Load Barrier example"></p><h3 id="调优选项"><a href="#调优选项" class="headerlink" title="调优选项"></a>调优选项</h3><p>从 JDK 11 到 JDK 15 发行版，如果要使用 ZGC 算法，必须解锁实验选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</span><br></pre></td></tr></table></figure><p>如果是 JDK 15 之后的版本，只需要指定一下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseZGC</span><br></pre></td></tr></table></figure></p><p>ZGC 的设计易于调整。下面是特定的 ZGC 选项的列表：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bf5068e18b9427a9d8fe09d361759ed~tplv-k3u1fbpfcp-watermark.image" alt="1_EoA3uGFcAOlXnFz2DddfJg.png"></p><p>为了知道使用的时间并查看有关算法行为的一些数字，我们可以打印一些垃圾收集器日志，选择 ZGC 来查看简单日志时，只需添加以下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseZGC -Xmx&lt;size&gt; -Xlog:gc</span><br></pre></td></tr></table></figure><p>如果您想打印带有更多详细信息的垃圾收集器日志，可以执行以下操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseZGC -Xmx&lt;size&gt; -Xlog:gc*</span><br></pre></td></tr></table></figure><br>接下来让我们看看其他有趣的调优选项。</p><h3 id="设置堆大小"><a href="#设置堆大小" class="headerlink" title="设置堆大小"></a>设置堆大小</h3><p>ZGC 中最重要的调整选项之一是设置最大堆大小 (<code>-Xmx&lt;size&gt;</code>) 。我们必须为我们的应用程序找到正确的值，因为我们不想丢失内存，并且希望在 GC 运行时允许我们的应用程序有足够的空间用于活动对象和分配。以下是使用示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseZGC Xmx&lt;size&gt;</span><br></pre></td></tr></table></figure><h3 id="设置-GC-并发线程"><a href="#设置-GC-并发线程" class="headerlink" title="设置 GC 并发线程"></a>设置 GC 并发线程</h3><p>尽管 ZGC 具有启发式功能，可以自动选择此数字，但有时，根据我们的应用程序，指定并发 GC 线程数可能会很有趣。此选项确定 GC 将占用多少 CPU，因此您必须小心要提供的容量。</p><h3 id="将未使用的内存返回到操作系统"><a href="#将未使用的内存返回到操作系统" class="headerlink" title="将未使用的内存返回到操作系统"></a>将未使用的内存返回到操作系统</h3><p>区别于其他的 GC 算法，ZGC 取消提交未使用的内存，将其返回给操作系统。对于可能会占用内存的应用程序，这可能是必需的。如果要禁用此选项，则可以使用 <code>-XX：-ZUncommit</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseZGC -Xmx&lt;size&gt; -XX:-ZUncommit</span><br></pre></td></tr></table></figure><h3 id="在-Linux-上启用大页面"><a href="#在-Linux-上启用大页面" class="headerlink" title="在 Linux 上启用大页面"></a>在 Linux 上启用大页面</h3><p>此选项可提高性能，而且没有任何隐患。唯一的问题是它需要 root 授权，这就是为什么它不是默认选项，并且可能无法为您的应用程序启用它的原因。查看文档以正确设置此选项。它需要准备一些东西，选项如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseZGC -Xms16G -Xmx16G -XX:+UseLargePages</span><br></pre></td></tr></table></figure></p><h3 id="在-Linux-上启用透明的大页面"><a href="#在-Linux-上启用透明的大页面" class="headerlink" title="在 Linux 上启用透明的大页面"></a>在 Linux 上启用透明的大页面</h3><p>不建议将 Huges 页面用于对延迟敏感的应用程序，尽管它可以替代以前的调整选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseZGC -… -XX:+UseLargePages -XX:+UseTransparentHugePages</span><br></pre></td></tr></table></figure><p>在这种情况下，我强烈建议您在应用程序中进行试验，并注意峰值，如果出现峰值，那么您可能就无法选择这种情况。</p><h3 id="启用-NUMA-支持"><a href="#启用-NUMA-支持" class="headerlink" title="启用 NUMA 支持"></a>启用 NUMA 支持</h3><p>ZGC 在默认情况下启用 NUMA 支持。这会将 Java 堆分配定向到 NUMA 本地内存。JVM 可以自动禁用它，如果您需要显式覆盖行为，则可以使用选项 -XX：+ UseNUMA或-XX：-UseNUMA。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseZGC -Xmx&lt;size&gt; -XX:+UseNUMA</span><br></pre></td></tr></table></figure><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseZGC -Xmx&lt;size&gt; -XX:-UseNUMA</span><br></pre></td></tr></table></figure></p><p>该算法的 <a href="https://wiki.openjdk.java.net/display/zgc/Main" target="_blank" rel="noopener">Wiki</a> 页面上还有更多详细的信息。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
            <tag> JAVA8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手实现一个迷宫机器人</title>
      <link href="2021/09/23/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%B7%E5%AE%AB%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
      <url>2021/09/23/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%B7%E5%AE%AB%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<p>很久没有产出，回过头来看看这些日子，好像又没有什么有趣的技术积累。突然想起来之前帮朋友做了个小作业做的一个迷宫机器人。虽然不高级但是还是挺好玩的。下面就给大家分享一下过程。</p><h3 id="地图绘制"><a href="#地图绘制" class="headerlink" title="地图绘制"></a>地图绘制</h3><p>首先定义出地图的宽和高，利用一个二维数组来保存地图的地形。 spawnMarker 用于存储机器人出生点位置。 robots 用于存放迷宫中机器人的当前状态。 controller 用于接收键盘/鼠标事件并传给 World。 Renderer 用于将 2D 字符地图渲染成图形。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">World</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width, height;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[][] terrain;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> FIRST_TERRAIN = <span class="string">' '</span>, LAST_TERRAIN = <span class="string">'~'</span>; <span class="comment">//地图上能展示的ASCII 方便用于机器人说话</span></span><br><span class="line">    <span class="keyword">private</span> Position[] spawnMarker = <span class="keyword">new</span> Position[<span class="number">10</span>]; <span class="comment">//from digits 0 to 9</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Robot&gt; robots = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Controller controller = <span class="keyword">new</span> Controller(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> Renderer renderer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> targetFrametime = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> pause = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> currentFrame = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> pauseAtFrame = -<span class="number">1</span>; <span class="comment">//will pause if current frame equals this, set to &lt;0 to not use</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Method work, memoryToString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述工作做完之后，我们就来看一下如何将下面的 2D 字符渲染成图案。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String mazeMap =</span><br><span class="line"></span><br><span class="line">        <span class="string">"###################\n"</span> +</span><br><span class="line">        <span class="string">"#  0H  #   ##    #  $\n"</span> +</span><br><span class="line">        <span class="string">"#  #a ##   ## ## #  #\n"</span> +</span><br><span class="line">        <span class="string">"####p  # #     #   ##\n"</span> +</span><br><span class="line">        <span class="string">"#  yp  #    ## ##   #\n"</span> +</span><br><span class="line">        <span class="string">"#  #  Mid # ##Automn#\n"</span> +</span><br><span class="line">        <span class="string">"#####################"</span>;</span><br><span class="line"></span><br><span class="line">World world = <span class="keyword">new</span> World(mazeMap);</span><br><span class="line">Robot robot = makeMazeRunner();</span><br><span class="line">robot.spawnInWorld(world, <span class="string">'0'</span>);</span><br><span class="line">world.run();</span><br></pre></td></tr></table></figure><br>首先通过 World 的构造函数将地图数据构建出来，并放置机器人出生点，并默认渲染地图数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//constructs the world from the "2D" String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">World</span><span class="params">(String mapData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(mapData, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//you should probably leave shouldRender to true, otherwise you will not see anything</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">World</span><span class="params">(String mapData, <span class="keyword">boolean</span> shouldRender)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldRender)</span><br><span class="line">        renderer = <span class="keyword">new</span> Renderer();</span><br><span class="line"></span><br><span class="line">    width = mapData.lines().mapToInt(String::length).max().orElseThrow();</span><br><span class="line">    height = (<span class="keyword">int</span>) mapData.lines().count();</span><br><span class="line"></span><br><span class="line">    terrain = <span class="keyword">new</span> <span class="keyword">char</span>[width][height];</span><br><span class="line">    String[] rows = mapData.lines().map(s -&gt; s + <span class="string">" "</span>.repeat(width - s.length())).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; height; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; width; x++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = rows[y].charAt(x);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>)</span><br><span class="line">                spawnMarker[c - <span class="string">'0'</span>] = <span class="keyword">new</span> Position(x + <span class="number">0.5</span>, y + <span class="number">0.5</span>);</span><br><span class="line">            terrain[x][y] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        work = Robot.class.getMethod("work");</span><br><span class="line">        memoryToString = Robot.class.getMethod("memoryToString");</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="comment">/* student has not implemented these methods yet */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着通过 World 的 run() 方法来渲染地图数据。具体的 Renderer 类细节就不描述了，整体的源码链接我会贴在文章结尾。渲染后地图大致是这个样子：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d196e480f3045208ff894b83f3dcf28~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>俯视图是这样的：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d43f5c330f64457c82fe979e0cb5036a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    if(renderer !&#x3D; null)</span><br><span class="line">        renderer.setup();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if(renderer !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; wait until unpaused</span><br><span class="line">                while (pause || currentFrame &#x3D;&#x3D; pauseAtFrame)</span><br><span class="line">                    Thread.sleep(50);</span><br><span class="line"></span><br><span class="line">                long before &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">                simulateFrame();</span><br><span class="line">                renderer.render();</span><br><span class="line"></span><br><span class="line">                long frametime &#x3D; System.currentTimeMillis() - before;</span><br><span class="line">                long sleepTime &#x3D; targetFrametime - frametime;</span><br><span class="line">                if (sleepTime &gt; 0)</span><br><span class="line">                    Thread.sleep(sleepTime);</span><br><span class="line">            &#125; else</span><br><span class="line">                simulateFrame();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        &#x2F;* Intentionally left blank *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="迷宫机器人"><a href="#迷宫机器人" class="headerlink" title="迷宫机器人"></a>迷宫机器人</h3><p>接着我们来看 Robot 类。机器人的变量相对而言就变得比较简单，name 和 size 用于描述机器人的姓名大小。 position ，direction ，world 描述机器人当前状态。memory 和 sensors 用于存储机器人的记忆和感知。 todo 和 program 用于存储机器人要做的一系列指令。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Position position = <span class="keyword">new</span> Position();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> direction;</span><br><span class="line">    <span class="keyword">private</span> World world;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// memory expand</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Memory&lt;?&gt;&gt; memory = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sensor expand</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Sensor&lt;?&gt;&gt; sensors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Command&gt; todo = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Function&lt;Robot, List&lt;Command&gt;&gt; program = <span class="keyword">new</span> Function&lt;Robot, List&lt;Command&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Command&gt; <span class="title">apply</span><span class="params">(Robot robot)</span> </span>&#123;</span><br><span class="line">            List&lt;Command&gt; commands = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            commands.addAll(todo);</span><br><span class="line">            <span class="keyword">return</span> commands;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>既然机器人要走迷宫，那走和调整方向的方法肯定是必不可少的。这里 turnBy 表示在当前方向上面顺延多少角度，turnTo 表示直接转向新的方向。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Pre-programmed Commands</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">go</span><span class="params">(<span class="keyword">double</span> distance)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//step can be negative if the penguin walks backwards</span></span><br><span class="line">    <span class="keyword">double</span> sign = Math.signum(distance);</span><br><span class="line">    distance = Math.abs(distance);</span><br><span class="line">    <span class="comment">//penguin walks, each step being 0.2m</span></span><br><span class="line">    <span class="keyword">while</span> (distance &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        position.moveBy(sign * Math.min(distance, <span class="number">0.2</span>), direction);</span><br><span class="line">        world.resolveCollision(<span class="keyword">this</span>, position);</span><br><span class="line">        distance -= <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">turnBy</span><span class="params">(<span class="keyword">double</span> deltaDirection)</span> </span>&#123;</span><br><span class="line">    direction += deltaDirection;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">turnTo</span><span class="params">(<span class="keyword">double</span> newDirection)</span> </span>&#123;</span><br><span class="line">    direction = newDirection;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里还给机器人加了一个 say 的方法，因为之前 World 中定义了有一些字符在地图中是可以直接打印并且不被渲染的。当机器人走到这个字符上，我希望能够让机器人说出这个字符。因为最后是一个 gui 的打印所以还是调用了 World 中的 say方法来渲染这个字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">say</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    world.say(<span class="keyword">this</span>, text);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我调整了一下 ASCII 的打印范围，让地图能够顺利渲染出中秋快乐的文字，让我们来看一下这个机器人是如何说出中秋快乐的吧：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e73745b4c414870be7fdbf964704950~tplv-k3u1fbpfcp-watermark.image?" alt="中秋2.gif"></p><p>接下来就开始我们最重要的走迷宫环节啦。在不知道迷宫复杂度的情况，又不能人为预设路线。所以需要我们对于未知路线，如何让机器人做出正确指令有一些思考。</p><p>我当时应该是参考了这个图片，但是具体的算法应该还是与这个有些出入的。奈何自己没有做注释，现在都看不懂当时是怎么想的了。所以作为一名 coder，注释真的很重要！<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a470f6c1fe59404e9c180853594060a8~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>这是我当时的代码，比较好玩的是，只要地图是可以通向终点的，哪怕地图内部不通，但是多一个口从外部也能连接终点。机器人也是可以找到终点的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Robot <span class="title">makeMazeRunner</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Robot panicPenguin = <span class="keyword">new</span> Robot(<span class="string">"Maze!"</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create memory</span></span><br><span class="line">    Memory&lt;Character&gt; terrain = panicPenguin.createMemory(<span class="keyword">new</span> Memory&lt;&gt;(<span class="string">"terrain"</span>, <span class="string">'0'</span>));</span><br><span class="line">    Memory&lt;Character&gt; end = panicPenguin.createMemory(<span class="keyword">new</span> Memory&lt;&gt;(<span class="string">"end"</span>, <span class="string">'$'</span>));</span><br><span class="line">    <span class="comment">// create and attach sensors</span></span><br><span class="line">    panicPenguin.attachSensor(<span class="keyword">new</span> TerrainSensor().setProcessor(terrain::setData));</span><br><span class="line">    panicPenguin.attachSensor(<span class="keyword">new</span> TerrainSensor().setProcessor(end::setData));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// program the robot</span></span><br><span class="line">    panicPenguin.setProgram(robot -&gt; &#123;</span><br><span class="line">        Position position = robot.getPosition();</span><br><span class="line">        List&lt;Command&gt; commands = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(end.getData().toString(), <span class="string">"$"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> commands;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (dir) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">'#'</span> != robot.getWorld().getTerrain(position.x + <span class="number">1</span>, position.y)) &#123;</span><br><span class="line">                    commands.add(r -&gt; r.turnTo(<span class="number">0</span>));</span><br><span class="line">                    commands.add(r -&gt; r.say(terrain.getData().toString()));</span><br><span class="line">                    commands.add(r -&gt; r.go(<span class="number">1</span>));</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> commands;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">'#'</span> != robot.getWorld().getTerrain(position.x, position.y - <span class="number">1</span>)) &#123;</span><br><span class="line">                        commands.add(r -&gt; r.turnTo(<span class="number">1.5</span> * Math.PI));</span><br><span class="line">                        commands.add(r -&gt; r.say(terrain.getData().toString()));</span><br><span class="line">                        commands.add(r -&gt; r.go(<span class="number">1</span>));</span><br><span class="line">                        <span class="keyword">return</span> commands;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        commands.add(r -&gt; r.turnTo(Math.PI));</span><br><span class="line">                        commands.add(r -&gt; r.say(terrain.getData().toString()));</span><br><span class="line">                        commands.add(r -&gt; r.go(<span class="number">1</span>));</span><br><span class="line">                        dir = <span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">return</span> commands;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">'#'</span> != robot.getWorld().getTerrain(position.x, position.y + <span class="number">1</span>)) &#123;</span><br><span class="line">                    commands.add(r -&gt; r.turnTo(Math.PI * <span class="number">0.5</span>));</span><br><span class="line">                    commands.add(r -&gt; r.say(terrain.getData().toString()));</span><br><span class="line">                    commands.add(r -&gt; r.go(<span class="number">1</span>));</span><br><span class="line">                    dir = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">return</span> commands;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">'#'</span> != robot.getWorld().getTerrain(position.x + <span class="number">1</span>, position.y)) &#123;</span><br><span class="line">                        commands.add(r -&gt; r.turnTo(<span class="number">0</span>));</span><br><span class="line">                        commands.add(r -&gt; r.say(terrain.getData().toString()));</span><br><span class="line">                        commands.add(r -&gt; r.go(<span class="number">1</span>));</span><br><span class="line">                        <span class="keyword">return</span> commands;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        commands.add(r -&gt; r.turnTo(<span class="number">1.5</span> * Math.PI));</span><br><span class="line">                        commands.add(r -&gt; r.say(terrain.getData().toString()));</span><br><span class="line">                        commands.add(r -&gt; r.go(<span class="number">1</span>));</span><br><span class="line">                        dir = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">return</span> commands;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">'#'</span> != robot.getWorld().getTerrain(position.x - <span class="number">1</span>, position.y)) &#123;</span><br><span class="line">                    commands.add(r -&gt; r.turnTo(Math.PI));</span><br><span class="line">                    commands.add(r -&gt; r.say(terrain.getData().toString()));</span><br><span class="line">                    commands.add(r -&gt; r.go(<span class="number">1</span>));</span><br><span class="line">                    dir = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">return</span> commands;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">'#'</span> != robot.getWorld().getTerrain(position.x, position.y + <span class="number">1</span>)) &#123;</span><br><span class="line">                        commands.add(r -&gt; r.turnTo(Math.PI * <span class="number">0.5</span>));</span><br><span class="line">                        commands.add(r -&gt; r.say(terrain.getData().toString()));</span><br><span class="line">                        commands.add(r -&gt; r.go(<span class="number">1</span>));</span><br><span class="line">                        <span class="keyword">return</span> commands;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        commands.add(r -&gt; r.turnTo(<span class="number">0</span>));</span><br><span class="line">                        commands.add(r -&gt; r.say(terrain.getData().toString()));</span><br><span class="line">                        commands.add(r -&gt; r.go(<span class="number">1</span>));</span><br><span class="line">                        dir = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">return</span> commands;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">'#'</span> != robot.getWorld().getTerrain(position.x, position.y - <span class="number">1</span>)) &#123;</span><br><span class="line">                    commands.add(r -&gt; r.turnTo(<span class="number">1.5</span> * Math.PI));</span><br><span class="line">                    commands.add(r -&gt; r.say(terrain.getData().toString()));</span><br><span class="line">                    commands.add(r -&gt; r.go(<span class="number">1</span>));</span><br><span class="line">                    dir = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> commands;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">'#'</span> != robot.getWorld().getTerrain(position.x - <span class="number">1</span>, position.y)) &#123;</span><br><span class="line">                        commands.add(r -&gt; r.turnTo(Math.PI));</span><br><span class="line">                        commands.add(r -&gt; r.say(terrain.getData().toString()));</span><br><span class="line">                        commands.add(r -&gt; r.go(<span class="number">1</span>));</span><br><span class="line">                        <span class="keyword">return</span> commands;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        commands.add(r -&gt; r.turnTo(Math.PI * <span class="number">0.5</span>));</span><br><span class="line">                        commands.add(r -&gt; r.say(terrain.getData().toString()));</span><br><span class="line">                        commands.add(r -&gt; r.go(<span class="number">1</span>));</span><br><span class="line">                        dir = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">return</span> commands;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> commands;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> panicPenguin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面来一起看一下各种好玩的效果图吧。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb6bbb97fa7e49f587711a508f7ed9ec~tplv-k3u1fbpfcp-watermark.image?" alt="中秋.gif"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9624ee795bdd45e8a94b1f12279320c4~tplv-k3u1fbpfcp-watermark.image?" alt="中秋3.gif"></p><h3 id="源码链接"><a href="#源码链接" class="headerlink" title="源码链接"></a>源码链接</h3><p><a href="https://github.com/liujiang157/Maze" target="_blank" rel="noopener">源码链接</a>，祝大家🥮节快乐~</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quarkus与Spring boot性能对比</title>
      <link href="2021/04/20/Quarkus%E4%B8%8ESpring-boot%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"/>
      <url>2021/04/20/Quarkus%E4%B8%8ESpring-boot%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<p>目前市场上主流的框架基本都是 <code>Spring</code> 全家桶系列， <code>Srping</code> 的生态完善也是众多开发者非常青睐这个框架的原因之一。但是我们今天主要从内存管理和性能方面看一下 <code>Quarkus</code> 和 <code>Spring Boot</code> 的区别。</p><h2 id="什么是-Quarkus-？"><a href="#什么是-Quarkus-？" class="headerlink" title="什么是 Quarkus ？"></a>什么是 Quarkus ？</h2><p>官网是这样定义的，<code>Quarkus</code> 是针对 Java 虚拟机 (JVM) 和本机编译的全栈 <code>Kubernetes</code> 本地 Java 框架，专门针对容器优化 Java ，使其成为无服务器，云和 Kubernetes 环境的有效平台。</p><h2 id="构建程序"><a href="#构建程序" class="headerlink" title="构建程序"></a>构建程序</h2><p>为了直观的比较两个框架的区别，这两个程序都将只引入  Spring Web 依赖。</p><h3 id="构建-Quarkus-应用"><a href="#构建-Quarkus-应用" class="headerlink" title="构建 Quarkus 应用"></a>构建 Quarkus 应用</h3><p>我们可以在 <a href="https://code.quarkus.io/" target="_blank" rel="noopener">Quarkus 官网</a>构建我们的 Quarkus 应用，注意我们只选择了 <code>Spring Web API</code> 依赖。</p><pre><code>var askSky = () =&gt; {    return 🌕.exists() ? new 🍺 : null;}</code></pre><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8727572903114c7fa2ca312e4a6270f9~tplv-k3u1fbpfcp-watermark.image" alt="506(1).jpg"></p><p>下载代码用 IDE 打开之后,我们会发现有一个默认的 <code>SpringGreetingController</code> 类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello-spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringGreetingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Spring"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="构建-Spring-Boot-程序"><a href="#构建-Spring-Boot-程序" class="headerlink" title="构建 Spring Boot 程序"></a>构建 Spring Boot 程序</h3><p>Spring Boot 的构建方法就不用多说了，我们也只选了 <code>Spring Web</code> 依赖。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6c87f646d86469f90953f4613f4dec5~tplv-k3u1fbpfcp-watermark.image" alt="92445.jpg"></p><p>我们修改一下 <code>Spring</code> 构建后的代码，添加 <code>SpringGreetingController</code> 至 Spring Boot 项目中。</p><h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p>完成了上述工作，不知道你是否发现 <code>Quarkus</code> 并没有像 <code>Spring Boot</code> 一样的 <code>Main</code> 启动函数，也没有部署到Web容器。通过翻阅 <code>Quarkus</code> 官网的介绍，可以看到我们只需要这样一行命令来启动 <code>Quarkus</code> 程序： <code>mvnw compile quarkus:dev</code>。我们再使用 <code>mvnw compile spring-boot:run</code> 将 <code>spring boot</code> 项目运行起来。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5057da8243947d6ae8f02e85d7b5203~tplv-k3u1fbpfcp-watermark.image" alt="0838(1).jpg"></p><p>我们使用 jdk 本身提供的 java 监测的 GUI 工具— <code>jconsole</code> 来检测两个进程的性能情况。</p><h3 id="Quarkus"><a href="#Quarkus" class="headerlink" title="Quarkus"></a>Quarkus</h3><h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05ac6de459ee49caa582c28470654b9f~tplv-k3u1fbpfcp-watermark.image" alt="239fee4e568ac7166cc0c29655b60cc.png"></p><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/290bc288660140198cbd88230b4621c7~tplv-k3u1fbpfcp-watermark.image" alt="f1ddabbb5232fcc4c3a9dcd498ba768.png"></p><h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><h4 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h4><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d76a6bf030224372a409e924fc420a6e~tplv-k3u1fbpfcp-watermark.image" alt="714adcc272e8585b8a9414bc6f3cf63.png"></p><h4 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h4><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa2671baec2b4586aceab1a8a26af2e8~tplv-k3u1fbpfcp-watermark.image" alt="2ced6255ce08b73d3b467500823ff2a.png"></p><p>两个应用程序的直接比较都表明 <code>Quarkus</code> 在启动应用程序时使用了更少的内存。 <code>Spring Boot</code> 使用的内存约为 145 Mb，而Quarkus的内存使用约为 122 Mb。而在类加载上 <code>Quarkus</code> 大约加载了 5303 个类，而 <code>Spring Boot</code> 大约加载了 4785 个类。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>测试结果和我在视频上看到的有一定出入，视频的测试结果是 <code>Quarkus</code> 性能远优于 <code>Spring Boot</code> 的。我的测试也只是给大家一个参考，动手能力强的可以自己去实践一下。</p><blockquote><p>视频地址:  <a href="https://youtu.be/oz-QSGy1DSo" target="_blank" rel="noopener">Quarkus vs Spring Boot - Performance</a> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Frameworks </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[译] 快速理解开闭原则</title>
      <link href="2021/04/20/%E8%AF%91-%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"/>
      <url>2021/04/20/%E8%AF%91-%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="https://levelup.gitconnected.com/the-open-closed-principle-made-simple-cc3d0ed70553" target="_blank" rel="noopener">The Open-Closed principle made simple</a><br>原文作者：<a href="https://mihai-sandu.medium.com/" target="_blank" rel="noopener">Mihai Sandu</a><br>译者：<a href="https://maybelence.cn/">maybelence</a></p></blockquote><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3157c27450b41d98d39467fcb8c42ed~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>原文的示例代码都是采用的 <code>Scala</code> 语言，其实 <code>Scala</code> 本身和 <code>java</code> 的语法非常像，考虑到目前更多的开发者都是 java ，因此我把原文的代码都转成了 java 。一些和 java 语法有冲突的地方也都做了中文注释。</p><hr><p>卡车是一种多功能的设备。他们可以根据车厢挂载的零件类型来执行不同的任务，如果载重允许的话，甚至可以<br>装载多个车厢。</p><p>简而言之，卡车可以通过不同的零件以进行扩展，但不能改装每个零件的内部单元（例如发动机或机舱）。可拓展的代码也应该像卡车挂载零件一样得心应手。</p><h2 id="制冰机问题"><a href="#制冰机问题" class="headerlink" title="制冰机问题"></a>制冰机问题</h2><p>假设我们必须要编写一个程序来为 <em>Ted&amp;Kelly</em> 公司制作可可冰激凌。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCreamMachine</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeIceCream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cacao ice-cream"</span>); <span class="comment">//logic to create cacao ice cream</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将程序交付给客户，虽然这段代码很简单，但是看上去没有什么问题，而且没有违反任何原则。客户目前是非常满意的。</p><p>但是事情并不是到这里就结束了，客户总是会有一些新的需求。这就意味着我们需要不断调整我们的代码。</p><h3 id="添加新的口味"><a href="#添加新的口味" class="headerlink" title="添加新的口味"></a>添加新的口味</h3><p>没想到程序刚上线就如此火爆，于是 <em>Ted＆Kelly</em> 希望扩大规模。他们要求我们还要能够生产香草味的冰激凌。</p><p>短暂思考之后，我们给出了以下解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCreamMachine</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeIceCream</span><span class="params">(String flavor)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"cacao"</span>.equals(flavor))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"Cacao ice-cream"</span>); <span class="comment">//logic to create cacao ice-cream</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"vanilla"</span>.equals(flavor))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"Vanilla ice-cream"</span>); <span class="comment">//logic to create vanilla ice-cream</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Flavor not supported"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们修改了最初的代码，添加了一个参数以指定所需的口味，并添加了 <code>if</code> 语句以在逻辑之间切换。由于我们已经改变了最初的函数签名，因此调用我们代码的方法将被破坏，但是至少从现在开始，我们应该在不破坏更改的情况下支持其他口味的生产。</p><h3 id="创建可可和香草组合"><a href="#创建可可和香草组合" class="headerlink" title="创建可可和香草组合"></a>创建可可和香草组合</h3><p>业务进展顺利，但是很快客户就提出了第二个需求，希望我们能够生产由可可和香草制成的冰淇淋。事情开始变得有点复杂，但是我们仍然能够处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCreamMachine</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeIceCream</span><span class="params">(String flavor)</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"cacao"</span>.equals(flavor))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"Cacao ice-cream"</span>); <span class="comment">//logic to create cacao ice-cream</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"vanilla"</span>.equals(flavor))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"Vanilla ice-cream"</span>); <span class="comment">//logic to create vanilla ice-cream</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"cacao-vanilla"</span>.equals(flavor))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//copy &amp; paste the cacao ice-cream logic</span></span><br><span class="line">            System.out.println(<span class="string">"Cacao ice-cream"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//copy &amp; paste the vanilla ice-cream logic</span></span><br><span class="line">            System.out.println(<span class="string">"Vanilla ice-cream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Flavor not supported"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们又添加了一个 <code>if</code> 语句，在这种情况下，生产冰淇淋的逻辑被复制到每个 <code>if</code> 内部。在实际的应用程序中，我可能会在单独的服务中提取生产的逻辑。但是，正如我们将看到的那样，提取服务并不总是最好的方案。</p><p>当 <em>Ted＆Kelly</em> 要求支持生产更多口味时，会发生什么。如果他想进一步将它们结合起来怎么办？仅添加 <code>if</code> 子句并不是理想的解决方案。</p><h3 id="这种解决方案产生的问题"><a href="#这种解决方案产生的问题" class="headerlink" title="这种解决方案产生的问题"></a>这种解决方案产生的问题</h3><p>每次我们添加新的口味或组合时，我们都必须更新 <code>IceCreamMachine</code> 类，这就意味着：</p><ul><li>我们更新已经部署的代码</li><li>这个类变得越来越复杂，易读性变得越来越差。假设我们有 100 种口味，这个类很容易膨胀到 5000+ 行代码</li><li>我们可能会破坏现有的单元测试</li></ul><p>现在回想一下开头卡车的类比，当你每次更换车厢挂载的零件时，你会每次都更换引擎吗？显然不会，看我们如何解决这个问题。</p><h2 id="传统的可拓展性方法"><a href="#传统的可拓展性方法" class="headerlink" title="传统的可拓展性方法"></a>传统的可拓展性方法</h2><p><em>Bertrand Meyer</em> 是最早提出开闭原则这一术语的人，他定义 “软件实体（类，模块，函数，等） 应当对扩展开放，对修改关闭。”</p><p>换句话说，每当我们需要向旧对象添加新行为时，都可以根据需要继承和更新它们。开闭原则是那些易于理解却难以应用的原则之一。</p><p>让我们遵循这种方法重写刚刚的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseIceCream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">MakeIceCream</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacaoIceCream</span> <span class="keyword">extends</span> <span class="title">BaseIceCream</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeIceCream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cacao ice-cream"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VanillaIceCream</span> <span class="keyword">extends</span> <span class="title">BaseIceCream</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeIceCream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Vanilla ice-cream"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacaoAndVanilla</span> <span class="keyword">extends</span> <span class="title">CacaoIceCream</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeIceCream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.MakeIceCream();</span><br><span class="line">        System.out.println(<span class="string">"Vanilla ice-cream"</span>); <span class="comment">//duplicate vanilla logic because we can't iherit both cacao and vanilla</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原始类分为了四个类，每个类代表一种生产口味。通过此解决方案，我们解决了所有最初的问题：</p><ul><li>每个类都短小精悍，可维护性和易读性都很高</li><li>当需要添加新口味时，我们只需要添加一个新的类</li><li>不会影响现有的单元测试</li></ul><p>代码看起来已经没有任何问题了，我们完全可以到这里就停止思考，但是其实这种解决方案还是存在一些<strong>问题</strong>的：</p><ul><li>不能继承多个类，因此对于两种口味的结合，我们必须复制一些代码或将逻辑提取到服务中</li><li>如果基类中的代码被更新，所有子类都会受到影响。假设基类通过构造函数注入了一些依赖关系，每当我们添加新的依赖关系时，所有子代都必须将该参数解析为基本构造函数</li></ul><h2 id="现在可拓展性的方法"><a href="#现在可拓展性的方法" class="headerlink" title="现在可拓展性的方法"></a>现在可拓展性的方法</h2><p>当 <em>Robert C. Martin</em> 重申 <em>Meyer</em> 的开闭原则时，他做了一些更新。<strong>偏爱继承而不是继承</strong>。</p><p>组合对象时，我们可以自由地随意组合任意数量和所需的组合。而且，如果我们针对抽象类（接口）进行编程，则可以修改已有代码的行为而无需进行修改代码。让我们看看最终的解决方案：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="type">IMakeIceCream</span> &#123;</span><br><span class="line">    void <span class="type">Make</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacaoIceCream</span> <span class="title">implements</span> <span class="title">IMakeIceCream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">IMakeIceCream</span> iceCreamMaker;</span><br><span class="line"></span><br><span class="line">    public <span class="type">CacaoIceCream</span>(<span class="type">IMakeIceCream</span> iceCreamMaker)  <span class="comment">//可选参数，如果不需要另一个口味传null</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.iceCreamMaker = iceCreamMaker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="type">Make</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (iceCreamMaker != <span class="literal">null</span>) <span class="comment">//if flavor passed in, make that first</span></span><br><span class="line">        &#123;</span><br><span class="line">            iceCreamMaker.<span class="type">Make</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"Cacao ice-cream"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VanillaIceCream</span> <span class="title">implements</span> <span class="title">IMakeIceCream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">IMakeIceCream</span> iceCreamMaker;</span><br><span class="line"></span><br><span class="line">    public <span class="type">VanillaIceCream</span>(<span class="type">IMakeIceCream</span> iceCreamMaker)  <span class="comment">//可选参数，如果不需要另一个口味传null</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.iceCreamMaker = iceCreamMaker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void <span class="type">Make</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (iceCreamMaker != <span class="literal">null</span>) <span class="comment">//if flavor passed in, make that first</span></span><br><span class="line">        &#123;</span><br><span class="line">            iceCreamMaker.<span class="type">Make</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"Vanilla ice-cream"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在将原始的类分成了三个对象：</p><ul><li><code>IMakeIceCream</code> 接口定义了制作冰淇淋的通用抽象</li><li><code>CacaoIceCream</code> 实现了 <code>IMakeIceCream</code> </li><li><code>VanillaIceCream</code> 实现了 <code>IMakeIceCream</code> </li></ul><p>通过使用接口，我们将类和实现解耦。接口是封闭不可修改的，因此一旦我们定义了对象，就无法更改。但是我们可以为新的功能定义新接口并继承它们。这使得代码可扩展。</p><p>为什么要向每个构造函数添加 <code>IMakeIceCream</code> 参数？新代码是否具有旧方法或旧方法的所有功能？</p><hr><p>答案是肯定的。可可香草组合仍在这里，但我们不需要 if 子句或专门针对它的类。我们可以利用构造函数参数。类似这样：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cacaoVanillaIceCream = <span class="keyword">new</span> <span class="type">CacaoIceCream</span>(<span class="keyword">new</span> <span class="type">VanillaIceCream</span>());</span><br><span class="line">cacaoVanillaIceCream.<span class="type">Make</span>();</span><br></pre></td></tr></table></figure><p>组合的好处在于，我们可以根据需要合成任意数量的对象。需要 4 种口味？只需编写一个构造函数链即可。这称为装饰器模式。你可以在 <a href="https://refactoring.guru/design-patterns/decorator/csharp/example" target="_blank" rel="noopener">这里</a> 读更多关于它的内容。</p><p>请注意， <code>IMakeIceCream</code> 参数是可选的。这使我可以组合使用或单独使用该类。</p><p>像这样编写代码会实现一个可拔插式的体系结构。这是非常 nice 的，因为我们可以通过编写代码来添加新功能，而不更改现有功能。任务完成。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拥抱Restful--Jersey框架</title>
      <link href="2021/04/19/%E6%8B%A5%E6%8A%B1Restful-Jersey%E6%A1%86%E6%9E%B6/"/>
      <url>2021/04/19/%E6%8B%A5%E6%8A%B1Restful-Jersey%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>提到 RestFul ，很容易联想到 Spring 框架，如果你在此之前没有接触过 Spring 框架，建议先点击 <a href="https://spring.io/guides/gs/rest-service/" target="_blank" rel="noopener">传送门</a> 了解一下如何通过 Spring 快速构建一个 Restful Web 服务。</p><p>今天我们主要通过另一个轻量级的框架— <code>Jersey</code> 整合 Spring 来构建一个 Restful 服务。 Jersey 是一个用于构建 Restful Web 服务的一个开源框架。是 <a href="https://zh.wikipedia.org/wiki/JAX-RS" target="_blank" rel="noopener">JAX-RS</a> 规范的一种具体实现。</p><h3 id="Maven-依赖"><a href="#Maven-依赖" class="headerlink" title="Maven 依赖"></a>Maven 依赖</h3><p>首先引入 <code>Jersey</code> 相关的依赖：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish.jersey.containers<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jersey-container-servlet<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish.jersey.media<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jersey-media-json-jackson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><br>如果要整合 Spring 框架的话，我们还需要引入 <code>jersey-spring4</code> 依赖：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 整合spring --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish.jersey.ext<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jersey-spring4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0-M6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Web-配置"><a href="#Web-配置" class="headerlink" title="Web 配置"></a>Web 配置</h3><p>接下来，我们需要建立一个 Web 项目来进行 Servlet 配置，使用 Spring 的 WebApplicationInitializer 。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(javax.servlet.ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigWebApplicationContext context</span><br><span class="line">                = <span class="keyword">new</span> AnnotationConfigWebApplicationContext();</span><br><span class="line"></span><br><span class="line">        servletContext.addListener(<span class="keyword">new</span> ContextLoaderListener(context));</span><br><span class="line">        servletContext.setInitParameter(<span class="string">"contextConfigLocation"</span>, <span class="string">"com.example.server"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里添加 <code>@Order(Ordered.HIGHEST_PRECEDENCE)</code> 注解的作用是确保 WebApplicationInitializer 在 Jersey-Spring 默认初始化程序之前执行。</p><h3 id="使用-Jersey-JAX-RS-服务"><a href="#使用-Jersey-JAX-RS-服务" class="headerlink" title="使用 Jersey JAX-RS 服务"></a>使用 Jersey JAX-RS 服务</h3><h4 id="资源表示类"><a href="#资源表示类" class="headerlink" title="资源表示类"></a>资源表示类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@XmlRootElement</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当仅需要 XML 支持（除了JSON）时，才需要引入 @XmlRootElement 这一类的 JAXB 注解，</p></blockquote><h4 id="实现服务"><a href="#实现服务" class="headerlink" title="实现服务"></a>实现服务</h4><p>现在我们通过 JAX-RS 注解来构建一个 RESTful Web 服务:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Path</span>(<span class="string">"/employees"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeResource</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeRepository employeeRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="meta">@Path</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@Produces</span>(&#123; MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">getEmployee</span><span class="params">(@PathParam(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> employeeRepository.getEmployee(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST</span></span><br><span class="line">    <span class="meta">@Consumes</span>(&#123; MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">addEmployee</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Employee employee, @Context UriInfo uriInfo)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        employeeRepository.addEmployee(<span class="keyword">new</span> Employee(employee.getId(), </span><br><span class="line">          employee.getFirstName(), employee.getLastName(), </span><br><span class="line">          employee.getAge()));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> Response.status(Response.Status.CREATED.getStatusCode())</span><br><span class="line">          .header(</span><br><span class="line">            <span class="string">"Location"</span>, </span><br><span class="line">            String.format(<span class="string">"%s/%s"</span>,uriInfo.getAbsolutePath().toString(), </span><br><span class="line">            employee.getId())).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> <code>@Path</code> 注解表示服务请求路由，我们也可以将变量嵌入到请求路由中，如代码中的 <code>{id}</code> 。如果需要获取该变量值，可以通过 <code>@PathParam</code> 注解。</p><p> <code>@GET</code> ， <code>@PUT</code> ， <code>@POST</code> ,  <code>@DELETE</code> 和 <code>@HEAD</code> 标识请求 HTTP 的方式。</p><p> <code>@Produces</code> 表示响应的数据类型，在示例中，我们已将其配置为根据HTTP请求头为  (Acceptapplication/json 或 application/xml) 的值返回JSON或XML。</p><p> <code>@Consumes</code> 定义服务可用的 MIME 类型，具体的数据类型取决于请求头 Content-Type（application/json或application/xml）。</p><p> <code>@Context</code> 注解用于将信息注入类字段，bean属性或方法参数。在示例中，我们使用它来注入 <code>UriInfo</code> 。我们还可以使用它来注入 ServletConfig ， ServletContext ， HttpServletRequest 和 HttpServletResponse 。</p><h3 id="使用-ExceptionMapper"><a href="#使用-ExceptionMapper" class="headerlink" title="使用 ExceptionMapper"></a>使用 ExceptionMapper</h3><p> <code>ExceptionMapper</code> 可以帮助我们拦截异常并将适当的HTTP响应代码返回给客户端。在以下示例中，如果抛出 EmployeeNotFound 异常，则返回 HTTP 响应代码 404 ：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Provider</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotFoundExceptionHandler</span> </span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">ExceptionMapper</span>&lt;<span class="title">EmployeeNotFound</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">toResponse</span><span class="params">(EmployeeNotFound ex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Response.status(Response.Status.NOT_FOUND).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="管理资源类"><a href="#管理资源类" class="headerlink" title="管理资源类"></a>管理资源类</h3><p>最后，让我们根据应用程序路径连接所有服务实现类和异常映射：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApplicationPath</span>(<span class="string">"/resources"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestConfig</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;(</span><br><span class="line">          Arrays.asList(</span><br><span class="line">            EmployeeResource<span class="class">.<span class="keyword">class</span>, </span></span><br><span class="line"><span class="class">            <span class="title">NotFoundExceptionHandler</span>.<span class="title">class</span>, </span></span><br><span class="line"><span class="class">            <span class="title">AlreadyExistsExceptionHandler</span>.<span class="title">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="API-测试"><a href="#API-测试" class="headerlink" title="API 测试"></a>API 测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JerseyApiLiveTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICE_URL</span><br><span class="line">      = <span class="string">"http://localhost:8082/spring-jersey/resources/employees"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenGetAllEmployees_whenCorrectRequest_thenResponseCodeSuccess</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> ClientProtocolException, IOException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        HttpUriRequest request = <span class="keyword">new</span> HttpGet(SERVICE_URL);</span><br><span class="line"></span><br><span class="line">        HttpResponse httpResponse = HttpClientBuilder</span><br><span class="line">          .create()</span><br><span class="line">          .build()</span><br><span class="line">          .execute(request);</span><br><span class="line"></span><br><span class="line">        assertEquals(httpResponse</span><br><span class="line">          .getStatusLine()</span><br><span class="line">          .getStatusCode(), HttpStatus.SC_OK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了 <code>Jersey</code> 框架并开发了一个简单的 API 。我们引入 <code>Spring</code> 用于依赖关系注入功能。还看到了 ExceptionMapper 的使用。</p>]]></content>
      
      
      <categories>
          
          <category> Frameworks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> Jersey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题--经营摩天轮的最大利润</title>
      <link href="2021/04/14/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E7%BB%8F%E8%90%A5%E6%91%A9%E5%A4%A9%E8%BD%AE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/"/>
      <url>2021/04/14/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E7%BB%8F%E8%90%A5%E6%91%A9%E5%A4%A9%E8%BD%AE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>昨天说今天准备刷一下<code>贪心算法</code>，今天根据贪心算法的 tag 找了一个题目。题目本身没有特别难，整理完这题的解题思路之后，我会再找几题看看有没有共性思路可以整理分享一下。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>你正在经营一座摩天轮，该摩天轮共有<code>4 个座舱</code> ，每个座舱 <code>最多可以容纳 4 位游客</code> 。你可以 逆时针 轮转座舱，但每次轮转都需要支付一定的运行成本 <code>runningCost</code> 。摩天轮每次轮转都恰好转动 <code>1 / 4</code> 周。</p><p>给你一个长度为 n 的数组 <code>customers</code> ， <code>customers[i]</code> 是在第 <code>i</code> 次轮转（下标从 0 开始）之前到达的新游客的数量。这也意味着你必须在新游客到来前轮转 i 次。每位游客在登上离地面最近的座舱前都会支付登舱成本 <code>boardingCost</code> ，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。</p><p>你可以随时停下摩天轮，即便是 <code>在服务所有游客之前</code> 。如果你决定停止运营摩天轮，为了保证所有游客安全着陆，将<code>免费进行所有后续轮转</code> 。注意，如果有超过 4 位游客在等摩天轮，那么只有 4 位游客可以登上摩天轮，其余的需要等待 <code>下一次轮转</code> 。</p><p>返回最大化利润所需执行的 <code>最小轮转次数</code> 。 如果不存在利润为正的方案，则返回 <code>-1</code> 。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06dfd4f56d484929940737bc41fb87cc~tplv-k3u1fbpfcp-watermark.image" alt="wheeldiagram12.png"></p><p><strong>示例</strong> 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：customers &#x3D; [8,3], boardingCost &#x3D; 5, runningCost &#x3D; 6</span><br><span class="line">输出：3</span><br><span class="line">解释：座舱上标注的数字是该座舱的当前游客数。</span><br><span class="line">1. 8 位游客抵达，4 位登舱，4 位等待下一舱，摩天轮轮转。当前利润为 4 * $5 - 1 * $6 &#x3D; $14 。</span><br><span class="line">2. 3 位游客抵达，4 位在等待的游客登舱，其他 3 位等待，摩天轮轮转。当前利润为 8 * $5 - 2 * $6 &#x3D; $28 。</span><br><span class="line">3. 最后 3 位游客登舱，摩天轮轮转。当前利润为 11 * $5 - 3 * $6 &#x3D; $37 。</span><br><span class="line">轮转 3 次得到最大利润，最大利润为 $37 。</span><br></pre></td></tr></table></figure><br><strong>示例</strong> 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：customers &#x3D; [10,9,6], boardingCost &#x3D; 6, runningCost &#x3D; 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">1. 10 位游客抵达，4 位登舱，6 位等待下一舱，摩天轮轮转。当前利润为 4 * $6 - 1 * $4 &#x3D; $20 。</span><br><span class="line">2. 9 位游客抵达，4 位登舱，11 位等待（2 位是先前就在等待的，9 位新加入等待的），摩天轮轮转。当前利润为 8 * $6 - 2 * $4 &#x3D; $40 。</span><br><span class="line">3. 最后 6 位游客抵达，4 位登舱，13 位等待，摩天轮轮转。当前利润为 12 * $6 - 3 * $4 &#x3D; $60 。</span><br><span class="line">4. 4 位登舱，9 位等待，摩天轮轮转。当前利润为 * $6 - 4 * $4 &#x3D; $80 。</span><br><span class="line">5. 4 位登舱，5 位等待，摩天轮轮转。当前利润为 20 * $6 - 5 * $4 &#x3D; $100 。</span><br><span class="line">6. 4 位登舱，1 位等待，摩天轮轮转。当前利润为 24 * $6 - 6 * $4 &#x3D; $120 。</span><br><span class="line">7. 1 位登舱，摩天轮轮转。当前利润为 25 * $6 - 7 * $4 &#x3D; $122 。</span><br><span class="line">轮转 7 次得到最大利润，最大利润为$122 。</span><br></pre></td></tr></table></figure></p><p><strong>示例</strong> 3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：customers &#x3D; [3,4,0,5,1], boardingCost &#x3D; 1, runningCost &#x3D; 92</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">1. 3 位游客抵达，3 位登舱，0 位等待，摩天轮轮转。当前利润为 3 * $1 - 1 * $92 &#x3D; -$89 。</span><br><span class="line">2. 4 位游客抵达，4 位登舱，0 位等待，摩天轮轮转。当前利润为 is 7 * $1 - 2 * $92 &#x3D; -$177 。</span><br><span class="line">3. 0 位游客抵达，0 位登舱，0 位等待，摩天轮轮转。当前利润为 7 * $1 - 3 * $92 &#x3D; -$269 。</span><br><span class="line">4. 5 位游客抵达，4 位登舱，1 位等待，摩天轮轮转。当前利润为 12 * $1 - 4 * $92 &#x3D; -$356 。</span><br><span class="line">5. 1 位游客抵达，2 位登舱，0 位等待，摩天轮轮转。当前利润为 13 * $1 - 5 * $92 &#x3D; -$447 。</span><br><span class="line">利润永不为正，所以返回 -1 。</span><br></pre></td></tr></table></figure><br><strong>示例</strong> 4：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：customers &#x3D; [10,10,6,4,7], boardingCost &#x3D; 3, runningCost &#x3D; 8</span><br><span class="line">输出：9</span><br><span class="line">解释：</span><br><span class="line">1. 10 位游客抵达，4 位登舱，6 位等待，摩天轮轮转。当前利润为 4 * $3 - 1 * $8 &#x3D; $4 。</span><br><span class="line">2. 10 位游客抵达，4 位登舱，12 位等待，摩天轮轮转。当前利润为 8 * $3 - 2 * $8 &#x3D; $8 。</span><br><span class="line">3. 6 位游客抵达，4 位登舱，14 位等待，摩天轮轮转。当前利润为 12 * $3 - 3 * $8 &#x3D; $12 。</span><br><span class="line">4. 4 位游客抵达，4 位登舱，14 位等待，摩天轮轮转。当前利润为 16 * $3 - 4 * $8 &#x3D; $16 。</span><br><span class="line">5. 7 位游客抵达，4 位登舱，17 位等待，摩天轮轮转。当前利润为 20 * $3 - 5 * $8 &#x3D; $20 。</span><br><span class="line">6. 4 位登舱，13 位等待，摩天轮轮转。当前利润为 24 * $3 - 6 * $8 &#x3D; $24 。</span><br><span class="line">7. 4 位登舱，9 位等待，摩天轮轮转。当前利润为 28 * $3 - 7 * $8 &#x3D; $28 。</span><br><span class="line">8. 4 位登舱，5 位等待，摩天轮轮转。当前利润为 32 * $3 - 8 * $8 &#x3D; $32 。</span><br><span class="line">9. 4 位登舱，1 位等待，摩天轮轮转。当前利润为 36 * $3 - 9 * $8 &#x3D; $36 。</span><br><span class="line">​​​​​​​10. 1 位登舱，0 位等待，摩天轮轮转。当前利润为 37 * $3 - 10 * $8 &#x3D; $31 。</span><br><span class="line">轮转 9 次得到最大利润，最大利润为 $36 。</span><br></pre></td></tr></table></figure></p><p><strong>提示</strong>：</p><ul><li>n == customers.length</li><li>1 &lt;= n &lt;= 105</li><li>0 &lt;= customers[i] &lt;= 50</li><li>1 &lt;= boardingCost, runningCost &lt;= 100</li></ul><blockquote><p>来源：力扣（LeetCode）&lt;/br&gt;<br>链接：<a href="https://leetcode-cn.com/problems/maximum-profit-of-operating-a-centennial-wheel" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-profit-of-operating-a-centennial-wheel</a>&lt;/br&gt;<br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这题我们的关注点其实只要关注最下面的仓位就可以，不管摩天轮如何轮转，最下面的仓位永远为空。因为转每次顾客完成一周的时候必定离开摩天轮。当我们决定停止服务时候，为了保证所有游客安全着陆，将<code>免费进行所有后续轮转</code> 。也就是后续费用都不在考虑范围之内。</p><p>理解了这些，这题是思路就逐渐变得清晰起来。我们只要保证每次最下面的摩天轮上的人数足够多，去除固定轮转成本，就能让我们的收益最大化。大致整理一下思路：</p><ul><li>当 <code>i</code> 批游客大于4人：<code>customer[i] - 4</code> 人排队等待，此次利润为：4 * boardingCost - runningCost</li><li>当 <code>i</code> 批游客小于4人：<code>customer[i]</code> 人全部乘仓，此次利润为：customer[i] * boardingCost - runningCost</li></ul><p>如果穷举情形，无非有这样几种情形</p><ol><li>customer[i] 小于等于4  全部登仓</li><li>customer[i] 大于4  登仓4人，将等待人数加入customer[i+1] ，这样下次循环不影响 1 中的情形</li><li>全部遍历之后，customer[customer.length-1] 大于 4 。减去 4 个已登机人数。</li><li>对于 customer[customer.length-1] 剩下人数，尽可能每次上的最多。</li></ol><h3 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minOperationsMaxProfit</span><span class="params">(<span class="keyword">int</span>[] customers, <span class="keyword">int</span> boardingCost, <span class="keyword">int</span> runningCost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minRotaes = <span class="number">0</span>, maxProfit = <span class="number">0</span>, currentProfit = <span class="number">0</span>, currentRotaes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; customers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (customers[i] &lt;= <span class="number">4</span>) &#123;</span><br><span class="line">                currentProfit += customers[i] * boardingCost - runningCost;</span><br><span class="line">                currentRotaes++;</span><br><span class="line">                <span class="keyword">if</span> (maxProfit &lt; currentProfit) &#123;</span><br><span class="line">                    minRotaes = currentRotaes;</span><br><span class="line">                    maxProfit = currentProfit;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currentProfit += <span class="number">4</span> * boardingCost - runningCost;</span><br><span class="line">                currentRotaes++;</span><br><span class="line">                <span class="keyword">if</span> (maxProfit &lt; currentProfit) &#123;</span><br><span class="line">                    minRotaes = currentRotaes;</span><br><span class="line">                    maxProfit = currentProfit;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; customers.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    customers[i + <span class="number">1</span>] += customers[i] - <span class="number">4</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        customers[customers.length - <span class="number">1</span>] -= <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">while</span> (customers[customers.length - <span class="number">1</span>] &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            currentProfit += <span class="number">4</span> * boardingCost - runningCost;</span><br><span class="line">            currentRotaes++;</span><br><span class="line">            customers[customers.length - <span class="number">1</span>] -= <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span> (maxProfit &lt; currentProfit) &#123;</span><br><span class="line">                minRotaes = currentRotaes;</span><br><span class="line">                maxProfit = currentProfit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (customers[customers.length - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            currentProfit += customers[customers.length - <span class="number">1</span>] * boardingCost - runningCost;</span><br><span class="line">            currentRotaes++;</span><br><span class="line">            <span class="keyword">if</span> (maxProfit &lt; currentProfit) &#123;</span><br><span class="line">                minRotaes = currentRotaes;</span><br><span class="line">                maxProfit = currentProfit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minRotaes &gt; <span class="number">0</span> ? minRotaes : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>我以为这一题会有一些巧妙的解法，甚至去研究了一下其他人的解法。发现普遍都是把题目翻译一下，没有花哨的操作。晚点时间我找几个典型的贪心算法整理一下。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题--验证回文串</title>
      <link href="2021/04/14/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>2021/04/14/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天题目是误打误撞遇到的。原本想刷一下五大常用算法之一的— <code>贪心算法</code> ，用标签搜了一下贪心算法，点进去之后发现并不是。但是遇到就是缘分，并且这题的解题思路很像快速排序，因此今天顺便复习一下快速排序，也同时可以复习一下五大常用算法的另一种— <code>分治算法</code> 。明天应该会整理一下贪心算法的解题思路。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p><strong>说明</strong>：本题中，我们将空字符串定义为有效的回文串。</p><p><strong>示例</strong> 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例</strong> 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-palindrome" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-palindrome</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于本题，难免会涉及前后两个元素比对。我们可以定义两个 <code>游标</code> 一个从字符串的起始位，一个从字符串的末位，依次遍历。遇到无效字符游标移动到下一个字符，当 <code>left</code> 和 <code>right</code> 相遇之后。说明在此之前所有的元素全部相同。如果在相遇之前已经遇到不匹配的字符，说明匹配失败。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02bc146c007044bfabd5a79176e7768f~tplv-k3u1fbpfcp-watermark.image" alt="未命名文件.png"></p><p>根据这样的思路可以写出一段伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BEGIN:</span><br><span class="line">    <span class="keyword">while</span>: left!= right then</span><br><span class="line">    <span class="keyword">do</span>:</span><br><span class="line">        <span class="keyword">if</span>(left字符无效) then</span><br><span class="line">                left++;</span><br><span class="line">                CONTINUE;</span><br><span class="line">        END <span class="keyword">if</span>;</span><br><span class="line">        <span class="keyword">if</span>(right字符无效) then</span><br><span class="line">                right++;</span><br><span class="line">                CONTINUE;</span><br><span class="line">        END <span class="keyword">if</span>;</span><br><span class="line">        <span class="keyword">if</span>(left字符！=right字符)</span><br><span class="line">                BREAK;</span><br><span class="line">    END <span class="keyword">while</span>;</span><br><span class="line">    <span class="keyword">return</span> left== right;</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>但是这样其实还是有一点问题的， <code>left</code> 真的能每次都遇到 <code>right</code> 吗？如果输入的字符串中有效字符个数是奇数，可以遇到。但是如果有效字符个数是偶数，如 <code>aa</code> , left 和 right 匹配成功。这时， left 和 right 分别移动一个位置，他们便完美的擦肩而过。他们擦肩而过，也能代表在擦肩之前所有的字符串都是匹配上的，因此真实的临界条件应该是 <code>left &lt; right</code> 。整理一下最终的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String inStr = s.toLowerCase();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = inStr.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Character.isLetterOrDigit(inStr.charAt(left))) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!Character.isLetterOrDigit(inStr.charAt(right))) &#123;</span><br><span class="line">                --right;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inStr.charAt(left) != inStr.charAt(right))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left &gt;= right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种游标操作，很容易联想到快速排序。排序算法的思想是在待排序的数列中，首先找一个数字作为基准数。接下来我们需要把这个待排序的数列中小于基准数的元素移动到待排序的数列的左边，把大于基准数的元素移动到待排序的数列的右边。这时候左边的元素肯定全部小于<code>基准数</code>小于右边元素。接着再分别对左右两个分区重复这个操作，直至完全有序。</p><p>这里以 47、29、71、99、78、19、24、47 为例。首先选取第一个元素作为基准值。定义两个 <code>游标</code> i 和 j ，将 <code>i</code> 游标依次向前移动，找到比基准数小的就交换。接着移动游标 <code>j</code> 从左边开始往右边找，找到第 1 个比基准数大的值，让它与基准值交换；然后继续寻找，直到 i 与 j 相遇时结束，最后基准值所在的位置即 k 的位置，也就是说 k 左边的值均比 k 上的值小，而 k 右边的值都比 k 上的值大。</p><p>所以对于上面的数列 47、29、71、99、78、19、24、47，进行第 1 趟第 1 个交换的排序情况如下，第 1 次的操作情况图所示。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ff6c592995549a4924416f25bc71e64~tplv-k3u1fbpfcp-watermark.image" alt="1-jpg.jpg"></p><p>交换之后，j 移动到了下标为 6 的位置，对 i 继续扫描，如图所示。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29abc35db495427faed4aefa8c012187~tplv-k3u1fbpfcp-watermark.image" alt="2-1Q00220013M46.jpg"></p><p>此时交换后的数列变为 24、29、47、99、78、19、71、47。接下来我们继续对 i、j 进行操作，如图 3 所示，继续进行 i— 及 j++ 的比较操作。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a6e1191f2334471a8664b3492f3ef1b~tplv-k3u1fbpfcp-watermark.image" alt="3-1Q00220025I54.jpg"></p><p>进行了这两次 i、j 的移动、比较、交换之后，我们最终得到的数列是 24、29、19、47、78、99、71、47。接下来我们继续进行 i— 的操作，发现在 i 为 4 时比 47 大不用交换，在 i 为 3 时与 j 相遇，这时就不需要继续移动、比较了，已经找到 k 了，并且 k 的值为 3。我们可以确认一下当前的数列是不是 k 左边的值都比 47 小，而 k 右边的值都比 47 大（由于要保持相对位置不变，所以 47 同样在基准值 47 的右边）。</p><p>47 这个值已经落到了它该在的位置，第 1 趟排序完成了。接下来就是以 k 为基准，分为两部分，然后在左右两部分分别执行上述排序操作，最后数据会分为 4 部分；接着对每部分进行操作，直到每部分都只有一个值为止。</p><blockquote><p>样例来源：《数据结构与算法教程》&lt;/br&gt;<br>链接：<a href="http://data.biancheng.net/view/117.html" target="_blank" rel="noopener">http://data.biancheng.net/view/117.html</a></p></blockquote><h3 id="快排代码"><a href="#快排代码" class="headerlink" title="快排代码"></a>快排代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        quickSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.println(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> begin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] src, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = src[begin];</span><br><span class="line">            <span class="keyword">int</span> i = begin;</span><br><span class="line">            <span class="keyword">int</span> j = end;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; src[j] &gt; key) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                    src[i] = src[j];</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; src[i] &lt; key) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                    src[j] = src[i];</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            src[i] = key;</span><br><span class="line">            quickSort(src, begin, i - <span class="number">1</span>);</span><br><span class="line">            quickSort(src, i + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>排序算法的核心思想本质其实是分治思想，把问题分为一个个的小部分来分别解决，再把结果组合起来。这题通过一个小的游标操作强行把快排拉了过来。虽然题目简单，但是能复习一下 <code>分治算法</code> ，也巩固了一下快速排序，也算今天有所收获吧。</p><p>本文正在参与「掘金 2021 4 月刷题打卡」, 点击查看 <a href="https://juejin.cn/post/6946462614306160670/" target="_blank" rel="noopener">活动详情</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题--按既定顺序创建目标数组</title>
      <link href="2021/04/14/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%8C%89%E6%97%A2%E5%AE%9A%E9%A1%BA%E5%BA%8F%E5%88%9B%E5%BB%BA%E7%9B%AE%E6%A0%87%E6%95%B0%E7%BB%84/"/>
      <url>2021/04/14/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%8C%89%E6%97%A2%E5%AE%9A%E9%A1%BA%E5%BA%8F%E5%88%9B%E5%BB%BA%E7%9B%AE%E6%A0%87%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天刷到的这个题目，从难度而言非常简单，甚至可以瞬秒，但是延伸一下很容易想到基础排序里面非常常见的一种—<code>插入排序</code> 。所以借着今天的题目，正好额外复习一下插入排序。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个整数数组 <code>nums</code> 和 <code>index</code>。你需要按照以下规则创建目标数组：</p><ul><li>目标数组 <code>target</code> 最初为空。</li><li>按从左到右的顺序依次读取 <code>nums[i]</code> 和 <code>index[i]</code>，在 <code>target</code> 数组中的下标 <code>index[i]</code> 处插入值 <code>nums[i]</code> 。</li><li>重复上一步，直到在 <code>nums</code> 和 <code>index</code> 中都没有要读取的元素。</li></ul><p>请你返回目标数组。</p><p>题目保证数字插入位置总是存在。</p><p><strong>示例</strong> 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,2,3,4], index &#x3D; [0,1,2,2,1]</span><br><span class="line">输出：[0,4,1,3,2]</span><br><span class="line">解释：</span><br><span class="line">nums       index     target</span><br><span class="line">0            0        [0]</span><br><span class="line">1            1        [0,1]</span><br><span class="line">2            2        [0,1,2]</span><br><span class="line">3            2        [0,1,3,2]</span><br><span class="line">4            1        [0,4,1,3,2]</span><br></pre></td></tr></table></figure><p><strong>示例</strong> 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4,0], index &#x3D; [0,1,2,3,0]</span><br><span class="line">输出：[0,1,2,3,4]</span><br><span class="line">解释：</span><br><span class="line">nums       index     target</span><br><span class="line">1            0        [1]</span><br><span class="line">2            1        [1,2]</span><br><span class="line">3            2        [1,2,3]</span><br><span class="line">4            3        [1,2,3,4]</span><br><span class="line">0            0        [0,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例</strong> 3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1], index &#x3D; [0]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure></p><p><strong>提示</strong>：</p><ul><li>1 &lt;= nums.length, index.length &lt;= 100</li><li>nums.length == index.length</li><li>0 &lt;= nums[i] &lt;= 100</li><li>0 &lt;= index[i] &lt;= i</li></ul><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/create-target-array-in-the-given-order" target="_blank" rel="noopener">https://leetcode-cn.com/problems/create-target-array-in-the-given-order</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题目主要还是把题目意思理解清楚。根据示例，当新数组对应 <code>index[i]</code> 下标已经存在元素时，新的 <code>num[i]</code> 会插入到这个坐标之中。原本填充在 <code>index[i]</code> 元素会依次向后移动一位。理解了这个之后。就会发现，相当于对每个元素，他都是执行了一个插入操作。所以代码也就能很容易写出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] createTargetArray(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] index) &#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            generateNewArray(nums[i], index[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateNewArray</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt; index; i--) &#123;</span><br><span class="line">            array[i] = array[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        array[index] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LeetCode 官网题解引了个 List ，但是殊途同归，也是对每个元素做插入操作。代码也贴出来看一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] createTargetArray(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] index) &#123;</span><br><span class="line">        List&lt;Integer&gt; targetList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            targetList.add(index[i],nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] target = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            target[i] = targetList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>题目到这里结束了。但是这个插入过程，很像我们做插排的时候。我们做插排的时候，默认第一个元素是最小的元素，从 <code>i=1</code> 开始遍历，如 (a) 从 2 开始遍历，然后寻找插入位置。如果在左边找到了插入位置，那么左边插入之后就是有序的，如果左边没有插入位置，说明左边所有元素包括当前元素，都是有序的，如图 (d) 。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bea5f449848b45b1a1d45be20f571977~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="插入排序代码"><a href="#插入排序代码" class="headerlink" title="插入排序代码"></a>插入排序代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="comment">// 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 记录要插入的数据</span></span><br><span class="line">            <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">            <span class="comment">// 从已经排序的序列最右边的开始比较，找到比其小的数</span></span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; tmp &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>]; </span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 存在比其小的数，插入</span></span><br><span class="line">            <span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">                arr[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>今天题目不难，但是多复习了一个基础排序，感觉也是有所收获。在每次刷题的时候，多去思考之前是否遇到相似场景。不至于遗忘之前的知识。顺便推荐一下我最近两天的文章，也是很有共性的两篇动态规划：</p><ul><li><a href="https://juejin.cn/post/6949201709608468510" target="_blank" rel="noopener">[LeetCode1262题 - 可被三整除的最大和] | 刷题打卡</a></li><li><a href="https://juejin.cn/post/6949809128680194079" target="_blank" rel="noopener">[LeetCode70题 - 爬楼梯] | 刷题打卡</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题--爬楼梯</title>
      <link href="2021/04/14/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
      <url>2021/04/14/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>昨天尝试了第一个动态规划题目—<a href="https://juejin.cn/post/6949201709608468510" target="_blank" rel="noopener">可被三整除的最大和</a>，用了全量递归和动态规划两种方案。今天的打卡题目也依旧是一个动态规划题。可能很多人在做动态规划的时候，爬楼梯都是他们做的第一个题。但是这个解法也依然有趣。今天依然从递归和dp两个角度来解题。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意</strong>：给定 n 是一个正整数。</p><p><strong>示例</strong> 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure><p><strong>示例</strong> 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/climbing-stairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/climbing-stairs</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>如果看过昨天的<a href="https://juejin.cn/post/6949201709608468510" target="_blank" rel="noopener">可被三整除的最大和</a>，应该很容易就能发现，如果那个题是进阶版本的话，这个顶多算一个初级版。<br>现在依然采用同样的思路，假设我到了第 <code>n</code> 个台阶，那么我有可能是从 <code>n-1</code> 台阶上来，也有可能是从 <code>n-2</code> 台阶上来。</p><p>如果把 <code>n</code> 阶的方案总数记为 <code>f(n)</code> ,那 <code>n-1</code> 和 <code>n-2</code> 的总数就分别为 <code>f(n-1)</code> 和 <code>f(n-2)</code> 。根据上面的分析，不难看出 <code>f(n) = f(n-1) + f(n-2)</code> 。这里要保证定义域有意义，所以最小的 n-2 &gt;=1。<br>能得到 <code>n∈[3,无穷) ，n=N*</code> 。我们这时候穷举一下小于3的时候， n=1 时，从 0 到 1 只有一种场景， n=2 时，从 0 到 2 有两种场景，即一次直接两步或者一次一步。</p><p>现在看一下递归思路的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>代码很简洁，也很易懂。看起来解法异常漂亮，但是这样暴力递归的话，对于 <code>n</code> 他每次都有两个儿子 <code>n-1</code> 和 <code>n-2</code> ,假设一直递归到有一个结点是 5 ,那么这个节点他还要递归 8 次 (5下面是8个节点)，因为 2 和 1 是确定的数字，所以对于 <code>n</code> 节点，总共的递归次数应该是 2<sup>n-2</sup> 次。因此从时间复杂度上来讲，效率是很低的。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc15fc8fdb9c4010bffd12cc70005237~tplv-k3u1fbpfcp-watermark.image" alt="未命名文件.png"></p><p>下面我们来优化这段代码，在已经得知 <code>f(n) = f(n-1) + f(n-2)</code> ，且<code>f(1) = 1, f(2) = 2</code>的条件下，我不难得到 f(3) = f(1) + f(2) 。如果我们把 f(1) 存入一个临时变量 temp1 ，f(2) 存入一个临时变量 temp2 ，f(3) = temp1 + temp2 ，此时再对结果做处理让 f(2) 占据 temp1 ， f(3) 占据 temp2。那一直到最后f(n) = temp1 + temp2。</p><h3 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h3><p>在上一个暴力递归代码稍稍改动之后，最终代码这样优化之后时间复杂度只有O(n)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> temp1 = <span class="number">1</span>, temp2 = <span class="number">2</span>, f_n = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            temp1 = temp2;</span><br><span class="line">            temp2 = f_n;</span><br><span class="line">            f_n = temp1 + temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f_n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我也是刚开始接触动态规划这一类算法题，但是动态算法给我的感觉都是如果不考虑效率的情况下，暴力递归都是可以实现的。至于如何优化递归，我最近做的几题都是找准 n 与 n-1 之间的状态，再反过来从 1-&gt;n ，利用数组或者临时变量或者其他数据结构存储信息，从而降低时间复杂度。继续加油！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题--可以被三整除的最大的数</title>
      <link href="2021/04/09/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
      <url>2021/04/09/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天终于开始上手面试中最为高频的—<code>动态规划</code>了。可能是之前没有接触过，就听别人说动态规划很难，所以我一直不愿去面对这类题目。今天鼓了鼓勇气，上手了第一个动态规划题。当我做完第一个之后，我发现其实动态规划其实没有想象的那么可怕。也推荐那些不敢尝试的coder多去尝试一下，你不尝试一下你就永远不知道其实你是可以的。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。</p><p><strong>示例</strong> 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,6,5,1,8]</span><br><span class="line">输出：18</span><br><span class="line">解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。</span><br></pre></td></tr></table></figure><p><strong>示例</strong> 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4]</span><br><span class="line">输出：0</span><br><span class="line">解释：4 不能被 3 整除，所以无法选出数字，返回 0。</span><br></pre></td></tr></table></figure><p><strong>示例</strong> 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4,4]</span><br><span class="line">输出：12</span><br><span class="line">解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。</span><br></pre></td></tr></table></figure><p><strong>提示</strong>：</p><p>1 &lt;= nums.length &lt;= 4 * 10^4<br>1 &lt;= nums[i] &lt;= 10^4<br>通过次数9,965提交次数19,256</p><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/greatest-sum-divisible-by-three" target="_blank" rel="noopener">https://leetcode-cn.com/problems/greatest-sum-divisible-by-three</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于数组 <code>nums</code> ，假设先从中取 <code>n</code> 个元素中任取了一个元素，那么就有 N 种选择，对于剩下的元素，又有 N-1 种选择。以此类推，如果暴力穷举，那么一共有 <code>n!</code> 种场景。最后满足场景的情况，就是sum%3==0，比较所有sum中最大的那个值就是我们要的答案，或者 <code>nums</code> 一直遍历到最后，即新生成的数组长度为0都没有满足条件的就直接return掉。这样暴力递归的解法大致如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumDivThree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        findmaxSumDivThree(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findmaxSumDivThree</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            result = Math.max(result, sum);</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> newSum = sum + nums[i];</span><br><span class="line">            findmaxSumDivThree( removeCurrent(nums, i), newSum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去掉i坐标形成新数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] removeCurrent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] newNums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != i)</span><br><span class="line">                newNums[m++] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但是这种暴力递归会存在许多重复场景，对于数组 [1,2,3] 而言，第一次选取 1，第二次选取 2，第三次选取 3，和第一次选取 2，第二次选取 1，第三次选取 3。只是换了个顺序。相当于无意义工作重复递归了 <code>(n-1)!</code>次。无疑效率是大打折扣的。并且这个解法的solution时间超出了限制，说白了还是效率不过关，所以要调整。<br>我们新建一个二维数组，长 n+1 宽 3 来维护当前的状态。即</p><ul><li>dp[i][0]表示nums[0…i]模三余零的最大和</li><li>dp[i][1]表示nums[0…i]模三余一的最大和</li><li>dp[i][2]表示nums[0…i]模三余二的最大和</li></ul><p>假设当前总和对三取模是0,即当前和为 dp[i][0] ，那么在他之前有三个状态</p><ul><li>dp[i-1][0] + nums[i]   nums[i]%3==0</li><li>dp[i-1][1] + nums[i]   nums[i]%3==1</li><li>dp[i-1][2] + nums[i]   nums[i]%3==2<br>此时我需要的是<code>dp[i][0]</code>的最大值，所以还需要上面值还需要与 dp[i-1] 做比较（如果 dp[i-1][1] + nums[i] 都比不上 dp[i-1][0] ,那这个结果自然不能占有我期待的 dp[i][0] 位置）。</li></ul><p>相同的对于 dp[i][1] 也就能写出:</p><ul><li>dp[i-1][0] + nums[i]   nums[i]%3==1</li><li>dp[i-1][1] + nums[i]   nums[i]%3==0</li><li>dp[i-1][2] + nums[i]   nums[i]%3==2<br>对于 dp[i][2] 同样的道理：</li><li>dp[i-1][0] + nums[i]   nums[i]%3==2</li><li>dp[i-1][1] + nums[i]   nums[i]%3==1</li><li>dp[i-1][2] + nums[i]   nums[i]%3==0<br>到了这里，就可以发现当 <code>nums[i]%3==0</code> 取模是0的时候。就总共有三种场景，相当于一个把思路再反过来理解：</li><li>dp[i][0] = max(dp[i - 1][0], dp[i - 1][0] + nums[i - 1])</li><li>dp[i][1] = max(dp[i - 1][1], dp[i - 1][1] + nums[i - 1])</li><li>dp[i][2] = max(dp[i - 1][2], dp[i - 1][2] + nums[i - 1])<br>剩下两种场景也是一样的道理，最后dp[n][0]就是最 3 取模为 0 的最大和，直接看代码里的效果吧。</li></ul><h3 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumDivThree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [nums.length+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">0</span>][<span class="number">1</span>] = Integer.MIN_VALUE; dp[<span class="number">0</span>][<span class="number">2</span>] = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i - <span class="number">1</span>] % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i - <span class="number">1</span>] % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i - <span class="number">1</span>] % <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>做完之后，感觉自己还是有很多收获的，希望以后遇到动态规划的时候都能冷静分析。今日打卡成功，欢迎大家一起和我参与 <a href="https://juejin.cn/post/6946462614306160670/" target="_blank" rel="noopener">4月刷题打卡挑战</a>。一起提升自己。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题--整理字符串</title>
      <link href="2021/04/08/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%95%B4%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2021/04/08/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%95%B4%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近几天没逛掘金，也没有任何知识上的输出。今天刚上就看到掘金又发起了每日刷题打卡的活动。正好这几天手很颓。先做一个简单题来寻找一下状态。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个由大小写英文字母组成的字符串 s 。</p><p>一个整理好的字符串中，两个相邻字符 s[i] 和 s[i+1]，其中 0&lt;= i &lt;= s.length-2 ，要满足如下条件:</p><p>若 s[i] 是小写字符，则 s[i+1] 不可以是相同的大写字符。<br>若 s[i] 是大写字符，则 s[i+1] 不可以是相同的小写字符。<br>请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 两个相邻 字符并删除，直到字符串整理好为止。</p><p>请返回整理好的 字符串 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。</p><p>注意：空字符串也属于整理好的字符串，尽管其中没有任何字符。</p><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/make-the-string-great" target="_blank" rel="noopener">https://leetcode-cn.com/problems/make-the-string-great</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p><strong>示例 1：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leEeetcode&quot;</span><br><span class="line">输出：&quot;leetcode&quot;</span><br><span class="line">解释：无论你第一次选的是 i &#x3D; 1 还是 i &#x3D; 2，都会使 &quot;leEeetcode&quot; 缩减为 &quot;leetcode&quot; 。</span><br></pre></td></tr></table></figure></p><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abBAcC&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：存在多种不同情况，但所有的情况都会导致相同的结果。例如：</span><br><span class="line">&quot;abBAcC&quot; --&gt; &quot;aAcC&quot; --&gt; &quot;cC&quot; --&gt; &quot;&quot;</span><br><span class="line">&quot;abBAcC&quot; --&gt; &quot;abBA&quot; --&gt; &quot;aA&quot; --&gt; &quot;&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;s&quot;</span><br><span class="line">输出：&quot;s&quot;</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li>1 &lt;= s.length &lt;= 100</li><li>s 只包含小写和大写英文字母</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>看到这个题目，最直接想到的暴力解法就是依次遍历，如果出现坐标 <code>i</code> 满足上述述场景就跳过当前元素和下一个元素。否则<code>拼接</code>当前字符。如果遍历结束，拼接后的字符串长度仍然等于当前长度。说明没有任何元素满足上述场景。直接返回该字符串。否则仍然执行该逻辑。</p><p>很明显的一个递归逻辑。直接看一下暴力解的代码，遍历的之后因为后面要判断下一个元素，防止下标越界可以先判断一下当前下标是不是最后一个下标，如果是最后一个下标就直接拼接当前元素。因为后面没有元素，显然也就不满足这种场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">makeGood</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==s.length()-<span class="number">1</span>)&#123;</span><br><span class="line">                stringBuilder.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Character.isUpperCase(s.charAt(i)) &amp;&amp; !Character.isUpperCase(s.charAt(i + <span class="number">1</span>)) &amp;&amp; Character.toLowerCase(s.charAt(i)) == s.charAt(i + <span class="number">1</span>)) &#123;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!Character.isUpperCase(s.charAt(i)) &amp;&amp; Character.isUpperCase(s.charAt(i + <span class="number">1</span>)) &amp;&amp; Character.toUpperCase(s.charAt(i)) == s.charAt(i + <span class="number">1</span>)) &#123;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stringBuilder.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归处理</span></span><br><span class="line">        <span class="keyword">return</span> s.length() == stringBuilder.length() ? s : makeGood(stringBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归的内存消耗和时间复杂度无疑非常令人痛苦，那就接着考虑一下这题有没有更优雅一点的实现方案。在依次遍历输入字符串 <code>s</code> 的时候，如果不满足要求场景，选择拼接字符串。<br>如图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac84eff2566f44028aecfb3f2605c943~tplv-k3u1fbpfcp-watermark.image" alt="未命名文件 (2).png"><br>这是新串的 <code>b</code> 与老串的 <code>B</code> 满足场景，弹出新串最后一个元素（栈顶元素），老串顺移下标。此时新串的栈顶 <code>a</code> 与老串的 <code>A</code> 仍满足场景，弹出 <code>a</code> 元素,遍历老串的下标再次+1。当新串栈顶与老串当前字符不满足场景时。新串入栈老串的当前字符。这种做法时间复杂度只有 O(n) 。而且省去了递归造成的栈内存损耗。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c263bbf3eab4df0b87dd48c96019e46~tplv-k3u1fbpfcp-watermark.image" alt="未命名文件 (3).png"></p><h3 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">makeGood</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stringBuilder.length() &gt; <span class="number">0</span> &amp;&amp; Character.toLowerCase(stringBuilder.charAt(stringBuilder.length()-<span class="number">1</span>)) == Character.toLowerCase(s.charAt(i)) &amp;&amp; stringBuilder.charAt(stringBuilder.length()-<span class="number">1</span>) != s.charAt(i)) &#123;</span><br><span class="line">                stringBuilder.deleteCharAt(stringBuilder.length()-<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stringBuilder.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>今天打卡第一天，先做一题激励一下自己，先给自己定个小目标，完成4月份每日打卡。</p><p>本文正在参与「掘金 2021 4 月刷题打卡」, 点击查看 <a href="https://juejin.cn/post/6946462614306160670/" target="_blank" rel="noopener">活动详情</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用JAVA实现一个IMDB数据解析器</title>
      <link href="2021/03/31/%E7%94%A8JAVA%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAIMDB%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
      <url>2021/03/31/%E7%94%A8JAVA%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAIMDB%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>在IMDB数据库中，至少有2000万条数据可以查询。在使用这些数据之前还有许多前置工作需要完成。</p><h3 id="数据库文件"><a href="#数据库文件" class="headerlink" title="数据库文件"></a>数据库文件</h3><p>我们只取120行的样例数据来测试我们的解析器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">Andre, KentThe Mask: The Origin (1995) (VG)  (voice)</span><br><span class="line"></span><br><span class="line">Andre, KevinCome Fly with Us (1974)  [Tony]  &lt;4&gt;</span><br><span class="line">Deep Throat Part II (1974)  (as Carter Courtney Jr.)  [Russian Agent]  &lt;8&gt;</span><br><span class="line">Fringe Benefits (1974)  [Dr. Charles Cherrypopper]  &lt;1&gt;</span><br><span class="line">Invasion of the Love Drones (1977)  [Pseudo Drone]  &lt;26&gt;</span><br><span class="line">Is There Sex After Death? (1971)  (as Carter Courtney Jr.)  [Sex Bowl Contestant]  &lt;82&gt;</span><br><span class="line">Lady on the Couch (1974)  [Dr. Miller]</span><br><span class="line">Naked Came the Stranger (1975)  [Party Guy with Candle]  &lt;6&gt;</span><br><span class="line">Sex Fantasies (1975)</span><br><span class="line">Stigma (1972)  (as Carter Courtney)  [Homosexual]  &lt;10&gt;</span><br><span class="line">Teenage Hitchhikers (1975)  (as Carter Courtney Jr.)  [Farquart (Bruce)]  &lt;8&gt;</span><br><span class="line">The $50,000 Climax Show (1975)  (as Kevin Andre Darby)</span><br><span class="line">The Big Con (1975)  (as Carter Courtney)  [Sam Browne]  &lt;7&gt;</span><br><span class="line">The Defiance of Good (1975)  [Dr. Hirsch]  &lt;8&gt;</span><br><span class="line">The Love Bus (1974)  (as Kevin André)  [Ralph Kramden]  &lt;7&gt;</span><br><span class="line">The Mount of Venus (1975)  (as Kevin André)  [Bacchus]  &lt;5&gt;</span><br><span class="line">The New York City Woman (1977)  (archive footage) (uncredited)  [Dr. Chartop]</span><br><span class="line">The Passions of Carol (1975)  (as Kevin André)  [The Spirits]  &lt;5&gt;</span><br><span class="line">The Private Afternoons of Pamela Mann (1974)  [Frank&#39;s First Client]  &lt;6&gt;</span><br><span class="line">The Switch or How to Alter Your Ego (1974)  [Seymour]  &lt;17&gt;</span><br><span class="line">Whatever Happened to Miss September? (1973)  (as Knah-Knah)  [Bentley]</span><br><span class="line"></span><br><span class="line">Andre, KurtMy Politics, My Country (2012)</span><br><span class="line">World Bender (2014)  [Network Executive]  &lt;8&gt;</span><br><span class="line"></span><br><span class="line">Andre, L.J.&quot;Disneyland&quot; (1954) &#123;Willie and the Yank: The Deserter (#13.15)&#125;  [Uncle Ferd]  &lt;10&gt;</span><br><span class="line">&quot;Disneyland&quot; (1954) &#123;Willie and the Yank: The Mosby Raiders (#13.16)&#125;  [Uncle Ferd]  &lt;10&gt;</span><br><span class="line"></span><br><span class="line">Andre, LeClercStreetSmart Guide (2014) (V)  [Himself - Guest]</span><br><span class="line">&quot;Laughs&quot; (2014) &#123;(#1.22)&#125;</span><br><span class="line">&quot;Laughs&quot; (2014) &#123;(#1.5)&#125;  [Himself]</span><br><span class="line"></span><br><span class="line">Andre, Lorin-PierreCirque du Soleil: Worlds Away (2012)  [Viva Elvis Cast Member]  &lt;198&gt;</span><br><span class="line">The Neighborhood Ball: An Inauguration Celebration (2009) (TV)  [Antigravity Performer]</span><br><span class="line"></span><br><span class="line">Andre, LukkaArmando Rene: Start Running (2015) (V)</span><br><span class="line">Making of Salir Corriendo (2015)  (archive footage)</span><br><span class="line"></span><br><span class="line">Andre, MandiMemoirs of a Lifeguard (2010)</span><br><span class="line"></span><br><span class="line">Andre, MarcusThe Grad Film (2015)  [Rob]</span><br><span class="line"></span><br><span class="line">Andre, Mario (I)Love Your Mama (1990)  [Bartender]</span><br><span class="line"></span><br><span class="line">Andre, Mario (II)Market Value (2016)  [Triage Patient]</span><br><span class="line">The Breakout Dream (2015)  [Pastor Mark]</span><br><span class="line">The Penny (2010)  [Darrell Watts]  &lt;6&gt;</span><br><span class="line"></span><br><span class="line">Andre, Mario (III)Blactose Intolerance (2015)  [Pa Pa]</span><br><span class="line">Life Outside the Rhyme (2016)  [The Muffin Man]</span><br><span class="line">Preacher Man (2015)  [Elder Jones]  &lt;4&gt;</span><br><span class="line">School for Gods (????)  [St. Louis Cartel]</span><br><span class="line">Under Pressure (2016)  [Uncle Ray]</span><br><span class="line">&quot;The Natural&quot; (2016)  [The Manager]</span><br><span class="line"></span><br><span class="line">Andre, MartinVasilissa maimou (2000)</span><br><span class="line"></span><br><span class="line">Andre, Mat (I)Lights Camera Blood! (2015)  [Hank the Hobo]</span><br><span class="line">&quot;Todd and the Book of Pure Evil&quot; (2010) &#123;B.Y.O.B.O.P.E. (#2.11)&#125;  [Dancerman]  &lt;18&gt;</span><br><span class="line"></span><br><span class="line">Andre, Mathias (II)Guilty Pleasures (2016) (TV)  [Groomer 3]  &lt;26&gt;</span><br><span class="line"></span><br><span class="line">Andre, MatthewSanta Rosa (2004) (V)</span><br><span class="line"></span><br><span class="line">Andre, Michael (II)&quot;Here 2 Help&quot; (2011) &#123;(#1.2)&#125;  [Himself]  &lt;3&gt;</span><br><span class="line">&quot;Here 2 Help&quot; (2011) &#123;(#1.3)&#125;  [Himself]  &lt;2&gt;</span><br><span class="line">&quot;Here 2 Help&quot; (2011) &#123;(#1.4)&#125;  [Himself]  &lt;2&gt;</span><br><span class="line">&quot;Here 2 Help&quot; (2011) &#123;(#1.5)&#125;  [Himself]  &lt;2&gt;</span><br><span class="line">&quot;Here 2 Help&quot; (2011) &#123;(#1.6)&#125;  [Himself]  &lt;2&gt;</span><br><span class="line">&quot;Peter Andre: My Life&quot; (2011) &#123;(#1.2)&#125;  [Himself]</span><br><span class="line">&quot;Peter Andre: My Life&quot; (2011) &#123;(#1.3)&#125;  [Himself]</span><br><span class="line">&quot;Peter Andre: My Life&quot; (2011) &#123;(#1.4)&#125;  [Himself]</span><br><span class="line">&quot;Peter Andre: My Life&quot; (2011) &#123;(#1.5)&#125;  [Himself]</span><br><span class="line">&quot;Peter Andre: My Life&quot; (2011) &#123;(#3.4)&#125;  [Himself]</span><br><span class="line">&quot;Peter Andre: My Life&quot; (2011) &#123;(#3.5)&#125;  [Himself]</span><br><span class="line">&quot;Peter Andre: My Life&quot; (2011) &#123;He&#39;s Found His Happy Ever After (#5.4)&#125;  [Himself]</span><br><span class="line">&quot;Peter Andre: My Life&quot; (2011) &#123;I Can&#39;t Remember When I Was 15 (#4.4)&#125;  [Himself]</span><br><span class="line">&quot;Peter Andre: My Life&quot; (2011) &#123;It&#39;s a New Chapter, Isn&#39;t It? (#5.1)&#125;  [Himself]</span><br><span class="line">&quot;Peter Andre: My Life&quot; (2011) &#123;Some Days Are Better Than Others (#4.1)&#125;  [Himself]</span><br><span class="line">&quot;Peter Andre: My Life&quot; (2011) &#123;There&#39;s Only One Problem... She Doesn&#39;t Like Coffee (#3.1)&#125;  [Himself]</span><br><span class="line">&quot;Peter Andre: My Life&quot; (2011) &#123;We&#39;re Off to Zanzib-Andre (#5.3)&#125;  [Himself]</span><br><span class="line">&quot;Peter Andre: My Life&quot; (2011) &#123;Why Wait, Why Hesitate? (#5.5)&#125;  [Himself]</span><br><span class="line"></span><br><span class="line">Andre, MiguelJourney Among Women (1977)  [Soldier]  &lt;21&gt;</span><br><span class="line"></span><br><span class="line">Andre, Mikail1 Lawan Satu (2013)  [Radhi]</span><br><span class="line">Dua Kalimah (2013)</span><br><span class="line">Gangster Wars (2013)  [Romeo]</span><br><span class="line">Mukasurat Cinta (2014)</span><br><span class="line">Sniper (2014)  [Mat Jambang]</span><br><span class="line">Tokak (2013)  [Boy]</span><br><span class="line"></span><br><span class="line">Andre, MikeA Mystery in Carmine (2012)  (as Mikey Andre)  [Toby]</span><br><span class="line"></span><br><span class="line">Andre, Mohd MikailHantu dalam botol kicap (2012)  [Azri]  &lt;4&gt;</span><br><span class="line"></span><br><span class="line">Andre, Mohd Pierre3 Temujanji (2012)  [Sein]  &lt;2&gt;</span><br><span class="line">3, 2, 1 cinta (2011)  (as Pierre Andre)  [Fariz]  &lt;3&gt;</span><br><span class="line">9 September (2007)  (as Pierre Andre)  [Kogi]  &lt;1&gt;</span><br><span class="line">Aku, Kau &amp; Dia (2012)  (as Pierre Andre)  [Abang Harris]</span><br><span class="line">Al-Hijab (2011)  (as Pierre Andre)  [Rafael]  &lt;1&gt;</span><br><span class="line">Chantek (2012)  [Ad]  &lt;1&gt;</span><br><span class="line">Cinta (2006)  [Taufiq]</span><br><span class="line">Cinta fotokopi (2005)  (as Pierre Andre)  [Din]</span><br><span class="line">Gol &amp; Gincu (2005)  [Reza]  &lt;3&gt;</span><br><span class="line">Jangan pandang belakang (2007)  [Darma]</span><br><span class="line">Jangan tegur (2009)  [Kamal]  &lt;2&gt;</span><br><span class="line">Krazy crazy krezy... (2009)  (as Pierre André)  &lt;3&gt;</span><br><span class="line">Pontianak harum sundal malam 2 (2005)  [Purnama]</span><br><span class="line">Potret mistik (2005)  (as Pierre Andre)  [Badrul]</span><br><span class="line">Salon (2005)  [Ezra Fernandez]  &lt;2&gt;</span><br><span class="line">Sepi (2008)  [Khalil]</span><br><span class="line">Seru (2011)  [Bob]</span><br><span class="line">Strawberi cinta (2012)  [Hakimi]</span><br><span class="line">X (2012&#x2F;I)  [Hafiz]</span><br><span class="line">&quot;Gol &amp; Gincu: The Series&quot; (2006)  [Reza]  &lt;2&gt;</span><br></pre></td></tr></table></figure><h3 id="用正则分析数据库文件"><a href="#用正则分析数据库文件" class="headerlink" title="用正则分析数据库文件"></a>用正则分析数据库文件</h3><p>我们使用正则来得到正确的数据，如果你之前没有接触过正则表达式，我推荐<a href="https://regexr.com/" target="_blank" rel="noopener">RegexR</a>网站提供给你学习。</p><p>我们将使用下面的正则字符串:</p><figure class="highlight re"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="literal">[A-Z<span class="identifier">a</span>-<span class="identifier">z</span>,.'<span class="identifier">$</span>&amp; ]</span>*)?(<span class="literal">[\<span class="identifier">t</span>]</span>*)(.+?)(<span class="literal">[ ]</span>*)\\((<span class="literal">[<span class="number">0</span>-<span class="number">9</span>,?]</span>&#123;<span class="number">4</span>&#125;)(.+?\\n&#123;<span class="number">2</span>&#125;)?</span><br></pre></td></tr></table></figure><p>这样会将所有的数据从演员中删除，然后你可以单独的使用这些数据。</p><h3 id="创建JAVA项目"><a href="#创建JAVA项目" class="headerlink" title="创建JAVA项目"></a>创建JAVA项目</h3><p>如果你之前没有接触过JAVA，希望你先学习一下JAVA的基础课程。</p><p>我们仅仅需要4个类：</p><ul><li>Main</li><li>Reader</li><li>Parser</li><li>Writer</li></ul><h4 id="创建Reader类"><a href="#创建Reader类" class="headerlink" title="创建Reader类"></a>创建Reader类</h4><p>我们应该做的第一件事是创建一个Reader类，该类将读取其中包含所有演员的数据库文件（database.txt）。在Java中，我们可以使用File和Scanner类读取文件的数据并将其放入ArrayList中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; lines = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Read</span><span class="params">(String dbFile)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            File readable = <span class="keyword">new</span> File(Reader<span class="class">.<span class="keyword">class</span>.<span class="title">getResource</span>(<span class="title">dbFile</span>).<span class="title">getFile</span>())</span>;</span><br><span class="line">            Scanner dbScanner = <span class="keyword">new</span> Scanner(readable);</span><br><span class="line">            <span class="keyword">while</span> (dbScanner.hasNextLine()) &#123;</span><br><span class="line">                String data = dbScanner.nextLine();</span><br><span class="line">                lines.add(data);</span><br><span class="line">            &#125;</span><br><span class="line">            dbScanner.close();</span><br><span class="line">             </span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span>(FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"File not found"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lines;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，创建保存String类型的ArrayList。公共方法Read（）将采用我们要读取的文件的路径，然后Scanner将每一行数据放入ArrayList中。如果没有剩余的行，关闭Scanner。</p><h4 id="创建Parser类"><a href="#创建Parser类" class="headerlink" title="创建Parser类"></a>创建Parser类</h4><p>为了将每一行的数据解析为结构化的csv文件，我们必须创建一个匹配模板并检查是否能够匹配刚刚读取的文件。</p><h5 id="ParseActors-方法"><a href="#ParseActors-方法" class="headerlink" title="ParseActors 方法"></a>ParseActors 方法</h5><p>ParseActors方法接收两个参数，文件存储的数据list，和一个正则表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;String&gt;&gt; ParseActors(ArrayList&lt;String&gt; input, String regex) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法返回一个String泛型的一个ArrayList，这样可以保证数据库中的每个演员和电影能被分别注册。</p><h5 id="创建匹配模式"><a href="#创建匹配模式" class="headerlink" title="创建匹配模式"></a>创建匹配模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pattern pattern = Pattern.compile(regex);</span><br></pre></td></tr></table></figure><h5 id="组装响应值"><a href="#组装响应值" class="headerlink" title="组装响应值"></a>组装响应值</h5><p>为了确保我们的csv文件是结构化的。我们创建一个ArrayList并且添加csv的header (Actor, Title, Year)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;ArrayList&lt;String&gt;&gt; collections = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;String&gt; &gt;();</span><br><span class="line"></span><br><span class="line">collections.add(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line"></span><br><span class="line">collections.get(<span class="number">0</span>).add(<span class="string">"Actor"</span>);</span><br><span class="line">collections.get(<span class="number">0</span>).add(<span class="string">"Title"</span>);</span><br><span class="line">collections.get(<span class="number">0</span>).add(<span class="string">"Year"</span>);</span><br></pre></td></tr></table></figure><h5 id="查找匹配项并填充collections"><a href="#查找匹配项并填充collections" class="headerlink" title="查找匹配项并填充collections"></a>查找匹配项并填充collections</h5><p>现在我们已经准备好列表并创建好了匹配模板，我们可以搜索匹配项。再次查看正则表达式字符串时，我们发现可以匹配一些内容。我们只需要演员的姓名，他上演的电影以及年份。</p><p>让我们创建一个映射所有结果的<code>for</code>循环，然后使用匹配模板找到正确的<code>strings</code>。<br>现在，该数据库存在一个大问题，那就是我们只能看到演员一次，然后才能看到他所播放的电影的完整列表。</p><p>一旦将演员放入<code>collections</code>，我们假设在找到另一个演员之前，找到的所有电影都是他所扮演的电影。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;String&gt;&gt; ParseActors(ArrayList&lt;String&gt; input, String regex) &#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(regex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ArrayList&lt;String&gt; lijst = new ArrayList&lt;String&gt;();</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;ArrayList&lt;String&gt;&gt; collections = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;String&gt; &gt;();</span><br><span class="line"></span><br><span class="line">        collections.add(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line"></span><br><span class="line">        collections.get(<span class="number">0</span>).add(<span class="string">"Actor"</span>);</span><br><span class="line">        collections.get(<span class="number">0</span>).add(<span class="string">"Title"</span>);</span><br><span class="line">        collections.get(<span class="number">0</span>).add(<span class="string">"Year"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.size(); i++) &#123;</span><br><span class="line">            Matcher matcher = pattern.matcher(input.get(i));</span><br><span class="line"></span><br><span class="line">            collections.add(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(matcher.find()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (matcher.group(<span class="number">1</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    String actor = matcher.group(<span class="number">1</span>).toString();</span><br><span class="line">                    <span class="comment">//lijst.add(actor.replaceAll("[,]", ""));   </span></span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(actor == <span class="string">""</span>)&#123;</span><br><span class="line">                        collections.get(i+<span class="number">1</span>).add(collections.get(i).get(<span class="number">0</span>).replaceAll(<span class="string">"[,]"</span>, <span class="string">""</span>).toString());</span><br><span class="line">                        System.out.println(collections.get(i+<span class="number">1</span>).get(<span class="number">0</span>));</span><br><span class="line">                         </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        collections.get(i+<span class="number">1</span>).add(actor.replaceAll(<span class="string">"[,]"</span>, <span class="string">""</span>));</span><br><span class="line">                        System.out.println(collections.get(i+<span class="number">1</span>).get(<span class="number">0</span>));</span><br><span class="line">                    &#125;     </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (matcher.group(<span class="number">3</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//lijst.add(matcher.group(3));</span></span><br><span class="line"></span><br><span class="line">                    collections.get(i+<span class="number">1</span>).add(matcher.group(<span class="number">3</span>).replaceAll(<span class="string">"[\",]"</span>, <span class="string">""</span>).replaceAll(<span class="string">"[,]"</span>, <span class="string">""</span>).toString());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (matcher.group(<span class="number">5</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//lijst.add(matcher.group(5));</span></span><br><span class="line">                    collections.get(i+<span class="number">1</span>).add(matcher.group(<span class="number">5</span>));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (matcher.group(<span class="number">6</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//lijst.add("null");</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> collections;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建Writer类"><a href="#创建Writer类" class="headerlink" title="创建Writer类"></a>创建Writer类</h4><p>Writer类的作用是将输出的数据写入到csv文件中，我们将在此类中创建的两种方法比Parser类简单得多。<br>我们需要再次使用File类，这一次，我们创建一个名为data.csv的文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File myObj = <span class="keyword">new</span> File(<span class="string">"data.csv"</span>);</span><br><span class="line">        <span class="keyword">if</span> (myObj.createNewFile()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"File created: "</span> + myObj.getName());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"File already exists."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"An error occurred."</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再创建一个writeToFile()方法，该方法将所有数据逐行写入CSV文件中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeToFile</span><span class="params">(ArrayList&lt;ArrayList&lt;String&gt;&gt; parserOutput)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileWriter myWriter = <span class="keyword">new</span> FileWriter(<span class="string">"data.csv"</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(parserOutput);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parserOutput.size(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(parserOutput.get(i).isEmpty())&#123;</span><br><span class="line">                    <span class="comment">//nothing</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   </span><br><span class="line">                    myWriter.append(parserOutput.get(i).get(<span class="number">0</span>) + <span class="string">","</span> + parserOutput.get(i).get(<span class="number">1</span>) + <span class="string">","</span> + parserOutput.get(i).get(<span class="number">2</span>) + <span class="string">"\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            myWriter.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"Successfully wrote to the file."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"An error occurred."</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="整合代码"><a href="#整合代码" class="headerlink" title="整合代码"></a>整合代码</h4><p>为了将所有的代码整合在一起，测试我们的解析器，我们需要：</p><ul><li>创建一个<code>Main.java</code>并添加我们的正则字符串和数据库文件地址</li><li>创建 Writer, Reader, 和 Parser的实例</li><li>创建一个list存储读取数据</li><li>创建一个list存储解析数据</li></ul><p>最后，我们将所有的数据写入到csv文化中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String file = <span class="string">"/databases/actorstest.txt"</span>;</span><br><span class="line">        String regex = <span class="string">"([A-Za-z,.'$&amp; ]*)?([\t]*)(.+?)([ ]*)\\(([0-9,?]&#123;4&#125;)(.+?\\n&#123;2&#125;)?"</span>;</span><br><span class="line"></span><br><span class="line">        Reader reader = <span class="keyword">new</span> Reader();</span><br><span class="line">        Parser parser = <span class="keyword">new</span> Parser();</span><br><span class="line">        Writer writer = <span class="keyword">new</span> Writer();</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;String&gt; lijst = reader.Read(file);</span><br><span class="line">        ArrayList&lt;ArrayList&lt;String&gt;&gt; parsed = parser.ParseActors(lijst, regex);</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">        writer.createFile();</span><br><span class="line">        writer.writeToFile(parsed);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="运行代码测试解析器"><a href="#运行代码测试解析器" class="headerlink" title="运行代码测试解析器"></a>运行代码测试解析器</h4><p>运行代码之后，会自动创建一个<code>data.csv</code>的文件，如下：</p><iframe src="/downloads/code/demo.html" allowfullscreen="" frameborder="0" height="2252" width="680" title="data.csv"  scrolling="auto"></iframe><p>如你所见，它存储了所有的数据，并按照<code>标题</code>, <code>演员</code>, 和<code>年份</code>分组。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们为演员列表创建了一个解析器。如果要解析更多IMDB列表或找到的任何数据库/列表，则可以创建一个新的Parse（）方法。<br>这样的解析器使您可以更好地理解数据的外观。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[译] JAVA16带给开发者的新特性</title>
      <link href="2021/03/29/%E8%AF%91-JAVA16%E5%B8%A6%E7%BB%99%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>2021/03/29/%E8%AF%91-JAVA16%E5%B8%A6%E7%BB%99%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="https://levelup.gitconnected.com/features-java-16-brings-to-developers-b0edd1a1ed28" target="_blank" rel="noopener">Features Java 16 Brings to Developers</a><br>原文作者：<a href="https://zivce.medium.com/" target="_blank" rel="noopener">Živković Miloš</a><br>译者：<a href="https://maybelence.cn/">maybelence</a></p></blockquote><p>Java不需要再做过多介绍。它作为一种编程语言，已经有很多年的发展历史。最近的更新也为该语言带来了几个新的特性：</p><ul><li>密封类</li><li>模式匹配</li><li>其他安全措施。</li></ul><h3 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h3><p><a href="https://openjdk.java.net/jeps/397" target="_blank" rel="noopener">JEP-397</a></p><p><code>密封</code>的目的是限制具体的类。密封将实现控制模式匹配，并提供对模式匹配的支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里可以许可的关键字已经密封 </span></span><br><span class="line"><span class="comment">// 允许列出可以扩展密封等级的等级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">    <span class="title">permits</span> <span class="title">Circle</span>, <span class="title">Rectangle</span>, <span class="title">Square</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>如果使用基本的接口，那你将不会得到反射，您不会对这些有限的具体实现有细致了解。</p><p>当使用密封类的话，你将获取到这个反射行为，您知道自己域中可以拥有的类型。</p><p>枚举表明了一组有限的值。密封类表明了一组数量有限的一种值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sealed <span class="class"><span class="keyword">interface</span> <span class="title">Celestial</span> </span></span><br><span class="line"><span class="class">    <span class="title">permits</span> <span class="title">Planet</span>, <span class="title">Star</span>, <span class="title">Comet</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Planet</span> <span class="keyword">implements</span> <span class="title">Celestial</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Star</span>   <span class="keyword">implements</span> <span class="title">Celestial</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Comet</span>  <span class="keyword">implements</span> <span class="title">Celestial</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是，这种层次结构并不会反映出重要的领域知识，即我们的模型中只有三种。<br>在这些情况下，限制子类或者子接口的集合可以简化建模。 — JEP-397</p></blockquote><h3 id="对基于值的类的值发出警告"><a href="#对基于值的类的值发出警告" class="headerlink" title="对基于值的类的值发出警告"></a>对基于值的类的值发出警告</h3><p><a href="https://openjdk.java.net/jeps/390" target="_blank" rel="noopener">JEP-390</a></p><p>基本类型的包装类是基于值的类，例如：<code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>Boolean</code>,和 <code>Character</code>。有关基于值的类的更多信息，请参见<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/doc-files/ValueBased.html" target="_blank" rel="noopener">此处</a>。</p><p>由于它们是不可变的对象，因此构造函数对于它们来言是没有任何意义的。</p><p>为了防止滥用构造函数，提供<code>@jdk.internal.ValueBased</code>来用于标注作为value-based的类。每次编译器找到基于值的类构造函数时，这都会发出警告。</p><h3 id="默认强封装JDK内部元素"><a href="#默认强封装JDK内部元素" class="headerlink" title="默认强封装JDK内部元素"></a>默认强封装JDK内部元素</h3><p><a href="https://openjdk.java.net/jeps/396" target="_blank" rel="noopener">JEP-396</a></p><p>这是为了鼓励用户使用标准的Java API。不过，如果您如果需要使用宽松的封装。请尽量避免使用该特性。</p><p>您需要将参数添加到JVM的启动器中。在下面您可以看到可能的参数，您可以传入。有关参数的更多信息，请参见<a href="https://openjdk.java.net/jeps/396#Description" target="_blank" rel="noopener">此处</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--illegal-access&#x3D; permit | deny | debug | warn</span><br></pre></td></tr></table></figure><p>尽管JAVA16包含了此功能，但是您可能在更早的<a href="https://stackoverflow.com/questions/53790182/get-the-current-value-of-illegal-access-setting-in-java" target="_blank" rel="noopener">版本</a>就遇到了这种问题，这个更改是在JAVA9<a href="https://jaxenter.com/jdk-9-replace-permit-illegal-access-134180.html" target="_blank" rel="noopener">发布</a>之后提出的。</p><blockquote><p>直至今日，某些构建工具在构建Java项目(Java&gt; = 9)时仍会打印出<a href="https://issues.apache.org/jira/browse/GROOVY-8339" target="_blank" rel="noopener">“反射访问”警告</a>，即使已经成功构建，它们也会感觉“尚未就绪”。 - <a href="https://www.marcobehler.com/guides/a-guide-to-java-versions-and-features" target="_blank" rel="noopener">出处</a></p></blockquote><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p><a href="https://openjdk.java.net/jeps/394" target="_blank" rel="noopener">JEP-394</a></p><p>模式匹配已经存在很长时间了，你可以在很多编程语言中发现它，例如Elixir。</p><p>在JAVA中，存在许多<code>instanceof</code>条件。因为有减少操作的动机从而衍生出了模式匹配。</p><blockquote><p>模式匹配允许简明地表达对象的所需“形状”（模式），并允许各种语句和表达式针对其输入（匹配）来测试“形状”。 — JEP-394</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很多样板代码</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    String s = (String) obj;    <span class="comment">// grr...</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用模式匹配，我们可以获得此代码。减少样板，进行转换，并声明变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">    <span class="comment">// Let pattern matching do the work!</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模式变量在它匹配的范围内。因此，这样的代码是有效的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a <span class="keyword">instanceof</span> Point p) &#123;</span><br><span class="line">    <span class="comment">// p在范围内</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p不再范围内</span></span><br><span class="line"><span class="keyword">if</span> (b <span class="keyword">instanceof</span> Point p) &#123;     <span class="comment">// Sure!</span></span><br><span class="line">        ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您不必担心变量名。如果范围不同，则可以重用现有名称。</p><p><em>模式匹配改善了什么？？？</em></p><p>可以避免很多显示的转换，让我们用相同的方法，写出可读性更高的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (o <span class="keyword">instanceof</span> CaseInsensitiveString) &amp;&amp;</span><br><span class="line">        ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</span><br><span class="line"><span class="comment">// to this </span></span><br><span class="line"><span class="keyword">return</span> (o <span class="keyword">instanceof</span> CaseInsensitiveString cis) &amp;&amp;</span><br><span class="line">        cis.s.equalsIgnoreCase(s);</span><br></pre></td></tr></table></figure><p>现在看下一个例子，如果instanceof String s的条件为true，则为s分配一个值。相反，如果模式匹配失败，那么s将没有任何值。</p><p>因此这个代码完全可以正常执行，不存在<a href="https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.22" target="_blank" rel="noopener">语句不可达</a>的情况。如果有条件通过，则s分配值；如果没有通过，则s被安全丢弃。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onlyForStrings</span><span class="params">(Object o)</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> String s))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyException();</span><br><span class="line">    <span class="comment">// s has value at this point</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Java在不断发展。导致很多重大更改。同时也引入很多<a href="https://medium.com/dev-genius/8-problems-every-java-developer-knows-4f65339e0c00" target="_blank" rel="noopener">问题</a>。</p><p><img src="0_MzIcNjgSR9uVS3yb.png" alt="Constant Java updates"></p><p>即使这样，我们仍然需要进行调整。使用新特性，以便我们创建更好的软件。这些是我提出的几个新特性。您可以在下面的部分中阅读更多内容。</p><hr><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>JEP草案：开关的模式匹配（preview）<a href="https://openjdk.java.net/jeps/406" target="_blank" rel="noopener">点此查看</a></p><p>JDK16：JAVA16中的新特性 <a href="https://www.infoworld.com/article/3569150/jdk-16-the-new-features-in-java-16.html" target="_blank" rel="noopener">点此查看</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA16 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切面编程--springAOP</title>
      <link href="2021/03/24/%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B-springAOP/"/>
      <url>2021/03/24/%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B-springAOP/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>AOP意为<code>面向切面编程</code>，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术，是OOP面向对象编程的一种补足。它是软件开发中的一个热点技术，Spring AOP 也是Spring框架的核心特性之一（另一个核心特性是IOC）</p><h4 id="为什么要引入AOP"><a href="#为什么要引入AOP" class="headerlink" title="为什么要引入AOP"></a>为什么要引入AOP</h4><ul><li>分离功能性需求和非功能性需求</li><li>集中处理某一关注点</li><li>侵入性少，增强代码可读性及可维护性</li></ul><h4 id="AOP应用场景"><a href="#AOP应用场景" class="headerlink" title="AOP应用场景"></a>AOP应用场景</h4><p>权限控制、缓存控制、事务控制、分布式追踪、异常处理等</p><p>举个例子，比如一个后台管理系统，每次修改元素信息的时候，都需要校验操作人是否拥有该操作权限，在传统的OOP中，我们需要写一个<code>基类</code>，声明鉴权方法，在子类中调用super.checkPriv();来返回结果。如果Service很多，每个Service都需要继承BaseService,就会导致耦合度过高，代码冗余。<br>而AOP可以直接通过一个单一的切面类，对需要权限验证的方法统一织入。就好像一个包租婆，她其实关心的只是跟用户签合同和收房租，如果每来一个用户，她都要带着看房、谈价格。对她而言显然是不乐意的。所以中介就出现了，这种重复且非核心的事情，直接交给中介。她就可以专注于签合同和收租。</p><p><img src="1.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Landlady1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 仅仅只是实现了核心的业务功能</span></span><br><span class="line">        System.out.println(<span class="string">"签合同"</span>);</span><br><span class="line">        System.out.println(<span class="string">"收租"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Landlady2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 仅仅只是实现了核心的业务功能</span></span><br><span class="line">        System.out.println(<span class="string">"签合同"</span>);</span><br><span class="line">        System.out.println(<span class="string">"收租"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Intermediary</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.example.*.service())"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPointCut</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"logPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//重复且非核心的事情</span></span><br><span class="line">        System.out.println(<span class="string">"带租客看房"</span>);</span><br><span class="line">        System.out.println(<span class="string">"谈价格"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册过程"><a href="#注册过程" class="headerlink" title="注册过程"></a>注册过程</h3><h4 id="AopAutoConfiguration"><a href="#AopAutoConfiguration" class="headerlink" title="AopAutoConfiguration"></a>AopAutoConfiguration</h4><p>AopAutoConfiguration 这个配置类主要是配置aop的代理类型，默认spring.aop.auto=true。看注释的意思，<code>spring.aop.auto=true</code>为true的时候，通过为配置类添加<code>@EnableAspectJAutoProxy</code>，spring默认就会开启AOP功能。springboot2.0之后AOP代理有三种策略：</p><ul><li>jdk动态代理：当spring.aop.proxy-target-class=false, 引入了aspectjweaver依赖时生效</li><li>cglib代理：当spring.aop.proxy-target-class=true, 引入了aspectjweaver依赖时生效</li><li>基础代理：当spring.aop.proxy-target-class=true, 若没有aspectjweaver依赖时生效，只作用于框架内部的advisors<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.boot.autoconfigure.EnableAutoConfiguration</span></span><br><span class="line"><span class="comment"> * Auto-configuration&#125; for Spring's AOP support. Equivalent to enabling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> EnableAspectJAutoProxy <span class="doctag">@EnableAspectJAutoProxy</span>&#125; in your configuration.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The configuration will not be activated if &#123;<span class="doctag">@literal</span> spring.aop.auto=false&#125;. The</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@literal</span> proxyTargetClass&#125; attribute will be &#123;<span class="doctag">@literal</span> true&#125;, by default, but can be</span></span><br><span class="line"><span class="comment"> * overridden by specifying &#123;<span class="doctag">@literal</span> spring.aop.proxy-target-class=false&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Josh Long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableAspectJAutoProxy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"auto"</span>, havingValue = <span class="string">"true"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为该注解的这个默认值是true，这些都不能省略，我好痛苦</span></span><br><span class="line">    <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>) </span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(Advice<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">class</span> <span class="title">AspectJAutoProxyingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"false"</span>,</span><br><span class="line">matchIfMissing = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAutoProxyConfiguration</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"true"</span>,</span><br><span class="line">matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibAutoProxyConfiguration</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnMissingClass</span>(<span class="string">"org.aspectj.weaver.Advice"</span>)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"true"</span>,</span><br><span class="line">matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassProxyingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ClassProxyingConfiguration(BeanFactory beanFactory) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h4><p>从代码可以看出 @EnableAspectJAutoProxy 引入了 AspectJAutoProxyRegister.class 对象 ，AspectJAutoProxyRegister 给容器中注册一个 AnnotationAwareAspectJAutoProxyCreator：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(AspectJAutoProxyRegistrar<span class="class">.<span class="keyword">class</span>) //引入<span class="title">AspectJAutoProxyRegister</span>.<span class="title">class</span>对象</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAspectJAutoProxy</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//默认使用java接口创建代理，当值为true的时候采用CGlib基于类代理</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//是否通过aop框架暴露该代理对象，AopContext能够访问.</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AspectJAutoProxyRegistrar"><a href="#AspectJAutoProxyRegistrar" class="headerlink" title="AspectJAutoProxyRegistrar"></a>AspectJAutoProxyRegistrar</h4><p>这个类的作用注释写的也很明白， 基于<code>@EnableAspectJAutoProxy</code>注解的情况下，对当前的<code>BeanDefinitionRegistry</code>注册一个<code>AnnotationAwareAspectJAutoProxyCreator</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Registers an org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line"><span class="comment"> * AnnotationAwareAspectJAutoProxyCreator against the current BeanDefinitionRegistry</span></span><br><span class="line"><span class="comment"> * as appropriate based on a given <span class="doctag">@EnableAspectJAutoProxy</span> annotation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">    <span class="comment">//下面的代码是判断是否采用CGlib和通过AOP暴露该代理对象的代码</span></span><br><span class="line">    <span class="comment">//全省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>直接接着看<code>AopConfigUtils</code>, registerAspectJAnnotationAutoProxyCreatorIfNecessary 这个方法，这个方法最后调用到了<code>registerOrEscalateApcAsRequired</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Class&lt;?&gt; cls, BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123; <span class="comment">//如果registry已经包含目标bean</span></span><br><span class="line">        BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">        <span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">            <span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line">            <span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">                apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">    beanDefinition.setSource(source);</span><br><span class="line">    beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    <span class="comment">//否则将beanDefinition注册进registry中,注册名为 AUTO_PROXY_CREATOR_BEAN_NAME</span></span><br><span class="line">    registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">    <span class="keyword">return</span> beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AnnotationAwareAspectJAutoProxyCreator对目标对象进行代理对象的创建，创建代理对象过程中，会先创建一个代理工厂，获取到所有的增强器（通知方法），将这些增强器和目标类注入代理工厂，再用代理工厂创建对象；<br>代理对象执行目标方法，得到目标方法的拦截器链，利用拦截器的链式机制，依次进入每一个拦截器进行执行。</p>]]></content>
      
      
      <categories>
          
          <category> Frameworks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 切面编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题--StrStr()</title>
      <link href="2021/03/23/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-StrStr/"/>
      <url>2021/03/23/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-StrStr/</url>
      
        <content type="html"><![CDATA[<p>昨天和朋友劳(da)逸(you)结(xi)合的时候，朋友告诉我他实现了一个Strstr()。然后我去看了一下，题目难度属于Easy。想着做出来还是简单的，于是立马动手操作了一把。</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>实现 strStr() 函数。</p><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p><p>示例 1:</p><blockquote><p>输入: haystack = “hello”, needle = “ll”<br>输出: 2<br>示例 2:</p><p>输入: haystack = “aaaaa”, needle = “bba”<br>输出: -1</p></blockquote><blockquote id="fn_链接：https://leetcode-cn.com/problems/implement-strstr"><sup>链接：https://leetcode-cn.com/problems/implement-strstr</sup>. 来源：力扣（LeetCode）<a href="#reffn_链接：https://leetcode-cn.com/problems/implement-strstr" title="Jump back to footnote [链接：https://leetcode-cn.com/problems/implement-strstr] in the text."> &#8617;</a></blockquote><p>因为我是一个java党，我拿到这个题目一看，这不就是indexOf吗，于是我优雅的写下了第一行代码。。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> haystack.indexOf(needle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="临界情况"><a href="#临界情况" class="headerlink" title="临界情况"></a>临界情况</h4><p>但是题目的本意显然不是让我们之间调用API，strStr()是C++的API，题目的本意是让我们实现他，短暂思索一下。我就开始了我接下来的思路。<br>既然要返回初始下标，那我直接将字符串转为char[]，通过判断数组下标，返回起始位置,当needle是空串的时候按照API的返回结果默认应该返回0，因此加了一层特殊的条件判断。然后开始思考indexOf如何实现。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] sources = haystack.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] targets = needle.toCharArray();</span><br><span class="line">    <span class="keyword">return</span> indexOf(sources, targets, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来思考临界条件。当targets的长度大于sources长度的时候。那肯定是匹配不上的。因此直接返回-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] sources, <span class="keyword">char</span>[] targets, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (targets.length &gt; sources.length)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理思路"><a href="#处理思路" class="headerlink" title="处理思路"></a>处理思路</h4><p>当满足targets的长度小于等于sources的长度的时候，我需要去寻找targets中第一个元素作为sources第一次出现的位置。如果从头至尾我都找不到这个元素，那么说明匹配不是，直接返回-1，如果我能找到这个元素的下标，则看后面能否完全匹配，若能这个第一次出现的位置就是返回下标。如果后面不完全匹配，那么我可以截取sources中这个<code>下标</code>到<code>sources.length</code>生成一个新的数组，我定义为newsources，重复这个匹配逻辑，如果匹配上，那么返回坐标就是sources中第一次出现的位置加上newsources中第一次出现的位置，如果没匹配上，就重复分割数组，直至<code>匹配成功</code>或者出现上面<code>临界情况</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] sources = haystack.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] targets = needle.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> indexOf(sources, targets, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] sources, <span class="keyword">char</span>[] targets, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (targets.length &gt; sources.length)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//先找到第一个位置</span></span><br><span class="line">        <span class="keyword">char</span> Item = targets[<span class="number">0</span>];</span><br><span class="line">        BREAK:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sources.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sources[i] == Item) &#123;</span><br><span class="line">                fromIndex = i; <span class="comment">//预设定</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; targets.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i == sources.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//这里其实可以优化，当找到第一个位置之后，</span></span><br><span class="line">                    <span class="comment">//直接判断sources剩余长度是不是大于等于targets长度可省略很多次if判断</span></span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (sources[i++] != targets[j]) &#123;</span><br><span class="line">                        fromIndex++;</span><br><span class="line">                        <span class="keyword">break</span> BREAK;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fromIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//全部遍历都找不到第一个元素，返回-1</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> == sources.length)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">int</span> thenIndex = indexOf(Arrays.copyOfRange(sources, fromIndex, sources.length), targets, fromIndex);</span><br><span class="line">        <span class="keyword">return</span> thenIndex == -<span class="number">1</span> ? -<span class="number">1</span> : fromIndex + thenIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面在遍历匹配的时候，我加了一层判断，因为可能sources剩余长度如果小于targets长度，i++之后 sources[i++]有可能会数组越界。这种处理其实不好，可以直接在遍历targets之前判断sources.length-fromIndex是不是比targets.length大。这样可以省略很多次if判断，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sources.length-fromIndex&lt;targets.length)&#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; targets.length; j++) &#123;</span><br><span class="line">    <span class="comment">// if (i != 0 &amp;&amp; i == sources.length - 1) &#123;</span></span><br><span class="line">    <span class="comment">// //这里其实可以优化，当找到第一个位置之后，</span></span><br><span class="line">    <span class="comment">// //直接判断sources剩余长度是不是大于等于targets长度可省略很多次if判断</span></span><br><span class="line">    <span class="comment">//     return -1; </span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">if</span> (sources[i++] != targets[j]) &#123;</span><br><span class="line">        fromIndex++;</span><br><span class="line">        <span class="keyword">break</span> BREAK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其实类似字符串的匹配算法还有很多，比较有名的KMP算法，或者利用哈希表来处理，都是一些解决方案，仅此记录一下我的解法，勿喷勿喷。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百问不厌的乐观锁和悲观锁</title>
      <link href="2021/01/28/%E7%99%BE%E9%97%AE%E4%B8%8D%E5%8E%8C%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/"/>
      <url>2021/01/28/%E7%99%BE%E9%97%AE%E4%B8%8D%E5%8E%8C%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>乐观锁和悲观锁一直都是面试中高频考察点，面试官也喜欢从这类问题去考察面试者的基本功。今天我们就来聊一下乐观锁和悲观锁的实现：<br><code>CAS，Synchronized，ReentrantLock</code>。</p><p>首先要对乐观锁和悲观锁，我们要有一定的概念：</p><ul><li>悲观锁：悲观的认为只要不做正确的数据同步措施，它就一定会出问题</li><li>乐观锁：乐观的认为不需要去采取同步措施也不会出问题，如果出现问题，再去补救</li></ul><p>那具体通过哪些方式去才取同步呢，在多线程中，同步机制主要分为以下四种，具体的区别以后再讲：</p><ul><li>互斥量：为协调共同对一个共享资源的单独访问而设计的。</li><li>临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。</li><li>临界量：为控制一个具有有限数量用户资源而设计。</li><li>事件：用来通知线程有一些事件已发生，从而启动后继任务的开始。</li></ul><h3 id="互斥（同步阻塞）悲观锁"><a href="#互斥（同步阻塞）悲观锁" class="headerlink" title="互斥（同步阻塞）悲观锁"></a>互斥（同步阻塞）悲观锁</h3><p>互斥只是同步机制的其中一个手段，也是很常见的保障并发正确性的手段<br>我们知道传统的锁（如<code>synchronized</code>或者<code>ReentrantLock</code>）之所以被称为重量级锁，就是因为他使用操作系统互斥量来实现同步。</p><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>synchronized能实现同步的基础：也是因为在java中，所有对象都可以作为锁。</p><p>具体表现为以下3种形式。</p><ul><li>对于普通同步方法，锁是当前实例对象。</li><li>对于静态同步方法，锁是当前类的Class对象。</li><li>对于同步方法块，锁是Synchonized括号里配置的对象。</li><li>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</li></ul><p>synchronized是基于<code>Monitor</code>来实现同步的。当<code>synchronized</code>经过编译之后，<strong>会在<code>同步块</code>的前后分别形成<code>monitorenter</code>和<code>monitorexit</code>指令</strong>。</p><ul><li>每个monitor维护着一个记录着拥有次数的计数器。未被拥有的monitor的该计数器为0</li><li>当执行进入monitorenter时，锁计数器就会+1，当执行到monitorexit,锁计数器就会-1。当锁计数器为0的时候，锁就会被释放</li><li>synchronized不会出现自己死锁自己的情况，因为对于已经进入同步块的线程，synchronized锁是可重入的</li><li>在synchronized同步代码块执行完，会阻塞其他线程进入同步锁（排他锁）</li><li>对于<code>同步方法</code>，<code>synchronized</code>同步方式是通过方法中的access_flags中设置<code>ACC_SYNCHRONIZED</code>标志来实现</li></ul><p>并且，随着JDK6对<code>synchronized</code>进行了各种优化之后，有些情况下synchronized就并不那么重,JDK6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁。<br>针对<code>synchronized</code>获取锁的方式，JVM 使用了锁升级的优化方式，就是先使用偏向锁优先同一线程然后再次获取锁，如果失败，就升级为 CAS 轻量级锁，如果失败就会短暂自旋，防止线程被系统挂起。最后如果以上都失败就升级为重量级锁。并且锁只能向上升级，不能降级。</p><p><img src="11.png" alt=""></p><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>实现ReentrantLock的基础是AQS( AbstractQueuedSynchronizer 队列同步器)，AQS 有一个 state 标记位，值为<code>1</code>时表示有线程占用，其他线程需要进入到同步队列等待，同步队列是一个双向链表。<br>当获得锁需要等待某个条件时，会进入condition队列，进入等待队列的可以有很多个。当满足condition的条件的时候，线程就会重新竞争锁资源。<br>ReentrantLock 内部有公平锁和非公平锁两种实现，差别就在于新来的线程是否比已经在同步队列中的等待线程更早获得锁。</p><p><img src="12.png" alt=""></p><p>ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。<br>它有公平锁FairSync和非公平锁NonfairSync两个子类。<br>ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p><h3 id="非阻塞同步（乐观锁）"><a href="#非阻塞同步（乐观锁）" class="headerlink" title="非阻塞同步（乐观锁）"></a>非阻塞同步（乐观锁）</h3><h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>CAS(Compare And Swap)是一种乐观锁的实现方式。是一种轻量级锁，JUC 中很多工具类的实现都是基于<code>CAS</code>的。CAS操作包含三个操作数—— 内存位置的值（V）、预期原值（A）和新值（B）。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值。</p><p><img src="13.png" alt=""></p><p>但是这种情况，当数据被其他线程修改，就会出现一直循环。导致CPU资源一直消耗过多。除此之外<code>CAS</code>本身还存在<code>ABA问题</code>。即线程一读取数据A，线程二也读取数据A，线程二通过CAS比较发现数据是A，于是将A写回B，线程三读取B，线程三通过CAS比较发现数据是B没有被操作过，又将数据写回A，此时线程一读到的是A，会以为数据没有改变过。对于ABA问题，通过控制变量值的<code>版本号</code>（自增字段或者时间戳）来保证CAS的正确性。具体解决思路就是在变量前追加上版本号，每次变量更新的时候把版本号加一，那么A - B - A就会变成1A - 2B - 3A。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>今日偷懒，不写总结。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单聊一下volatile</title>
      <link href="2021/01/06/%E7%AE%80%E5%8D%95%E8%81%8A%E4%B8%80%E4%B8%8Bvolatile/"/>
      <url>2021/01/06/%E7%AE%80%E5%8D%95%E8%81%8A%E4%B8%80%E4%B8%8Bvolatile/</url>
      
        <content type="html"><![CDATA[<p>开始讲这个题目之前，先来聊一下什么是线程安全。多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是<code>线程安全</code>的。</p><p>这是一个很常见的面试题，再接着往下深入一点，如何保证线程安全呢？线程安全一般是从三个方面考虑：</p><ul><li>原子性: <code>synchronized</code>确保同一时间只有一个线程能拿到锁,进入当前代码块</li><li>可见性：<code>volatile</code>保证不同线程对共享变量操作的可见性,<code>synchronized</code>获得锁后会清空工作内存，从主存拷贝最新的变量到工作内存(副本)，再将修改后的副本重新刷到主存中，然后释放锁，其他没有获得锁的线程都处于阻塞状态，因此也能保证数据可见性。</li><li>有序性：<code>volatile</code>本身就具有指令重排序，<code>synchronized</code>和<code>Lock</code>保证每个时刻是有一个线程执行同步代码，自然就保证了有序性。</li></ul><p>说完这些我们开始看一个控制台小程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> maybelence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@descrpition</span> a demo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; fun = System.out::println;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.start();</span><br><span class="line">        <span class="keyword">while</span> (!test.isFlag())&#123; &#125;</span><br><span class="line">        fun.accept(<span class="string">"你真厉害"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">"flag is "</span>+ flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台打印的是<code>flag is true</code>，现在应该不足为奇了。那如何让计算机对你说“你真厉害”呢。这时候应该可以胸有成竹的选择volatile或者synchronized。<br>先来看一下synchronized实现。<br>我这里大致写了一下,这里只有第一种会打印“你真厉害”，但是第二种并不会打印。第一种每循环一次都会获取一次锁，当执行完成之后，会将flag值从工作内存刷新到主存中。但是第二种，他在获取锁的时候，flag仍然是false的，然后就进入了无限死循环。并不会将flag值更新到主存中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; fun = System.out::println;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.start();</span><br><span class="line">        <span class="keyword">while</span> (!test.isFlag()) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (test) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fun.accept(<span class="string">"你真厉害"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testmain</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; fun = System.out::println;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.start();</span><br><span class="line">        <span class="keyword">synchronized</span> (test) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!test.isFlag()) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fun.accept(<span class="string">"你真厉害"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>现在来看一下加volatile修饰的方式,每个线程在操作数据的时候，会将数据从主内存中拷贝一份副本到当前线程的工作内存，如果该线程对于副本操作，并且写回了。<br>那么其他线程所取得的副本就失效了。需要对数据操作的话就又得从主存中重新读取。而volatile可以保证不同线程对于该变量的可见性，也就是当一个线程对于该数据操作之后，并写回主存，其他线程就可以立即获得该变量最新的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">"flag is "</span>+ flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那当有多个线程同时对<code>flag</code>进行操作，那刷新到主存中以谁的数据为准呢？对于这种缓存不一致性问题，通常有两种方式：</p><ul><li>通过在总线加LOCK#锁的方式（锁总线）</li><li>通过某些缓存一致性协议（锁缓存）</li></ul><h3 id="锁总线"><a href="#锁总线" class="headerlink" title="锁总线"></a>锁总线</h3><p>CPU总线是CPU与所有芯片连接的主干道，当一个CPU要操作数据的时候，它向总线发送一个<code>LOCK#</code>的信号，其他处理器就会处于阻塞状态。从而使该CPU可以独享此共享内存。但是锁总线会导致其他CPU与共享内存之间的通信被锁住，导致对其他共享内存的数据也无法操作，因此开销较大。</p><h3 id="锁缓存"><a href="#锁缓存" class="headerlink" title="锁缓存"></a>锁缓存</h3><p>以在Intel系列中广泛使用的MESI协议为例，当CPU操作数据的时候，如果发现该变量是一个共享变量，即在其他处理器中也存在该变量的副本。那么就会发信号告知该CPU将该变量的缓存行置为无效状态。当其他CPU需要读取这个数据的时候，会查看该变量是否是失效状态，如果是失效状态，会重新从共享内存中重新读取该变量的值。至于CPU是如何发现数据是否已经过期。是CPU通过<code>嗅探</code>在总线上传播的数据来检查自己的缓存是否过期。当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行置为失效状态，当处理器需要对这个数据进行<code>读取(操作)</code>的时候，会重新从系统内存中读取该数据。</p><blockquote><p>由于volatile的mesi缓存一致性协议需要不断的从主内存嗅探和cas不断循环无效交互导致总线带宽达到峰值<code>(总线风暴)</code>。因此不要大量使用volatile。</p></blockquote><h2 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h2><blockquote><p>为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。</p></blockquote><p>一段源码，到最后执行，需要经历那些重排序规则呢？</p><p><img src="00.png" alt="源码到执行指令经历的重排序"></p><p>一个好的内存模型，会尽可能小的去约束处理器和编译器，在不改变程序执行结果的情况下，尽可能提高程序的执行效率。因此JMM会尽量减少对底层的约束，使其能够发挥自身优势。</p><p>一般重排序分为以下三种：</p><ul><li>编译器的重排序：编译器在不改变单线程语义的情况下，可以重新定义语句执行顺序</li><li>指令集并行的重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</li><li>内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的</li></ul><p>这里要提到一个概念：<code>as-if-serial</code>。</p><blockquote><p>不管怎么重排序，单线程下的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p></blockquote><h3 id="Volatile如何禁止重排序"><a href="#Volatile如何禁止重排序" class="headerlink" title="Volatile如何禁止重排序"></a>Volatile如何禁止重排序</h3><p>java编译器会在生成指令系列时在适当的位置会插入<code>内存屏障</code>指令来禁止特定类型的处理器重排序。并且为了实现volatile的内存语义，为了实现volatile的内存语义，JMM会限制特定类型的编译器和处理器重排序，JMM会针对编译器制定volatile重排序规则表：</p><div class="table-container"><table><thead><tr><th>能否重排序</th><th></th><th><strong>第二个操作</strong></th><th></th></tr></thead><tbody><tr><td><strong>第一个操作</strong></td><td>普通读（写）</td><td>volatile（读）</td><td>volatile（写）</td></tr><tr><td>普通读（写）</td><td></td><td></td><td>NO</td></tr><tr><td>volatile（读）</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>volatile（写）</td><td></td><td>NO</td><td>NO</td></tr></tbody></table></div><blockquote><p>volatile<code>写</code>是在<code>前面和后面</code>分别插入内存屏障，而volatile<code>读</code>操作是在<code>后面插入两个</code>内存屏障。</p></blockquote><p><img src="01.png" alt="volatile写"></p><p><img src="02.png" alt="volatile读"></p><p>上述重排序规则，为了提高处理速度，JVM往往会对代码进行指令重排序优化。并发编程下指令重排序会带来一些安全隐患：如指令重排序导致的多个线程操作之间的不可见性。</p><p>从JDK5开始，提出了<code>happens-before</code>的概念，通过这个概念来阐述操作之间的内存可见性。</p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。<br><code>volatile域规则：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读。</code><br>如果现在我的变了flag变成了false，那么后面的那个操作，一定要知道我变了。</p><p>一定要记住<code>volatile无法保证原子性</code>，如果非要保证原子性，可以采用concurrent包下的一些原子类或者给加锁。关于volatile的应用，可以看之前有一篇讲单例的文章<a href="/2020/09/25/那些年我们学过的设计模式，你还记得几个（一）/">2020-09-25-那些年我们学过的设计模式，你还记得几个（一）</a>。</p><h3 id="volatile和synchronized的区别"><a href="#volatile和synchronized的区别" class="headerlink" title="volatile和synchronized的区别"></a>volatile和synchronized的区别</h3><ul><li>volatile只能修饰实例变量和类变量，而synchronized可以修饰方法，以及代码块。</li><li>volatile保证数据的可见性，但是不保证原子性(多线程进行写操作，不保证线程安全);而synchronized是一种排他(互斥)的机制。</li><li>volatile用于禁止指令重排序：可以解决单例双重检查对象初始化代码执行乱序问题。</li><li>volatile可以看做是轻量版的synchronized，volatile不保证原子性，但是如果是对一个共享变量进行多个线程的赋值，而没有其他的操作，那么就可以用volatile来代替synchronized，因为赋值本身是有原子性的，而volatile又保证了可见性，所以就可以保证线程安全了。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>volatile修饰符适用于以下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值，比如booleanflag;或者作为触发器，实现轻量级同步。</p></li><li><p>volatile属性的读写操作都是无锁的，它不能替代synchronized，因为它没有提供原子性和互斥性。因为无锁，不需要花费时间在获取锁和释放锁_上，所以说它是低成本的。</p></li><li><p>volatile只能作用于属性，我们用volatile修饰属性，这样compilers就不会对这个属性做指令重排序。</p></li><li><p>volatile提供了可见性，任何一个线程对其的修改将立马对其他线程可见，volatile属性不会被线程缓存，始终从主存中读取。</p></li><li><p>volatile提供了happens-before保证，对volatile变量v的写入happens-before所有其他线程后续对v的读操作。</p></li><li><p>volatile可以使得long和double的赋值是原子的。</p></li><li><p>volatile可以在单例双重检查中实现可见性和禁止指令重排序，从而保证安全性。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈红黑树</title>
      <link href="2020/11/05/%E6%B5%85%E8%B0%88%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>2020/11/05/%E6%B5%85%E8%B0%88%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>在网上很多博客上面看到有些讲红黑树的文章都不能完整描述它的体系，对于树的调平染色也没有很详细的介绍，因此让很多人觉得红黑树很难理解。但红黑树的应用场景还是很常见的。</p><p>JAVA8中HashMap的底层实现，就为了解决过度哈希冲突而造成的长链表，从而将链表转换为红黑树；Linux中的CFS进程调度算法，vruntime利用红黑树来存储；多路复用EPoll核心结构也是采用红黑树和双向链表来存储。</p><p>了解红黑树的结构，有助于我们去理解一些底层实现，并且红黑树本身也是对树结构的一种高度应用。包括多叉树、树平衡调整、树节点旋转。其实红黑树的本质就是对2-3-4树的概念模型一种具体实现。</p><h3 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h3><p>2-3-4树是<code>阶数</code>为4的B树，B树，全名BalanceTree，平衡树。这种结构主要用来做查找。它最重要的特性在于平衡，这使得我们能够在最坏情况下也保持O(LogN)的时间复杂度实现查找（一个不具备平衡性的查找树可能退化成单链表，时间复杂度会到O（N））。</p><blockquote><p>平衡的定义是说从空链接到根节点距离相等，此处一定要用心理解。（也就是说非叶子节点是不会存在空链接的）</p></blockquote><p>因为2-3-4是一个<code>阶数</code>为4的数，所以他会存在以下几个节点：</p><ul><li>2结点 2节点中存放着一个key[X]，两个指针，分别指向小于X的子节点和大于X的子节点；</li><li>3结点 3节点中存放在两个key[X,Y],三个指针，分别指向小于X的子节点，介于X~Y之间的子节点和大于Y的子节点；</li><li>4结点 4节点中存放在两个key[X,Y,Z],四个指针，理论同上</li></ul><p><img src="49.png" alt="2-3-4数图解"></p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是对概念模型2-3-4树的一种实现，由于直接进行不同节点间的转化会造成较大的开销，所以选择以二叉树为基础，在二叉树的属性中加入一个<code>颜色</code>属性来表示2-3-4树中不同的节点。<br>2-3-4树中的2节点对应着红黑树中的<code>黑色节点</code>，而2-3-4树中的非2节点是以<code>红节点+黑节点</code>的方式存在，红节点的意义是与黑色父节点结合，表达着2-3-4树中的3，4节点。</p><p>我们先看2-3-4树到红黑树的节点转换。2节点直接转化为黑色节点；3节点这里可以有两种表现形式，左倾红节点或者右倾红节点。而4节点被强制要求转化为一个黑父带着左右两个红色儿子。</p><p><img src="50.png" alt="2-3-4树转红黑树"></p><p>本文主要针对2-3树的左倾红黑树进行探讨，也就是说，如果一个树中出现了<code>红色</code>结点，那么这个结点一定是<code>左儿子</code>，这也是<code>算法4</code>中给出的红黑树的实现方式。</p><ul><li>这种实现方式不用考虑2-3-4树中复杂的4节点分裂</li><li>这种限定能够很大的减少红黑树调整过程中的复杂性</li></ul><p><img src="51.png" alt="2-3树转红黑树"></p><p>如果说这样还是比较抽象的话，那下面这个左倾红黑树转2-3树应该能够清晰的描绘他们之间的关系了。</p><p><img src="52.png" alt="左倾红黑树转2-3树"></p><p>在了解红黑树的插入删除操作之前，我们需要先了解2-3树的插入删除操作，才能理解红黑树中染色和旋转背后的意义。插入操作需要遵循一个原则：</p><blockquote><p>先将这个元素尝试性地放在已经存在的节点中，如果要存放的节点是2节点，那么插入后会变成3节点，如果要存放的节点是3节点，那么插入后会变成4节点（临时）。<br>然后对可能生成的临时4节点进行分裂处理，使得临时4节点消失。</p></blockquote><p><img src="53.jpg" alt="2-3-4树插入(1)"><br><img src="54.jpg" alt="2-3-4树插入(2)"></p><p>正对应了红黑树在插入的时候一定会把待插入节点涂成红色，因为红色节点的意义是与<code>父节点</code>进行关联，形成概念模型2-3树中的3节点或者临时4节点。</p><p>而红黑树之所以需要在插入后进行调整，正是因为可能存在着概念模型中的临时4节点（反应在红黑树中是双红的情况）。</p><p>试想在2-3树中如果待插入节点是个2节点，那么反应在红黑树中，不正好对应着黑色父节点吗，在黑色父节点下面增加一个红色儿子，确实不会违背红黑树的任何规则，这也对应着我们向2-3树中的2节点插入一个元素，只需要简单的把2节点变成3节点。</p><p>接下来让我们来看一下对于2-3树的删除。对于2-3树的删除我们主要要考虑待删除元素在2节点这种情况，因为如果待删除元素在3节点，那么可以直接将这个元素删除，而不会破坏2-3树的任何性质（删除这个元素不会引起高度的变化）。</p><p>当待删除元素在2节点的时候，由于删除这个元素会导致2节点失去自己唯一的元素，引发2节点自身的删除，会使得树中某条路径的高度发生变化，树变得不平衡。<br>因此我们有两种方案去解决这个问题：</p><ul><li>先删除这个2节点，然后对树进行平衡调整。</li><li>想办法让这个被删除的元素不可能出现在2节点中。</li></ul><p>这里选择第二种方案，我们在搜索到这个节点的路径中，不断地判断当前节点是否为2节点，如果是，就从它的兄弟节点或者它的父节点借一个元素，使得当前节点由2节点成为一个3节点或者一个临时4节点（视具体情况而定，在后面的红黑树部分会详细介绍）。</p><p>这种操作会产生一种结果：除非当前节点是根节点，否则当前节点的父节点一定是一个非2节点（因为搜索的路径是自上而下，父节点已经进行过了这种操作，所以不可能是2节点），那么我们可以保证到达叶子节点的时候，也能顺利的从父节点或者兄弟节点处借到元素，使得自己成为非2节点。从而能够直接删除某个元素（现在这个元素不在2节点中了）。</p><p><img src="55.jpg" alt="2-3树的删除"></p><h3 id="再品红黑树"><a href="#再品红黑树" class="headerlink" title="再品红黑树"></a>再品红黑树</h3><p><img src="56.png" alt="红黑树中的红黑结点"></p><p>来品一下红黑树的5条定义</p><ul><li><p>红黑树结点颜色的有黑色和红色</p><blockquote><p>2-3树到红黑树的转化已经详细说明</p></blockquote></li><li><p>根结点一定是黑色</p><blockquote><p>2-3树中如果根节点为2节点，那么它本来就对应红黑树中黑节点；如果根节点为3节点，也可以用黑色节点表示较大的那个元素，然后较小的元素作为左倾红节点存在于红黑树中</p></blockquote></li><li><p>所有叶子节点都是黑色</p><blockquote><p>这里的叶子其实是空链接</p></blockquote></li><li><p>任意节点到叶子节点经过的黑色节点数目相同</p><blockquote><p>红黑树中的红节点是和黑色父节点绑定的，在2-3树中本来就是同一层的，只有黑色节点才会在2-3树中真正贡献高度，由于2-3树的任一节点到空链接距离相同，因此反应在红黑树中就是<code>黑色完美平衡</code></p></blockquote></li><li><p>不会有连续的红色节点</p><blockquote><p>2-3树中本来就规定没有4节点，2-3-4树中虽然有4节点，但是要求在红黑树中体现为一黑色节点带两红色儿子，分布左右，所以也不会有连续红节点</p></blockquote></li></ul><hr><blockquote><p>现在就能看的出来红黑树的定义背后正浮现着一颗2-3树概念模型。虽然我们已经有了这样的认识，但是红黑树作为真正的实现模型，我们还是要回到这个实现本身来探究它的一系列操作</p></blockquote><h4 id="作为二叉查找树"><a href="#作为二叉查找树" class="headerlink" title="作为二叉查找树"></a>作为二叉查找树</h4><p>二叉查找树的节点有一个元素X和两个指针域，左指针指向小于X的元素，右指针指向大于X的元素。</p><p>假设我们的插入序列是1~10，那么这颗树会演变成只有右链接的形式，树高会增加到10层，这个时候已经不具备O(LogN)的查找时间复杂度，因为这颗树退化成了链表。</p><p>因此对二叉树进行平衡调整是很重要的一个环节，无论是AVL还是红黑树，它们本质上都是希望尽可能保证这颗二叉查找树中的元素尽量均衡的分布在树的两侧。</p><p>当我们向一颗二叉查找树中插入一个元素Y的时候，我们会一直与树中的节点进行大小比较，如果Y小于当前元素，就往左走，如果Y大于当前元素，就往右走，直到达到叶子节点，这个时候我们可以把Y插入这颗二叉查找树了。</p><p>由于这次的插入动作，整棵树可能会发生一些不平衡，因此我们需要在插入后进行一次平衡调整，使得整棵树恢复到平衡的状态（具体如何调整，要看树是AVL还是红黑树亦或是其他的平衡树）。</p><p>二叉查找树的删除是一个很有意思的问题，不同于插入的是，待删除的元素并不能保证一定出现在树中的叶子节点。这将带来一个棘手的情景，即我们需要从树的中间部分取走一个元素，而且在取走后还需要经过调整来使得整颗树满足平衡的性质。从树的中间部分直接取走一个节点的场景实在是太多，也牵扯到了太多相关的节点，这种操作很难实现。</p><p>好在有人提出了一个观点，我们对查找树中一个节点的删除，其实可以不必真的改动这个节点的位置。由于查找树的特殊性质，将某个元素节点删除后，它有两个最佳替代者，分别是有序序列中的前驱元素和后继元素。</p><p>我们还是以一个包含元素1~10的二叉查找树为例，如果我们希望删除5所在的节点，那么让4或者6替代它的位置都是可行的。作为前驱元素的4，会存放在5所在节点的左子树的最右侧；作为后继元素的6，会存放在5所在节点的右子树的最左侧。</p><p>关于这个结论，大家只需稍加思索便可以明白。</p><p>现在我们又让问题简化了，也就是说，删除某个节点的时候，我们先找到它的前驱元素或者后继元素（随便选一个），将它的前驱元素直接填到待删除的节点，然后再把它的前驱元素或者后继元素删除。</p><p>这个时候问题就转化成了在二叉查找树中删除一个没有左子树的节点（或者是一个没有右子树的节点），我们只需要将这个节点删除再进行对应的平衡调整即可（虽然还是需要调平，但是比直接在树中层删除一个同时具备左右儿子的节点要容易很多）。</p><p>注意，此处并没有强调是针对红黑树的操作，因为红黑树和AVL都是二叉查找树，它们都适用这个方法。</p><h4 id="树的旋转"><a href="#树的旋转" class="headerlink" title="树的旋转"></a>树的旋转</h4><p>为了调平一颗二叉树，使得其左右节点数目分布均匀，通常会选择旋转的手段。你可以把一颗二叉树某节点的左右子树想象成天平上待称量的物品，如果哪边重了，我们就从重的那边拿出一部分，加到轻的那边，以此保持相对的平均。</p><p>以X为旋转点的左旋</p><p><img src="58.png" alt="左旋调平"></p><p>以X为旋转点的右旋</p><p><img src="59.png" alt="右旋调平"></p><p>理解了这些之后，再去看红黑树的插入删除，就能够理解旋转和染色背后的意义了。我们仍然选择算法4中的左倾红黑树作演示：首先看<code>插入</code></p><h4 id="左倾红黑树的插入"><a href="#左倾红黑树的插入" class="headerlink" title="左倾红黑树的插入"></a>左倾红黑树的插入</h4><p><img src="60.png" alt="红黑树基树"></p><p>对于上述左倾红黑树的插入一共有三种可能的情况：</p><ul><li>待插入元素比黑父大，插在了黑父的右边，而黑父左边是红色儿子。这种情况会导致在红黑树中出现右倾红节点。</li></ul><p>这种情况对应着2-3树中出现了临时4节点，我们在2-3树中的处理是将这个临时4节点分裂，左右元素各自形成一个2节点，中间元素上升到上层跟父节点结合。所以，我们在红黑树中的动作是，将原本红色的左右儿子染黑（左右分裂），将黑父染红（等待上升结合）。</p><p><img src="61.png" alt="红黑树基于黑叔插入图1"></p><ul><li>待插入元素比红父小，且红父自身就是左倾。听起来有点绕，看图就会明白，其实就是说红父和待插入元素同时靠在了左边，形成了连续的红节点。</li></ul><p>这种情况我们需要用两步来调整。由于我们插入的是红色节点，其实不会破坏黑色完美平衡，所以要注意的是在旋转和染色的过程种继续保持这种完美黑色平衡。<br>首先对红父的父亲进行一次右旋，这次右旋不会破坏黑色平衡，但是也没有解决连续红色的问题。<br>接下来将12所在节点与15所在节点交换颜色，这样的目的是为了消除连续红色，并且这个操作依旧维持了黑色平衡。现在我们已经得到了情况1的场景，直接按情况1处理即可。</p><p><img src="62.png" alt="红黑树基于黑叔插入图2"></p><ul><li>待插入元素比红父大，且红父自身就是左倾。</li></ul><p>也就是说插入的这个节点形成了一个右倾的红色节点，对右倾的处理很简单，将红父进行一次左旋，就能使得右倾红节点变为左倾，现在出现了连续的左倾红节点，直接按情况2处理即可。</p><p><img src="63.png" alt="红黑树基于黑叔插入图3"></p><p>在插入时，可以体会到左倾红黑树对于左倾的限制带来的好处，因为在原树符合红黑树定义的情况下，如果父亲是红的，那么它一定左倾，同时也不用考虑可能存在的右倾兄弟（如果有，那说明原树不满足红黑树定义）。</p><p>这种限制消除了很多需要考虑的场景，让插入变得更加简单。</p><h4 id="左倾红黑树的删除"><a href="#左倾红黑树的删除" class="headerlink" title="左倾红黑树的删除"></a>左倾红黑树的删除</h4><p>左倾红黑树的删除需要借鉴之前提到的<code>二叉查找树通用的删除</code>策略，当我们要删除某个节点的时候选择它的前驱节点或者后继节点元素来替代它，转而删除它的前驱/后继节点。</p><p>这里我们用<code>后继节点</code>来替代被删除节点。</p><p>假设我们需要删除的节点它的右子树如图所示，那么对该节点的删除实际上转为了对2的删除。</p><p>我们从当前的根节点出发，利于2-3树中预合并的策略逐层对红黑树进行调整。具体的做法是，每次都保证当前的节点是2-3树中的非2节点，如果当前节点已经是非2节点，那么直接跳过；如果当前节点是2节点，那么根据兄弟节点的状况来进行调整：</p><ul><li><p>如果兄弟是2节点，那么从父节点借一个元素给当前节点，然后与兄弟节点一起形成一个临时4节点。</p></li><li><p>如果兄弟是非2节点，那么兄弟上升一个元素到父节点，同时父节点下降一个元素到当前节点，使得当前节点成为一个3节点。</p></li></ul><p>这样的策略能够保证最后走到待删除节点的时候，它一定是一个非2节点，我们可以直接将其元素删除。</p><p><img src="64.png" alt="左倾红黑树的删除"></p><p>接下来要考虑的是修复工作，由于红黑树定义的限制，我们在调整的过程中出现了一些本不该存在的<code>红色右倾节点</code>（因为生成了概念模型中的临时4节点），于是我们顺着搜索的方向向上<code>回溯</code>，如果遇到当前节点具备右倾的红色儿子，那么对当前节点进行一次左旋，这时原本的右儿子会来到当前节点的位置，然后将右儿子与当前节点交换颜色，我们就将右倾红节点修复成了左倾红节点，同时我们并没有破坏黑色节点的平衡。</p><p><img src="65.png" alt="左倾红黑树修复"></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul><li>你知道了红黑树的五条定义，如果我构造一颗只有黑色节点的红黑树，这样子可行吗？因为这样子没有破坏任何一条红黑树的规则。</li><li>那么请问红黑树中要红节点干什么呢？红节点的真实意义是什么呢？</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红黑树 </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一下最近刷题的一些小想法</title>
      <link href="2020/10/30/%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%AF%E6%80%A7%E6%80%9D%E7%BB%B4/"/>
      <url>2020/10/30/%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%AF%E6%80%A7%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<p>事情的起因还是要从我昨天上班赚（mo）钱（yu）开始说起，最近项目比较闲，于是我在intelij上面装了一个leetcode插件，每天日常刷一刷leetcode题。就在昨天，我刷到了这样一题</p><hr><p>给定一个较长字符串<code>big</code>和一个包含较短字符串的数组<code>smalls</code>，设计一个方法，根据<code>smalls</code>中的每一个较短字符串，对<code>big</code>进行搜索。输出<code>smalls</code>中的字符串在<code>big</code>里出现的所有位置<code>positions</code>，其中<code>positions[i]</code>为<code>smalls[i]</code>出现的所有位置。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">big &#x3D; &quot;mississippi&quot;</span><br><span class="line">smalls &#x3D; [&quot;is&quot;,&quot;ppi&quot;,&quot;hi&quot;,&quot;sis&quot;,&quot;i&quot;,&quot;ssippi&quot;]</span><br><span class="line">输出： [[1,4],[8],[],[3],[1,4,7,10],[5]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= len(big) &lt;= 1000</code></li><li><code>0 &lt;= len(smalls[i]) &lt;= 1000</code></li><li><code>smalls</code>的总字符数不会超过 100000。</li><li>你可以认为<code>smalls</code>中没有重复字符串。</li><li>所有出现的字符均为英文小写字母。</li></ul><p><strong>解法：</strong></p><p>看到判断字符串在母串的位置，很容易让人想到indexOf(str)，我们可以记录indexOf(str)返回值，但<code>smalls</code>中特定位的字符在<code>big</code>出现的次数是未知数x，所以可以用一个可变数组List来存储这个字符在<code>big</code>中出现的次数。而indexOf(str)默认返回的是str在母串中第一次的索引值，String还提供了indexOf(str,index)来记录从第一个开始的索引值，因此可以采用indexOf(str,index+1)来避免记录重复值。<br>所以解法就很简单，先用indexOf获取索引值，然后存储在一个长度可变的数组List中，接着讲List再转成固定长度数组，返回给result[i]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] multiSearch(String big, String[] smalls) &#123;</span><br><span class="line">        <span class="keyword">int</span> [][] result = <span class="keyword">new</span> <span class="keyword">int</span> [smalls.length][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; smalls.length ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">""</span>.equals(big))&#123;</span><br><span class="line">                result[i] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!smalls[i].equals(<span class="string">""</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> index = big.indexOf(smalls[i]);</span><br><span class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span> (index&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    list.add(index);</span><br><span class="line">                    index = big.indexOf(smalls[i],index+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                result[i] = parseList2Array(list);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                result[i] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parseList2Array(List&lt;Integer&gt; list)&#123;</span><br><span class="line">        <span class="keyword">int</span> [] index = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size() ; i++) &#123;</span><br><span class="line">            index[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题很简答，但是我越刷(mo yu)越开心，又刷到了这样一题。</p><hr><p> 给定字符串<code>J</code> 代表石头中宝石的类型，和字符串 <code>S</code>代表你拥有的石头。 <code>S</code> 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p><p><code>J</code> 中的字母不重复，<code>J</code> 和 <code>S</code>中的所有字符都是字母。字母区分大小写，因此<code>&quot;a&quot;</code>和<code>&quot;A&quot;</code>是不同类型的石头。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J &#x3D; &quot;aA&quot;, S &#x3D; &quot;aAAbbbb&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J &#x3D; &quot;z&quot;, S &#x3D; &quot;ZZ&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>S</code> 和 <code>J</code> 最多含有50个字母。</li><li><code>J</code> 中的字符不重复。</li></ul><p>我直接一波惯性思维，想到了indexOf真香(主要简单)，把<code>J</code>拆成char[],那每个char[i],不就相当于上一题里面的small[i]吗，这样一想，其实还是在母串里找每个字符出现的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] charArray = J.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> item: charArray) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = S.indexOf(item);</span><br><span class="line">        <span class="keyword">while</span> (index&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            result++;</span><br><span class="line">            index = S.indexOf(item,index+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答出来之后，我就开始思考有没有其他方法可以更简单或者更快的解决这个题目。还是从刚刚这个思路切入，把<code>J</code>切成char[]，因为<code>S</code>中的char[i]可能是多个，所以还需要像上一题这样多次搜索，但是<code>J</code>中的元素是不会重复的，如果把<code>S</code>拆成char[]，那么对应可以直接在<code>J</code>中进行一次搜索，而且因为不需要取索引值，所以可以直接用J.contains(char[i])，看返回的布尔值，实现计数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] charArray = S.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> item: charArray) &#123;</span><br><span class="line">        <span class="keyword">if</span>(J.contains(item+<span class="string">""</span>))&#123;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步思考，既然<code>J</code>的每个元素都不相同，那么我们可以采用元素都不重复的集合Set来存储J的每一个元素。不过这样需要对两个字符串都转数组，虽然简单但是感觉不如上述代码简洁。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] chars = J.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> item: chars) &#123;</span><br><span class="line">        set.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(S.charAt(i)))</span><br><span class="line">            result++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完这些，是不是突然发现，既然是用<code>J</code>中的每一个字符去挨个遍历<code>S</code>中的每一个字符。那么最粗暴的方法当然是双重for循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> Jitem : J.toCharArray())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> Sitem : S.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(Jitem == Sitem)&#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法虽然简单，但是这样效率极低极低，这样的写法相当于是把整个<code>J</code>和整个<code>S</code>都遍历了一遍，相当于执行了<code>J.length*S.length</code>次。因为这里<code>J</code>的每一个字符都是唯一不重复的。那么我们可以用<code>S</code>去匹配<code>J</code>,找到自己break当前小循环直接进入下一次大循环，就会少一些遍历<code>J</code>中剩下的字符次数，相对而言就会少执行很多次循环体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> Sitem : S.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> Jitem : J.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span>(Jitem == Sitem)&#123;</span><br><span class="line">                    result++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>快乐的上班(mo yu)时光总是很短暂，下班啦~~~~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收与内存分配</title>
      <link href="2020/09/27/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>2020/09/27/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，外面的人想进来，里面的人想出去。</p><blockquote id="fn_引用"><sup>引用</sup>. 《深入理解JAVA虚拟机》<a href="#reffn_引用" title="Jump back to footnote [引用] in the text."> &#8617;</a></blockquote><p>JAVA相对于C/C++而言引入了GC机制，使程序员更加去关注程序本身，不需要再对每个new的对象去进行delete/free操作。C++就好像你在家里自己恰饭，需要去自己做好。吃完之后还要自己收拾。而JAVA更像是在餐厅中吃饭，你不需要去关注饭是如何做好的，以及吃完以后服务员是如何收拾的，你只要负责享用美食就可以了。</p><hr><h2 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h2><p>了解GC之前，我们需要先了解JVM的内存模型，搞清楚被回收的数据一般存在在哪些区域。</p><p><img src="jvmncqy.png" alt="JVM内存区域"></p><ul><li>虚拟机栈：描述方法执行时的内存模型，属于线程私有，生命周期同线程一样。主要保存执行方法时的局部变量表、操作数栈、动态连接和方法返回地址等信息,方法执行时入栈，方法执行完出栈，出栈之后数据清空，不需要GC。</li><li>本地方法栈：主要存储虚拟机调用native方法/服务相关信息。大体逻辑和虚拟机栈相同，也不需要GC。</li><li>程序技术器：主要记录当前线程执行字节码的行号。是<code>唯一一个</code>在 Java 虚拟机规范中没有规定任何 OOM 情况的区域，所以也不需要GC。</li><li>本地内存：线程共享区域。在JAVA8之前，方法区是在堆内的实现的。受GC管理，JAVA8把方法区的实现移到了本地内存中的元空间。这样方法区就不受JVM控制，也不会进行GC，也提升了性能，因为发生 GC 会发生 Stop The Word,造成性能受到一定影响，也方便在元空间中统一管理。</li><li>堆：堆是GC 发生的主要区域，对象实例和数组都是在堆上分配的，GC 也主要对这两类数据进行回收。接下来我们也终点分析这块区域。</li></ul><h2 id="如何判断垃圾"><a href="#如何判断垃圾" class="headerlink" title="如何判断垃圾"></a>如何判断垃圾</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>简单来说就是对每个对象去添加一个引用计数器，每当有一个地方引用他，计数器就加一，当引用失效就减一。如果没有被引用（引用次数为 0），则此对象可回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String ref = <span class="keyword">new</span> String(<span class="string">"Java"</span>);</span><br></pre></td></tr></table></figure><p><img src="630.png" alt="引用计数"></p><p>ref 引用了右侧定义的对象，所以引用次数是 1 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref &#x3D; null;</span><br></pre></td></tr></table></figure><p>对象没被引用，引用次数置为 0，由于不被任何变量引用，此时即被回收</p><p><img src="640.gif" alt="引用计数"></p><p>但单纯的引用计数无法解决对象之间的相互循环引用的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRCGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TestRCGC instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestRCGC</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步</span></span><br><span class="line">    A a = <span class="keyword">new</span> TestRCGC(<span class="string">"a"</span>);</span><br><span class="line">    B b = <span class="keyword">new</span> TestRCGC(<span class="string">"b"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步</span></span><br><span class="line">    a.instance = b;</span><br><span class="line">    b.instance = a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步</span></span><br><span class="line">    a = <span class="keyword">null</span>;</span><br><span class="line">    b = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="650.png" alt="循环引用"></p><p>虽然最后 a，b 都被置为 null 了，但是由于之前它们指向的对象互相指向了对方（引用计数都为 1），所以无法回收，也正是由于无法解决循环引用的问题，所以现代JAVA虚拟机都不用引用计数法来判断对象是否应该被回收。</p><h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p>当前主流的内存管理系统基本都是采用的可达性分析算法来判定对象是否存活。它的原理是通过一系列“GC Roots”的根对象作为起始节点集。从这个节点开始，通过引用向下搜索，搜索过程走的路被称为“引用链”，如果对象到“GC Roots”之间没有引用链相连的话，则说明这个对象是不可达的，也就是死亡的。</p><p><img src="660.png" alt="可达性分析"></p><p>如图所示：对象a和对象b之间，虽然存在循环引用，但是a，b之间不存在与GC Root想关联的引用，因此a,b是可回收的。<br>但是此时a,b并没有真正的死亡，而是处于一个“缓刑”的阶段。一个对象真正死亡需要同时满足两个条件，一个是对象与GC Roots没有相连接的引用链。另一个是对象是否有必要执行finallize()方法。如果对象未执行，则会先执行finallize()方法。如果执行该方法后对象仍不可达，则回收该对象，反之不回收该对象。<br>但是finallize只会被执行<code>一次</code>，如果在第一次执行了finallize之后对象仍然是可达的。那么下一次对象再被GC的时候会忽略finallize方法，会被回收。</p><p>那么这些 GC Roots 到底是什么东西呢，哪些对象可以作为 GC Root 呢，有以下几类</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li></ul><h4 id="虚拟机栈中引用的对象"><a href="#虚拟机栈中引用的对象" class="headerlink" title="虚拟机栈中引用的对象"></a>虚拟机栈中引用的对象</h4><p>a 是栈帧中的本地变量，当 a = null 时，由于此时 a 充当了 <strong>GC Root</strong> 的作用，a 与原来指向的实例 <strong>new Test()</strong> 断开了连接，所以对象会被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Test a = <span class="keyword">new</span> Test();</span><br><span class="line">    a = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法区中类静态属性引用对象"><a href="#方法区中类静态属性引用对象" class="headerlink" title="方法区中类静态属性引用对象"></a>方法区中类静态属性引用对象</h4><p>当栈帧中的本地变量 a = null 时，由于 a 原来指向的对象与 GC Root (变量 a) 断开了连接，所以 a 原来指向的对象会被回收，而由于我们给 s 赋值了变量的引用，s 在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Test s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Test a = <span class="keyword">new</span> Test();</span><br><span class="line">    a.s = <span class="keyword">new</span> Test();</span><br><span class="line">    a = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法区中常量引用对象"><a href="#方法区中常量引用对象" class="headerlink" title="方法区中常量引用对象"></a>方法区中常量引用对象</h4><p>常量 s 指向的对象并不会因为 a 指向的对象被回收而回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Test s = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test a = <span class="keyword">new</span> Test();</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="本地方法栈中-JNI-引用的对象"><a href="#本地方法栈中-JNI-引用的对象" class="headerlink" title="本地方法栈中 JNI 引用的对象"></a>本地方法栈中 JNI 引用的对象</h4><p>本地方法就是一个 java 调用非 java 代码的接口，该方法并非 Java 实现的，可能由 C 或 Python等其他语言实现的， Java 通过 JNI 来调用本地方法， 而本地方法是以库文件的形式存放的（在 WINDOWS 平台上是 DLL 文件形式，在 UNIX 机器上是 SO 文件形式）。通过调用本地的库文件的内部方法，使 JAVA 可以实现和本地机器的紧密联系，调用系统级的各接口方法。</p><p>当调用 Java 方法时，虚拟机会创建一个栈桢并压入 Java 栈，而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不会在 Java 栈祯中压入新的祯，虚拟机只是简单地动态连接并直接调用指定的本地方法。</p><p><img src="670.png" alt="栈帧"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_pecuyu_jnirefdemo_MainActivity_newStringNative</span><span class="params">(JNIEnv *env, jobject instance，jstring jmsg)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">   <span class="comment">// 缓存String的class</span></span><br><span class="line">   jclass jc = (*env)-&gt;FindClass(env, STRING_PATH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 java 调用以上本地方法时，jc 会被本地方法栈压入栈中, jc 就是我们说的本地方法栈中 JNI 的对象引用，因此只会在此本地方法执行完成后才会被释放。</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>先根据可达性算法<strong>标记</strong>出相应的可回收对象，对可回收的对象进行回收。</p><p><img src="680.png" alt="标记清除"></p><p>这种方式很简单，但是会有一个特别明显的问题，当大量的小对象死亡时，标记清除出来的碎片化空间就特别多。那么我们如何能获得一个连续内存空间呢？</p><h3 id="标记整理法"><a href="#标记整理法" class="headerlink" title="标记整理法"></a>标记整理法</h3><p>两步和标记清除法一样，不同的是它在标记清除法的基础上添加了一个整理的过程 ，即将所有的存活对象都往一端移动,紧邻排列，这样就可以解决碎片化空间的问题。</p><p><img src="690.png" alt="标记整理"></p><p>这种算法的缺点是每进一次垃圾清除都要频繁地移动存活的对象，效率十分低下。</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>把堆等分成两块区域, A 和 B，区域 A 负责分配对象，区域 B 不分配, 对区域 A 使用以上所说的标记法把存活的对象标记出来（下图有误无需清除），然后把区域 A 中存活的对象都复制到区域 B（存活对象都依次<strong>紧邻排列</strong>）最后把 A 区对象全部清理掉释放出空间。</p><p><img src="700.png" alt="标记整理"></p><p>复制算法的缺点是比如给堆分配分配的内存只有一半是可用的，另外每次回收也要把存活对象移动到另一半，效率低下。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>分代收集算法整合了以上算法，综合了这些算法的优点，最大程度避免了它们的缺点，所以是现代虚拟机采用的首选算法,与其说它是算法，倒不是说它是一种策略，因为它是把上述几种算法整合在了一起，为啥需要分代收集呢，来看一下对象的分配有啥规律</p><p><img src="710.png" alt="对象存活时间"></p><p><em>如图示：纵轴代表已分配的字节，而横轴代表程序运行时间</em></p><p>由图可知，大部分的对象都很短命，都在很短的时间内都被回收了（IBM 专业研究表明，一般来说，98% 的对象都是朝生夕死的，经过一次 Minor GC 后就会被回收），所以分代收集算法根据<strong>对象存活周期的不同</strong>将堆分成新生代和老生代（Java8以前还有个永久代）,默认比例为 1 : 2，新生代又分为 Eden 区， from Survivor 区（简称S0），to Survivor 区(简称 S1),三者的比例为 8: 1 : 1，这样就可以根据新老生代的特点选择最合适的垃圾回收算法，我们把新生代发生的 GC 称为 Young GC（也叫 Minor GC）,老年代发生的 GC 称为 Old GC（也称为 Full GC）。</p><p><img src="720.png" alt="新生代老年代"></p><h4 id="分代收集工作原理"><a href="#分代收集工作原理" class="headerlink" title="分代收集工作原理"></a>分代收集工作原理</h4><p><strong>1、对象在新生代的分配与回收</strong></p><p>由以上的分析可知，大部分对象在很短的时间内都会被回收，对象一般分配在 Eden 区</p><p><img src="730.png" alt="img"></p><p>当 Eden 区将满时，触发 Minor GC<img src="740.png" alt="img"></p><p>我们之前怎么说来着，大部分对象在短时间内都会被回收, 所以经过 Minor GC 后只有少部分对象会存活，它们会被移到 S0 区（这就是为啥空间大小  Eden: S0: S1 = 8:1:1, Eden 区远大于 S0,S1 的原因，因为在 Eden 区触发的 Minor GC 把大部对象（接近98%）都回收了,只留下少量存活的对象，此时把它们移到 S0 或 S1 绰绰有余）同时对象年龄加一（对象的年龄即发生 Minor GC 的次数），最后把 Eden 区对象全部清理以释放出空间,动图如下</p><p><img src="750.gif" alt="img"></p><p>当触发下一次 Minor GC 时，会把 Eden 区的存活对象和 S0（或S1） 中的存活对象（S0 或 S1 中的存活对象经过每次 Minor GC 都可能被回收）一起移到 S1（Eden 和 S0 的存活对象年龄+1）, 同时清空 Eden 和 S0 的空间。<img src="760.gif" alt="img"></p><p>若再触发下一次 Minor GC，则重复上一步，只不过此时变成了 从 Eden，S1 区将存活对象复制到 S0 区,每次垃圾回收, S0, S1 角色互换，都是从 Eden ,S0(或S1) 将存活对象移动到 S1(或S0)。也就是说在 Eden 区的垃圾回收我们采用的是<strong>复制算法</strong>，因为在 Eden 区分配的对象大部分在 Minor GC 后都消亡了，只剩下极少部分存活对象（这也是为啥 Eden:S0:S1 默认为 8:1:1 的原因），S0,S1 区域也比较小，所以最大限度地降低了复制算法造成的对象频繁拷贝带来的开销。</p><p><strong>2、对象何时晋升老年代</strong></p><ul><li>当对象的年龄达到了我们设定的阈值，则会从S0（或S1）晋升到老年代<img src="770.gif" alt="img">如图示：年龄阈值设置为 15， 当发生下一次 Minor GC 时，S0 中有个对象年龄达到 15，达到我们的设定阈值，晋升到老年代！</li><li>大对象 当某个对象分配需要大量的连续内存时，此时对象的创建不会分配在 Eden 区，会直接分配在老年代，因为如果把大对象分配在 Eden 区, Minor GC 后再移动到 S0,S1 会有很大的开销（对象比较大，复制会比较慢，也占空间），也很快会占满 S0,S1 区，所以干脆就直接移到老年代.</li><li>还有一种情况也会让对象晋升到老年代，即在 S0（或S1） 区相同年龄的对象大小之和大于 S0（或S1）空间一半以上时，则年龄大于等于该年龄的对象也会晋升到老年代。</li></ul><p><strong>3、空间分配担保</strong></p><p>在发生 MinorGC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，那么Minor GC 可以确保是安全的,如果不大于，那么虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行 Minor GC，否则可能进行一次 Full GC。</p><p><strong>4、Stop The World</strong></p><p>如果老年代满了，会触发 Full GC, Full GC 会同时回收新生代和老年代（即对整个堆进行GC），它会导致 Stop The World（简称 STW）,造成挺大的性能开销。</p><p>什么是 STW ？所谓的 STW, 即在 GC（minor GC 或 Full GC）期间，只有垃圾回收器线程在工作，其他工作线程则被挂起。</p><p><img src="780.png" alt="img"></p><p><em>画外音：为啥在垃圾收集期间其他工作线程会被挂起？想象一下，你一边在收垃圾，另外一群人一边丢垃圾，垃圾能收拾干净吗。</em></p><p>一般 Full GC 会导致工作线程停顿时间过长（因为Full GC 会清理<strong>整个堆</strong>中的不可用对象，一般要花较长的时间），如果在此 server 收到了很多请求，则会被拒绝服务！所以我们要尽量减少 Full GC（Minor GC 也会造成 STW,但只会触发轻微的 STW,因为 Eden 区的对象大部分都被回收了，只有极少数存活对象会通过复制算法转移到 S0 或 S1 区，所以相对还好）。</p><p>现在我们应该明白把新生代设置成 Eden, S0，S1区或者给对象设置年龄阈值或者默认把新生代与老年代的空间大小设置成 1:2 都是为了<strong>尽可能地避免对象过早地进入老年代，尽可能晚地触发 Full GC</strong>。想想新生代如果只设置 Eden 会发生什么，后果就是每经过一次 Minor GC，存活对象会过早地进入老年代，那么老年代很快就会装满，很快会触发 Full GC，而对象其实在经过两三次的 Minor GC 后大部分都会消亡，所以有了 S0,S1的缓冲，只有少数的对象会进入老年代，老年代大小也就不会这么快地增长，也就避免了过早地触发 Full GC。</p><p>由于 Full GC（或Minor GC） 会影响性能，所以我们要在一个合适的时间点发起 GC，这个时间点被称为 Safe Point，这个时间点的选定既不能太少以让 GC 时间太长导致程序过长时间卡顿，也不能过于频繁以至于过分增大运行时的负荷。一般当线程在这个时间点上状态是可以确定的，如确定 GC Root 的信息等，可以使 JVM 开始安全地 GC。Safe Point 主要指的是以下特定位置：</p><ul><li>循环的末尾</li><li>方法返回前</li><li>调用方法的 call 之后</li><li>抛出异常的位置 另外需要注意的是由于新生代的特点（大部分对象经过 Minor GC后会消亡）， Minor GC 用的是复制算法，而在老生代由于对象比较多，占用的空间较大，使用复制算法会有较大开销（复制算法在对象存活率较高时要进行多次复制操作，同时浪费一半空间）所以根据老生代特点，在老年代进行的 GC 一般采用的是标记整理法来进行回收。</li></ul><h2 id="垃圾收集器种类"><a href="#垃圾收集器种类" class="headerlink" title="垃圾收集器种类"></a>垃圾收集器种类</h2><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java 虚拟机规范并没有规定垃圾收集器应该如何实现，因此一般来说不同厂商，不同版本的虚拟机提供的垃圾收集器实现可能会有差别，一般会给出参数来让用户根据应用的特点来组合各个年代使用的收集器，主要有以下垃圾收集器</p><p><img src="790.png" alt="img"></p><ul><li>在新生代工作的垃圾回收器：Serial, ParNew, ParallelScavenge</li><li>在老年代工作的垃圾回收器：CMS，Serial Old, Parallel Old</li><li>同时在新老生代工作的垃圾回收器：G1</li></ul><p>图片中的垃圾收集器如果存在连线，则代表它们之间可以配合使用，接下来我们来看看各个垃圾收集器的具体功能。</p><h3 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h3><h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><p>Serial 收集器是工作在新生代的，单线程的垃圾收集器，单线程意味着它只会使用一个 CPU 或一个收集线程来完成垃圾回收，不仅如此，还记得我们上文提到的 STW 了吗，它在进行垃圾收集时，其他用户线程会暂停，直到垃圾收集结束，也就是说在 GC 期间，此时的应用不可用。</p><p>看起来单线程垃圾收集器不太实用，不过我们需要知道的任何技术的使用都不能脱离场景，在 <strong>Client 模式</strong>下，它简单有效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 单线程模式无需与其他线程交互，减少了开销，专心做 GC 能将其单线程的优势发挥到极致，另外在用户的桌面应用场景，分配给虚拟机的内存一般不会很大，收集几十甚至一两百兆（仅是新生代的内存，桌面应用基本不会再大了），STW 时间可以控制在一百多毫秒内，只要不是频繁发生，这点停顿是可以接受的，所以对于运行在 Client 模式下的虚拟机，Serial 收集器是新生代的默认收集器</p><h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><p>ParNew 收集器是 Serial 收集器的多线程版本，除了使用多线程，其他像收集算法,STW,对象分配规则，回收策略与 Serial 收集器完成一样，在底层上，这两种收集器也共用了相当多的代码，它的垃圾收集过程如下<img src="800.png" alt="img"></p><p>ParNew 主要工作在 Server 模式，我们知道服务端如果接收的请求多了，响应时间就很重要了，多线程可以让垃圾回收得更快，也就是减少了 STW 时间，能提升响应时间，所以是许多运行在 Server 模式下的虚拟机的首选新生代收集器，另一个与性能无关的原因是因为除了 Serial  收集器，<strong>只有它能与 CMS 收集器配合工作</strong>，CMS 是一个划时代的垃圾收集器，是真正意义上的<strong>并发收集器</strong>，它第一次实现了垃圾收集线程与用户线程（基本上）同时工作，它采用的是传统的 GC 收集器代码框架，与 Serial,ParNew 共用一套代码框架，所以能与这两者一起配合工作，而后文提到的 Parallel Scavenge 与 G1 收集器没有使用传统的 GC 收集器代码框架，而是另起炉灶独立实现的，另外一些收集器则只是共用了部分的框架代码,所以无法与 CMS 收集器一起配合工作。</p><p>在多 CPU 的情况下，由于 ParNew 的多线程回收特性，毫无疑问垃圾收集会更快，也能有效地减少 STW 的时间，提升应用的响应速度。</p><h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>Parallel Scavenge 收集器也是一个使用<strong>复制算法</strong>，<strong>多线程</strong>，工作于新生代的垃圾收集器，看起来功能和 ParNew 收集器一样，它有啥特别之处吗</p><p><strong>关注点不同</strong>，CMS 等垃圾收集器关注的是尽可能缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 目标是达到一个可控制的吞吐量（吞吐量 = 运行用户代码时间 / （运行用户代码时间+垃圾收集时间）），也就是说 CMS 等垃圾收集器更适合用到与用户交互的程序，因为停顿时间越短，用户体验越好，而 Parallel Scavenge 收集器关注的是吞吐量，所以更适合做后台运算等不需要太多用户交互的任务。</p><p>Parallel Scavenge 收集器提供了两个参数来精确控制吞吐量，分别是控制最大垃圾收集时间的 -XX:MaxGCPauseMillis 参数及直接设置吞吐量大小的 -XX:GCTimeRatio（默认99%）</p><p>除了以上两个参数，还可以用 Parallel Scavenge 收集器提供的第三个参数 -XX:UseAdaptiveSizePolicy，开启这个参数后，就不需要手工指定新生代大小,Eden 与 Survivor 比例（SurvivorRatio）等细节，只需要设置好基本的堆大小（-Xmx 设置最大堆）,以及最大垃圾收集时间与吞吐量大小，虚拟机就会根据当前系统运行情况收集监控信息，动态调整这些参数以尽可能地达到我们设定的最大垃圾收集时间或吞吐量大小这两个指标。自适应策略也是 Parallel Scavenge  与 ParNew 的重要区别！</p><h3 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h3><h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p>上文我们知道， Serial 收集器是工作于新生代的单线程收集器，与之相对地，Serial Old 是工作于老年代的单线程收集器，此收集器的主要意义在于给 Client 模式下的虚拟机使用，如果在 Server 模式下，则它还有两大用途：一种是在 JDK 1.5 及之前的版本中与 Parallel Scavenge 配合使用，另一种是作为 CMS 收集器的后备预案,在并发收集发生 Concurrent Mode Failure 时使用（后文讲述）,它与 Serial 收集器配合使用示意图如下</p><p><img src="810.png" alt="img"></p><h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><p>Parallel Old 是相对于 Parallel Scavenge 收集器的老年代版本，使用多线程和标记整理法，两者组合示意图如下,这两者的组合由于都是多线程收集器，真正实现了「吞吐量优先」的目标</p><p><img src="820.png" alt="img"></p><h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><p>CMS 收集器是以实现最短 STW 时间为目标的收集器，如果应用很重视服务的响应速度，希望给用户最好的体验，则 CMS 收集器是个很不错的选择！</p><p>我们之前说老年代主要用标记整理法，而 CMS 虽然工作于老年代，但采用的是标记清除法，主要有以下四个步骤</p><ol><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ol><p><img src="830.png" alt="img"></p><p>从图中可以的看到初始标记和重新标记两个阶段会发生 STW，造成用户线程挂起，不过初始标记仅标记 GC Roots 能关联的对象，速度很快，并发标记是进行 GC Roots  Tracing 的过程，重新标记是为了修正并发标记期间因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录，这一阶段停顿时间一般比初始标记阶段稍长，但<strong>远比并发标记时间短</strong>。</p><p>整个过程中耗时最长的是并发标记和标记清理，不过这两个阶段用户线程都可工作，所以不影响应用的正常使用，所以总体上看，可以认为 CMS 收集器的内存回收过程是与用户线程一起并发执行的。</p><p>但是 CMS 收集器远达不到完美的程度，主要有以下三个缺点</p><ul><li>CMS 收集器对 CPU 资源非常敏感  原因也可以理解，比如本来我本来可以有 10 个用户线程处理请求，现在却要分出 3 个作为回收线程，吞吐量下降了30%，CMS 默认启动的回收线程数是 （CPU数量+3）/ 4, 如果 CPU 数量只有一两个，那吞吐量就直接下降 50%,显然是不可接受的</li><li>CMS 无法处理浮动垃圾（Floating Garbage）,可能出现 「Concurrent Mode Failure」而导致另一次 Full GC 的产生，由于在并发清理阶段用户线程还在运行，所以清理的同时新的垃圾也在不断出现，这部分垃圾只能在下一次 GC 时再清理掉（即浮云垃圾），同时在垃圾收集阶段用户线程也要继续运行，就需要预留足够多的空间要确保用户线程正常执行，这就意味着 CMS 收集器不能像其他收集器一样等老年代满了再使用，JDK 1.5 默认当老年代使用了68%空间后就会被激活，当然这个比例可以通过 -XX:CMSInitiatingOccupancyFraction 来设置，但是如果设置地太高很容易导致在 CMS 运行期间预留的内存无法满足程序要求，会导致 <strong>Concurrent Mode Failure</strong> 失败，这时会启用 Serial Old 收集器来重新进行老年代的收集，而我们知道 Serial Old 收集器是单线程收集器，这样就会导致 STW 更长了。</li><li>CMS 采用的是标记清除法，上文我们已经提到这种方法会产生大量的内存碎片，这样会给大内存分配带来很大的麻烦，如果无法找到足够大的连续空间来分配对象，将会触发 Full GC，这会影响应用的性能。当然我们可以开启 -XX:+UseCMSCompactAtFullCollection（默认是开启的），用于在 CMS 收集器顶不住要进行 FullGC 时开启内存碎片的合并整理过程，内存整理会导致 STW，停顿时间会变长，还可以用另一个参数 -XX:CMSFullGCsBeforeCompation 用来设置执行多少次不压缩的 Full GC 后跟着带来一次带压缩的。</li></ul><h4 id="G1（Garbage-First）-收集器"><a href="#G1（Garbage-First）-收集器" class="headerlink" title="G1（Garbage First） 收集器"></a>G1（Garbage First） 收集器</h4><p>G1 收集器是面向服务端的垃圾收集器，被称为驾驭一切的垃圾回收器，主要有以下几个特点</p><ul><li><p>像 CMS 收集器一样，能与应用程序线程并发执行。</p></li><li><p>整理空闲空间更快。</p></li><li><p>需要 GC 停顿时间更好预测。</p></li><li><p>不会像 CMS 那样牺牲大量的吞吐性能。</p></li><li><p>不需要更大的 Java Heap</p></li></ul><p>与 CMS 相比，它在以下两个方面表现更出色</p><ol><li>运作期间不会产生内存碎片，G1 从整体上看采用的是标记-整理法，局部（两个 Region）上看是基于复制算法实现的，两个算法都不会产生内存碎片，收集后提供规整的可用内存，这样有利于程序的长时间运行。</li><li>在 STW 上建立了<strong>可预测</strong>的停顿时间模型，用户可以指定期望停顿时间，G1 会将停顿时间控制在用户设定的停顿时间以内。</li></ol><p>为什么G1能建立可预测的停顿模型呢，主要原因在于 G1 对堆空间的分配与传统的垃圾收集器不一器，传统的内存分配就像我们前文所述，是连续的，分成新生代，老年代，新生代又分 Eden,S0,S1,如下</p><p><img src="840.png" alt="img"><br>而 G1 各代的存储地址不是连续的，每一代都使用了 n 个不连续的大小相同的 Region，每个Region占有一块连续的虚拟内存地址，如图示</p><p><img src="850.png" alt="img"><br>除了和传统的新老生代，幸存区的空间区别，Region还多了一个H，它代表Humongous，这表示这些Region存储的是巨大对象（humongous object，H-obj），即大小大于等于region一半的对象，这样超大对象就直接分配到了老年代，防止了反复拷贝移动。那么 G1 分配成这样有啥好处呢？</p><p>传统的收集器如果发生 Full GC 是对整个堆进行全区域的垃圾收集，而分配成各个 Region 的话，方便 G1 跟踪各个 Region 里垃圾堆积的价值大小（回收所获得的空间大小及回收所需经验值），这样根据价值大小维护一个优先列表，根据允许的收集时间，优先收集回收价值最大的 Region,也就避免了整个老年代的回收，也就减少了 STW 造成的停顿时间。同时由于只收集部分 Region,可就做到了 STW 时间的可控。</p><p>G1 收集器的工作步骤如下</p><ol><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ol><p><img src="860.png" alt="img"></p><p>可以看到整体过程与 CMS 收集器非常类似，筛选阶段会根据各个 Region 的回收价值和成本进行排序，根据用户期望的 GC 停顿时间来制定回收计划。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> GC </tag>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那些年我们学过的设计模式，你还记得几个（一）</title>
      <link href="2020/09/25/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E5%AD%A6%E8%BF%87%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E8%BF%98%E8%AE%B0%E5%BE%97%E5%87%A0%E4%B8%AA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2020/09/25/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E5%AD%A6%E8%BF%87%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E8%BF%98%E8%AE%B0%E5%BE%97%E5%87%A0%E4%B8%AA%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>最近在忙着面试，趁着没工作的空闲期，想把设计模式好好整理一遍。话不多说，我们直接上第一个设计模式—-<code>单例模式</code></p><h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>这也是面试时面试官经常问我的问题，什么是单例模式？脑海中是不是立即浮现出两种单例模式。然后准备滔滔不绝的说给面试官听？面试官在问我们这个问题的时候，我们最好不要答非所问。最好根据单例模式的定义去正面回答面试官。</p><p>单例模式是指在内存中只会创建且仅创建一次对象的设计模式。在程序中多次使用同一个对象且作用相同时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中创建一个对象，让所有需要调用的地方都共享这一单例对象。</p><p><img src="dlms1.jpg" alt="单例模式定义"></p><h2 id="单例模式创建类型"><a href="#单例模式创建类型" class="headerlink" title="单例模式创建类型"></a>单例模式创建类型</h2><ul><li><p><code>懒汉式</code>：在被程序第一次调用的时候才初始化该单例对象</p></li><li><p><code>饿汉式</code>：在类加载的时候就已经创建好该单例对象</p></li></ul><h3 id="懒汉式创建单例对象"><a href="#懒汉式创建单例对象" class="headerlink" title="懒汉式创建单例对象"></a>懒汉式创建单例对象</h3><p>懒汉式只在程序第一次调用的时候创建对象，所以需要调用的时候需要判断是否已经实例化该对象，如果未实例化，则实例化该对象。</p><p><img src="lhs.png" alt="懒汉式"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleTon singleTon;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon==<span class="keyword">null</span>)&#123;</span><br><span class="line">            singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面再讲这段代码的优化，我们先来看第二种单例模式的实现。</p><h3 id="饿汉式创建单例对象"><a href="#饿汉式创建单例对象" class="headerlink" title="饿汉式创建单例对象"></a>饿汉式创建单例对象</h3><p>饿汉式在类加载的时候就已经初始化好该对象，后续程序调用的都是该对象。</p><p><img src="ehs.png" alt="饿汉式"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleTon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleTon singleTon = <span class="keyword">new</span> HungrySingleTon();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样类在加载时会在堆内存中创建一个HungrySingleTon对象，当类被卸载时，HungrySingleTon对象也就会被随之死亡了。</p><h3 id="懒汉式代码如何优化"><a href="#懒汉式代码如何优化" class="headerlink" title="懒汉式代码如何优化"></a>懒汉式代码如何优化</h3><p>因为上述懒汉式的实现并不能保证在多线程环境下，对象只被创建一次的问题。因此存在一个线程安全的问题。我们回顾一下上面懒汉式创建的主要函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon==<span class="keyword">null</span>)&#123;</span><br><span class="line">            singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果同时存在多个线程，线程1在判断了<code>singleTon==null</code>后让出了cpu的使用权，而线程二这时候获取到了cpu的使用权，也判断了一次<code>singleTon==null</code>那么线程2就会执行<code>singleTon = new LazySingleTon()</code>,当线程1重新获取到cpu的使用权之后，因为他刚判断了<code>singleTon</code>是null，所以线程1也会创建一个LazySingleTon的实例。所以就存在了<code>线程安全</code>的问题。</p><hr><p>我们最容易想到的办法就是加锁，给类对象加锁或者给方法加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给方法加锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(singleTon==<span class="keyword">null</span>)&#123;</span><br><span class="line">singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleTon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给类对象加锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon==<span class="keyword">null</span>)&#123;</span><br><span class="line">singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleTon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但上面两种方法都存在一个问题，在获取对象之前都要先获取锁，所以并发性能就显得尤其的低下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon ==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleTon<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleTon == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的实现方式，就完美的解决了性能低下和锁资源的问题。</p><ul><li><strong>line2:</strong>当singleTon已经被实例化的时候,直接返回对象，不再获取锁资源</li><li><strong>line3</strong>:当多个线程进入第一个if时，施加同步锁，每次仅允许一个线程进去当前代码块。</li><li><strong>line4</strong>:锁内再次进行判断，因为多个线程抢夺一个资源时只有一个获取到，后进入的线程所要获取的对象已经被第一个线程实例化过。所以需要再次判断。</li></ul><p>这就是典型的DCL型懒汉单例，<code>Double Check and Lock</code>双重校验加锁。但是我们在写DCL的时候都会加入<code>volatile</code>关键词修饰singleTon。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleTon singleTon;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon ==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleTon<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleTon == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是因为JVM在创建对象的时候，可以对指令进行重排序以提高程序性能。JVM在创建对象的时候，一般会经过以下三个步骤：</p><ul><li>分配内存空间</li><li>初始化对象</li><li>将对象指向分配好的内存空间</li></ul><p>但是在2和3的时候有可能出现指令重排。比如多个线程，当线程1执行了1-3而正在初始化对象，而线程2获取对象时，就获取到了一个未初始化的对象。就会出现空指针异常了。而volatile就是为了在JVM创建对象的时候进行<code>禁止指令重排</code>的。</p><h2 id="还有其他的形式吗"><a href="#还有其他的形式吗" class="headerlink" title="还有其他的形式吗"></a>还有其他的形式吗</h2><h3 id="静态内部类实现单例"><a href="#静态内部类实现单例" class="headerlink" title="静态内部类实现单例"></a>静态内部类实现单例</h3><p>静态内部类相对于DCL模式实现更简单，对<code>静态域</code>使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在<code>实例域</code>需要延迟初始化时使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingleTon INSTANCE = <span class="keyword">new</span> SingleTon();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SingleTon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举类实现单例"><a href="#枚举类实现单例" class="headerlink" title="枚举类实现单例"></a>枚举类实现单例</h3><p>在JDK1.5中，java引入了枚举类型。枚举是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是《 Effective Java》 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象。</p><p>优点不言而喻：</p><ul><li>实现更简单</li><li>天然的线程安全</li><li>可以防止反射、反序列化创建多个枚举对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="破坏单例模式"><a href="#破坏单例模式" class="headerlink" title="破坏单例模式"></a>破坏单例模式</h2><p>枚举本身自带防止反射和反序列化的特性，那懒汉式和饿汉式又是如何被破坏的呢</p><h3 id="反射破坏单例模式"><a href="#反射破坏单例模式" class="headerlink" title="反射破坏单例模式"></a>反射破坏单例模式</h3><p>下面我们就可以用反射直接强制访问私有构造器，去创建实例对象破坏单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取类的显式构造器</span></span><br><span class="line">    Constructor&lt;HungrySingleTon&gt; construct = HungrySingleTon<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>()</span>;</span><br><span class="line">    <span class="comment">// 可访问私有构造器</span></span><br><span class="line">    construct.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 利用反射构造新对象</span></span><br><span class="line">    HungrySingleTon obj1 = construct.newInstance();</span><br><span class="line">    <span class="comment">// 通过正常方式获取单例对象</span></span><br><span class="line">    HungrySingleTon obj2 = HungrySingleTon.getInstance();</span><br><span class="line">    System.out.println(obj1 == obj2); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那如何防止单例模式被反射破坏呢，因为反射是强制访问私有构造器，对于饿汉式，在类加载的时候对象已经初始化，所以我们可以在私有构造器对当前对象进行判断来规避反射破坏单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleTon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleTon singleTon = <span class="keyword">new</span> HungrySingleTon();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleTon</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"禁止通过反射实例化对象"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化和反序列化破坏单例模式"><a href="#序列化和反序列化破坏单例模式" class="headerlink" title="序列化和反序列化破坏单例模式"></a>序列化和反序列化破坏单例模式</h3><p>下面是一个序列化和反序列化去破坏单例的例子，但是使用序列化和反序列化破坏单例时，单例对象的类必须实现Serializable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleTon</span> <span class="keyword">implements</span>  <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 创建输出流</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"Singleton.file"</span>));</span><br><span class="line">        <span class="comment">// 将单例对象写到文件中</span></span><br><span class="line">        oos.writeObject(HungrySingleTon.getInstance());</span><br><span class="line">        <span class="comment">// 从文件中读取单例对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"Singleton.file"</span>);</span><br><span class="line">        ObjectInputStream ois =  <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        HungrySingleTon newInstance = (HungrySingleTon) ois.readObject();</span><br><span class="line">        <span class="comment">// 判断是否是同一个对象</span></span><br><span class="line">        System.out.println(newInstance == HungrySingleTon.getInstance()); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleTon singleTon = <span class="keyword">new</span> HungrySingleTon();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>单例模式主要实现方式为懒汉式、饿汉式、静态内部类和枚举</li><li>大部分的单例模式可以被反射和序列化和反序列化破坏</li><li>我们可以通过人为干预来避免反射或系列化攻击</li><li>枚举自带天然的线程安全和单一实例以及防反射和防序列化和反序列破坏的特性</li><li>对于懒汉式最优雅的写法应该是DCL加volatile修饰</li><li>对内存要求高的时候我们可以选择<code>懒加载</code>的单例实现方式</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
