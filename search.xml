<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM垃圾回收与内存分配</title>
      <link href="2020/09/27/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>2020/09/27/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，外面的人想进来，里面的人想出去。</p><blockquote id="fn_引用"><sup>引用</sup>. 《深入理解JAVA虚拟机》<a href="#reffn_引用" title="Jump back to footnote [引用] in the text."> &#8617;</a></blockquote><p>JAVA相对于C/C++而言引入了GC机制，使程序员更加去关注程序本身，不需要再对每个new的对象去进行delete/free操作。C++就好像你在家里自己恰饭，需要去自己做好。吃完之后还要自己收拾。而JAVA更像是在餐厅中吃饭，你不需要去关注饭是如何做好的，以及吃完以后服务员是如何收拾的，你只要负责享用美食就可以了。</p><hr><h2 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h2><p>了解GC之前，我们需要先了解JVM的内存模型，搞清楚被回收的数据一般存在在哪些区域。</p><p><img src="jvmncqy.png" alt="JVM内存区域"></p><ul><li>虚拟机栈：描述方法执行时的内存模型，属于线程私有，生命周期同线程一样。主要保存执行方法时的局部变量表、操作数栈、动态连接和方法返回地址等信息,方法执行时入栈，方法执行完出栈，出栈之后数据清空，不需要GC。</li><li>本地方法栈：主要存储虚拟机调用native方法/服务相关信息。大体逻辑和虚拟机栈相同，也不需要GC。</li><li>程序技术器：主要记录当前线程执行字节码的行号。是<code>唯一一个</code>在 Java 虚拟机规范中没有规定任何 OOM 情况的区域，所以也不需要GC。</li><li>本地内存：线程共享区域。在JAVA8之前，方法区是在堆内的实现的。受GC管理，JAVA8把方法区的实现移到了本地内存中的元空间。这样方法区就不受JVM控制，也不会进行GC，也提升了性能，因为发生 GC 会发生 Stop The Word,造成性能受到一定影响，也方便在元空间中统一管理。</li><li>堆：堆是GC 发生的主要区域，对象实例和数组都是在堆上分配的，GC 也主要对这两类数据进行回收。接下来我们也终点分析这块区域。</li></ul><h2 id="如何判断垃圾"><a href="#如何判断垃圾" class="headerlink" title="如何判断垃圾"></a>如何判断垃圾</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>简单来说就是对每个对象去添加一个引用计数器，每当有一个地方引用他，计数器就加一，当引用失效就减一。如果没有被引用（引用次数为 0），则此对象可回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String ref = <span class="keyword">new</span> String(<span class="string">"Java"</span>);</span><br></pre></td></tr></table></figure><p><img src="630.png" alt="引用计数"></p><p>ref 引用了右侧定义的对象，所以引用次数是 1 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref &#x3D; null;</span><br></pre></td></tr></table></figure><p>对象没被引用，引用次数置为 0，由于不被任何变量引用，此时即被回收</p><p><img src="640.gif" alt="引用计数"></p><p>但单纯的引用计数无法解决对象之间的相互循环引用的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRCGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TestRCGC instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestRCGC</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一步</span></span><br><span class="line">    A a = <span class="keyword">new</span> TestRCGC(<span class="string">"a"</span>);</span><br><span class="line">    B b = <span class="keyword">new</span> TestRCGC(<span class="string">"b"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二步</span></span><br><span class="line">    a.instance = b;</span><br><span class="line">    b.instance = a;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三步</span></span><br><span class="line">    a = <span class="keyword">null</span>;</span><br><span class="line">    b = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="650.png" alt="循环引用"></p><p>虽然最后 a，b 都被置为 null 了，但是由于之前它们指向的对象互相指向了对方（引用计数都为 1），所以无法回收，也正是由于无法解决循环引用的问题，所以现代JAVA虚拟机都不用引用计数法来判断对象是否应该被回收。</p><h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p>当前主流的内存管理系统基本都是采用的可达性分析算法来判定对象是否存活。它的原理是通过一系列“GC Roots”的根对象作为起始节点集。从这个节点开始，通过引用向下搜索，搜索过程走的路被称为“引用链”，如果对象到“GC Roots”之间没有引用链相连的话，则说明这个对象是不可达的，也就是死亡的。</p><p><img src="660.png" alt="可达性分析"></p><p>如图所示：对象a和对象b之间，虽然存在循环引用，但是a，b之间不存在与GC Root想关联的引用，因此a,b是可回收的。<br>但是此时a,b并没有真正的死亡，而是处于一个“缓刑”的阶段。一个对象真正死亡需要同时满足两个条件，一个是对象与GC Roots没有相连接的引用链。另一个是对象是否有必要执行finallize()方法。如果对象未执行，则会先执行finallize()方法。如果执行该方法后对象仍不可达，则回收该对象，反之不回收该对象。<br>但是finallize只会被执行<code>一次</code>，如果在第一次执行了finallize之后对象仍然是可达的。那么下一次对象再被GC的时候会忽略finallize方法，会被回收。</p><p>那么这些 GC Roots 到底是什么东西呢，哪些对象可以作为 GC Root 呢，有以下几类</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li></ul><h4 id="虚拟机栈中引用的对象"><a href="#虚拟机栈中引用的对象" class="headerlink" title="虚拟机栈中引用的对象"></a>虚拟机栈中引用的对象</h4><p>a 是栈帧中的本地变量，当 a = null 时，由于此时 a 充当了 <strong>GC Root</strong> 的作用，a 与原来指向的实例 <strong>new Test()</strong> 断开了连接，所以对象会被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Test a = <span class="keyword">new</span> Test();</span><br><span class="line">    a = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法区中类静态属性引用对象"><a href="#方法区中类静态属性引用对象" class="headerlink" title="方法区中类静态属性引用对象"></a>方法区中类静态属性引用对象</h4><p>当栈帧中的本地变量 a = null 时，由于 a 原来指向的对象与 GC Root (变量 a) 断开了连接，所以 a 原来指向的对象会被回收，而由于我们给 s 赋值了变量的引用，s 在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Test s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Test a = <span class="keyword">new</span> Test();</span><br><span class="line">    a.s = <span class="keyword">new</span> Test();</span><br><span class="line">    a = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法区中常量引用对象"><a href="#方法区中常量引用对象" class="headerlink" title="方法区中常量引用对象"></a>方法区中常量引用对象</h4><p>常量 s 指向的对象并不会因为 a 指向的对象被回收而回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Test s = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test a = <span class="keyword">new</span> Test();</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="本地方法栈中-JNI-引用的对象"><a href="#本地方法栈中-JNI-引用的对象" class="headerlink" title="本地方法栈中 JNI 引用的对象"></a>本地方法栈中 JNI 引用的对象</h4><p>本地方法就是一个 java 调用非 java 代码的接口，该方法并非 Java 实现的，可能由 C 或 Python等其他语言实现的， Java 通过 JNI 来调用本地方法， 而本地方法是以库文件的形式存放的（在 WINDOWS 平台上是 DLL 文件形式，在 UNIX 机器上是 SO 文件形式）。通过调用本地的库文件的内部方法，使 JAVA 可以实现和本地机器的紧密联系，调用系统级的各接口方法。</p><p>当调用 Java 方法时，虚拟机会创建一个栈桢并压入 Java 栈，而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不会在 Java 栈祯中压入新的祯，虚拟机只是简单地动态连接并直接调用指定的本地方法。</p><p><img src="670.png" alt="栈帧"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_pecuyu_jnirefdemo_MainActivity_newStringNative</span><span class="params">(JNIEnv *env, jobject instance，jstring jmsg)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">   <span class="comment">// 缓存String的class</span></span><br><span class="line">   jclass jc = (*env)-&gt;FindClass(env, STRING_PATH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 java 调用以上本地方法时，jc 会被本地方法栈压入栈中, jc 就是我们说的本地方法栈中 JNI 的对象引用，因此只会在此本地方法执行完成后才会被释放。</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>先根据可达性算法<strong>标记</strong>出相应的可回收对象，对可回收的对象进行回收。</p><p><img src="680.png" alt="标记清除"></p><p>这种方式很简单，但是会有一个特别明显的问题，当大量的小对象死亡时，标记清除出来的碎片化空间就特别多。那么我们如何能获得一个连续内存空间呢？</p><h3 id="标记整理法"><a href="#标记整理法" class="headerlink" title="标记整理法"></a>标记整理法</h3><p>两步和标记清除法一样，不同的是它在标记清除法的基础上添加了一个整理的过程 ，即将所有的存活对象都往一端移动,紧邻排列，这样就可以解决碎片化空间的问题。</p><p><img src="690.png" alt="标记整理"></p><p>这种算法的缺点是每进一次垃圾清除都要频繁地移动存活的对象，效率十分低下。</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>把堆等分成两块区域, A 和 B，区域 A 负责分配对象，区域 B 不分配, 对区域 A 使用以上所说的标记法把存活的对象标记出来（下图有误无需清除），然后把区域 A 中存活的对象都复制到区域 B（存活对象都依次<strong>紧邻排列</strong>）最后把 A 区对象全部清理掉释放出空间。</p><p><img src="700.png" alt="标记整理"></p><p>复制算法的缺点是比如给堆分配分配的内存只有一半是可用的，另外每次回收也要把存活对象移动到另一半，效率低下。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>分代收集算法整合了以上算法，综合了这些算法的优点，最大程度避免了它们的缺点，所以是现代虚拟机采用的首选算法,与其说它是算法，倒不是说它是一种策略，因为它是把上述几种算法整合在了一起，为啥需要分代收集呢，来看一下对象的分配有啥规律</p><p><img src="710.png" alt="对象存活时间"></p><p><em>如图示：纵轴代表已分配的字节，而横轴代表程序运行时间</em></p><p>由图可知，大部分的对象都很短命，都在很短的时间内都被回收了（IBM 专业研究表明，一般来说，98% 的对象都是朝生夕死的，经过一次 Minor GC 后就会被回收），所以分代收集算法根据<strong>对象存活周期的不同</strong>将堆分成新生代和老生代（Java8以前还有个永久代）,默认比例为 1 : 2，新生代又分为 Eden 区， from Survivor 区（简称S0），to Survivor 区(简称 S1),三者的比例为 8: 1 : 1，这样就可以根据新老生代的特点选择最合适的垃圾回收算法，我们把新生代发生的 GC 称为 Young GC（也叫 Minor GC）,老年代发生的 GC 称为 Old GC（也称为 Full GC）。</p><p><img src="720.png" alt="新生代老年代"></p><h4 id="分代收集工作原理"><a href="#分代收集工作原理" class="headerlink" title="分代收集工作原理"></a>分代收集工作原理</h4><p><strong>1、对象在新生代的分配与回收</strong></p><p>由以上的分析可知，大部分对象在很短的时间内都会被回收，对象一般分配在 Eden 区</p><p><img src="730.png" alt="img"></p><p>当 Eden 区将满时，触发 Minor GC<img src="740.png" alt="img"></p><p>我们之前怎么说来着，大部分对象在短时间内都会被回收, 所以经过 Minor GC 后只有少部分对象会存活，它们会被移到 S0 区（这就是为啥空间大小  Eden: S0: S1 = 8:1:1, Eden 区远大于 S0,S1 的原因，因为在 Eden 区触发的 Minor GC 把大部对象（接近98%）都回收了,只留下少量存活的对象，此时把它们移到 S0 或 S1 绰绰有余）同时对象年龄加一（对象的年龄即发生 Minor GC 的次数），最后把 Eden 区对象全部清理以释放出空间,动图如下</p><p><img src="750.gif" alt="img"></p><p>当触发下一次 Minor GC 时，会把 Eden 区的存活对象和 S0（或S1） 中的存活对象（S0 或 S1 中的存活对象经过每次 Minor GC 都可能被回收）一起移到 S1（Eden 和 S0 的存活对象年龄+1）, 同时清空 Eden 和 S0 的空间。<img src="760.gif" alt="img"></p><p>若再触发下一次 Minor GC，则重复上一步，只不过此时变成了 从 Eden，S1 区将存活对象复制到 S0 区,每次垃圾回收, S0, S1 角色互换，都是从 Eden ,S0(或S1) 将存活对象移动到 S1(或S0)。也就是说在 Eden 区的垃圾回收我们采用的是<strong>复制算法</strong>，因为在 Eden 区分配的对象大部分在 Minor GC 后都消亡了，只剩下极少部分存活对象（这也是为啥 Eden:S0:S1 默认为 8:1:1 的原因），S0,S1 区域也比较小，所以最大限度地降低了复制算法造成的对象频繁拷贝带来的开销。</p><p><strong>2、对象何时晋升老年代</strong></p><ul><li>当对象的年龄达到了我们设定的阈值，则会从S0（或S1）晋升到老年代<img src="770.gif" alt="img">如图示：年龄阈值设置为 15， 当发生下一次 Minor GC 时，S0 中有个对象年龄达到 15，达到我们的设定阈值，晋升到老年代！</li><li>大对象 当某个对象分配需要大量的连续内存时，此时对象的创建不会分配在 Eden 区，会直接分配在老年代，因为如果把大对象分配在 Eden 区, Minor GC 后再移动到 S0,S1 会有很大的开销（对象比较大，复制会比较慢，也占空间），也很快会占满 S0,S1 区，所以干脆就直接移到老年代.</li><li>还有一种情况也会让对象晋升到老年代，即在 S0（或S1） 区相同年龄的对象大小之和大于 S0（或S1）空间一半以上时，则年龄大于等于该年龄的对象也会晋升到老年代。</li></ul><p><strong>3、空间分配担保</strong></p><p>在发生 MinorGC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，那么Minor GC 可以确保是安全的,如果不大于，那么虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行 Minor GC，否则可能进行一次 Full GC。</p><p><strong>4、Stop The World</strong></p><p>如果老年代满了，会触发 Full GC, Full GC 会同时回收新生代和老年代（即对整个堆进行GC），它会导致 Stop The World（简称 STW）,造成挺大的性能开销。</p><p>什么是 STW ？所谓的 STW, 即在 GC（minor GC 或 Full GC）期间，只有垃圾回收器线程在工作，其他工作线程则被挂起。</p><p><img src="780.png" alt="img"></p><p><em>画外音：为啥在垃圾收集期间其他工作线程会被挂起？想象一下，你一边在收垃圾，另外一群人一边丢垃圾，垃圾能收拾干净吗。</em></p><p>一般 Full GC 会导致工作线程停顿时间过长（因为Full GC 会清理<strong>整个堆</strong>中的不可用对象，一般要花较长的时间），如果在此 server 收到了很多请求，则会被拒绝服务！所以我们要尽量减少 Full GC（Minor GC 也会造成 STW,但只会触发轻微的 STW,因为 Eden 区的对象大部分都被回收了，只有极少数存活对象会通过复制算法转移到 S0 或 S1 区，所以相对还好）。</p><p>现在我们应该明白把新生代设置成 Eden, S0，S1区或者给对象设置年龄阈值或者默认把新生代与老年代的空间大小设置成 1:2 都是为了<strong>尽可能地避免对象过早地进入老年代，尽可能晚地触发 Full GC</strong>。想想新生代如果只设置 Eden 会发生什么，后果就是每经过一次 Minor GC，存活对象会过早地进入老年代，那么老年代很快就会装满，很快会触发 Full GC，而对象其实在经过两三次的 Minor GC 后大部分都会消亡，所以有了 S0,S1的缓冲，只有少数的对象会进入老年代，老年代大小也就不会这么快地增长，也就避免了过早地触发 Full GC。</p><p>由于 Full GC（或Minor GC） 会影响性能，所以我们要在一个合适的时间点发起 GC，这个时间点被称为 Safe Point，这个时间点的选定既不能太少以让 GC 时间太长导致程序过长时间卡顿，也不能过于频繁以至于过分增大运行时的负荷。一般当线程在这个时间点上状态是可以确定的，如确定 GC Root 的信息等，可以使 JVM 开始安全地 GC。Safe Point 主要指的是以下特定位置：</p><ul><li>循环的末尾</li><li>方法返回前</li><li>调用方法的 call 之后</li><li>抛出异常的位置 另外需要注意的是由于新生代的特点（大部分对象经过 Minor GC后会消亡）， Minor GC 用的是复制算法，而在老生代由于对象比较多，占用的空间较大，使用复制算法会有较大开销（复制算法在对象存活率较高时要进行多次复制操作，同时浪费一半空间）所以根据老生代特点，在老年代进行的 GC 一般采用的是标记整理法来进行回收。</li></ul><h2 id="垃圾收集器种类"><a href="#垃圾收集器种类" class="headerlink" title="垃圾收集器种类"></a>垃圾收集器种类</h2><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java 虚拟机规范并没有规定垃圾收集器应该如何实现，因此一般来说不同厂商，不同版本的虚拟机提供的垃圾收集器实现可能会有差别，一般会给出参数来让用户根据应用的特点来组合各个年代使用的收集器，主要有以下垃圾收集器</p><p><img src="790.png" alt="img"></p><ul><li>在新生代工作的垃圾回收器：Serial, ParNew, ParallelScavenge</li><li>在老年代工作的垃圾回收器：CMS，Serial Old, Parallel Old</li><li>同时在新老生代工作的垃圾回收器：G1</li></ul><p>图片中的垃圾收集器如果存在连线，则代表它们之间可以配合使用，接下来我们来看看各个垃圾收集器的具体功能。</p><h3 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h3><h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><p>Serial 收集器是工作在新生代的，单线程的垃圾收集器，单线程意味着它只会使用一个 CPU 或一个收集线程来完成垃圾回收，不仅如此，还记得我们上文提到的 STW 了吗，它在进行垃圾收集时，其他用户线程会暂停，直到垃圾收集结束，也就是说在 GC 期间，此时的应用不可用。</p><p>看起来单线程垃圾收集器不太实用，不过我们需要知道的任何技术的使用都不能脱离场景，在 <strong>Client 模式</strong>下，它简单有效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 单线程模式无需与其他线程交互，减少了开销，专心做 GC 能将其单线程的优势发挥到极致，另外在用户的桌面应用场景，分配给虚拟机的内存一般不会很大，收集几十甚至一两百兆（仅是新生代的内存，桌面应用基本不会再大了），STW 时间可以控制在一百多毫秒内，只要不是频繁发生，这点停顿是可以接受的，所以对于运行在 Client 模式下的虚拟机，Serial 收集器是新生代的默认收集器</p><h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><p>ParNew 收集器是 Serial 收集器的多线程版本，除了使用多线程，其他像收集算法,STW,对象分配规则，回收策略与 Serial 收集器完成一样，在底层上，这两种收集器也共用了相当多的代码，它的垃圾收集过程如下<img src="800.png" alt="img"></p><p>ParNew 主要工作在 Server 模式，我们知道服务端如果接收的请求多了，响应时间就很重要了，多线程可以让垃圾回收得更快，也就是减少了 STW 时间，能提升响应时间，所以是许多运行在 Server 模式下的虚拟机的首选新生代收集器，另一个与性能无关的原因是因为除了 Serial  收集器，<strong>只有它能与 CMS 收集器配合工作</strong>，CMS 是一个划时代的垃圾收集器，是真正意义上的<strong>并发收集器</strong>，它第一次实现了垃圾收集线程与用户线程（基本上）同时工作，它采用的是传统的 GC 收集器代码框架，与 Serial,ParNew 共用一套代码框架，所以能与这两者一起配合工作，而后文提到的 Parallel Scavenge 与 G1 收集器没有使用传统的 GC 收集器代码框架，而是另起炉灶独立实现的，另外一些收集器则只是共用了部分的框架代码,所以无法与 CMS 收集器一起配合工作。</p><p>在多 CPU 的情况下，由于 ParNew 的多线程回收特性，毫无疑问垃圾收集会更快，也能有效地减少 STW 的时间，提升应用的响应速度。</p><h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>Parallel Scavenge 收集器也是一个使用<strong>复制算法</strong>，<strong>多线程</strong>，工作于新生代的垃圾收集器，看起来功能和 ParNew 收集器一样，它有啥特别之处吗</p><p><strong>关注点不同</strong>，CMS 等垃圾收集器关注的是尽可能缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 目标是达到一个可控制的吞吐量（吞吐量 = 运行用户代码时间 / （运行用户代码时间+垃圾收集时间）），也就是说 CMS 等垃圾收集器更适合用到与用户交互的程序，因为停顿时间越短，用户体验越好，而 Parallel Scavenge 收集器关注的是吞吐量，所以更适合做后台运算等不需要太多用户交互的任务。</p><p>Parallel Scavenge 收集器提供了两个参数来精确控制吞吐量，分别是控制最大垃圾收集时间的 -XX:MaxGCPauseMillis 参数及直接设置吞吐量大小的 -XX:GCTimeRatio（默认99%）</p><p>除了以上两个参数，还可以用 Parallel Scavenge 收集器提供的第三个参数 -XX:UseAdaptiveSizePolicy，开启这个参数后，就不需要手工指定新生代大小,Eden 与 Survivor 比例（SurvivorRatio）等细节，只需要设置好基本的堆大小（-Xmx 设置最大堆）,以及最大垃圾收集时间与吞吐量大小，虚拟机就会根据当前系统运行情况收集监控信息，动态调整这些参数以尽可能地达到我们设定的最大垃圾收集时间或吞吐量大小这两个指标。自适应策略也是 Parallel Scavenge  与 ParNew 的重要区别！</p><h3 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h3><h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p>上文我们知道， Serial 收集器是工作于新生代的单线程收集器，与之相对地，Serial Old 是工作于老年代的单线程收集器，此收集器的主要意义在于给 Client 模式下的虚拟机使用，如果在 Server 模式下，则它还有两大用途：一种是在 JDK 1.5 及之前的版本中与 Parallel Scavenge 配合使用，另一种是作为 CMS 收集器的后备预案,在并发收集发生 Concurrent Mode Failure 时使用（后文讲述）,它与 Serial 收集器配合使用示意图如下</p><p><img src="810.png" alt="img"></p><h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><p>Parallel Old 是相对于 Parallel Scavenge 收集器的老年代版本，使用多线程和标记整理法，两者组合示意图如下,这两者的组合由于都是多线程收集器，真正实现了「吞吐量优先」的目标</p><p><img src="820.png" alt="img"></p><h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><p>CMS 收集器是以实现最短 STW 时间为目标的收集器，如果应用很重视服务的响应速度，希望给用户最好的体验，则 CMS 收集器是个很不错的选择！</p><p>我们之前说老年代主要用标记整理法，而 CMS 虽然工作于老年代，但采用的是标记清除法，主要有以下四个步骤</p><ol><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ol><p><img src="830.png" alt="img"></p><p>从图中可以的看到初始标记和重新标记两个阶段会发生 STW，造成用户线程挂起，不过初始标记仅标记 GC Roots 能关联的对象，速度很快，并发标记是进行 GC Roots  Tracing 的过程，重新标记是为了修正并发标记期间因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录，这一阶段停顿时间一般比初始标记阶段稍长，但<strong>远比并发标记时间短</strong>。</p><p>整个过程中耗时最长的是并发标记和标记清理，不过这两个阶段用户线程都可工作，所以不影响应用的正常使用，所以总体上看，可以认为 CMS 收集器的内存回收过程是与用户线程一起并发执行的。</p><p>但是 CMS 收集器远达不到完美的程度，主要有以下三个缺点</p><ul><li>CMS 收集器对 CPU 资源非常敏感  原因也可以理解，比如本来我本来可以有 10 个用户线程处理请求，现在却要分出 3 个作为回收线程，吞吐量下降了30%，CMS 默认启动的回收线程数是 （CPU数量+3）/ 4, 如果 CPU 数量只有一两个，那吞吐量就直接下降 50%,显然是不可接受的</li><li>CMS 无法处理浮动垃圾（Floating Garbage）,可能出现 「Concurrent Mode Failure」而导致另一次 Full GC 的产生，由于在并发清理阶段用户线程还在运行，所以清理的同时新的垃圾也在不断出现，这部分垃圾只能在下一次 GC 时再清理掉（即浮云垃圾），同时在垃圾收集阶段用户线程也要继续运行，就需要预留足够多的空间要确保用户线程正常执行，这就意味着 CMS 收集器不能像其他收集器一样等老年代满了再使用，JDK 1.5 默认当老年代使用了68%空间后就会被激活，当然这个比例可以通过 -XX:CMSInitiatingOccupancyFraction 来设置，但是如果设置地太高很容易导致在 CMS 运行期间预留的内存无法满足程序要求，会导致 <strong>Concurrent Mode Failure</strong> 失败，这时会启用 Serial Old 收集器来重新进行老年代的收集，而我们知道 Serial Old 收集器是单线程收集器，这样就会导致 STW 更长了。</li><li>CMS 采用的是标记清除法，上文我们已经提到这种方法会产生大量的内存碎片，这样会给大内存分配带来很大的麻烦，如果无法找到足够大的连续空间来分配对象，将会触发 Full GC，这会影响应用的性能。当然我们可以开启 -XX:+UseCMSCompactAtFullCollection（默认是开启的），用于在 CMS 收集器顶不住要进行 FullGC 时开启内存碎片的合并整理过程，内存整理会导致 STW，停顿时间会变长，还可以用另一个参数 -XX:CMSFullGCsBeforeCompation 用来设置执行多少次不压缩的 Full GC 后跟着带来一次带压缩的。</li></ul><h4 id="G1（Garbage-First）-收集器"><a href="#G1（Garbage-First）-收集器" class="headerlink" title="G1（Garbage First） 收集器"></a>G1（Garbage First） 收集器</h4><p>G1 收集器是面向服务端的垃圾收集器，被称为驾驭一切的垃圾回收器，主要有以下几个特点</p><ul><li><p>像 CMS 收集器一样，能与应用程序线程并发执行。</p></li><li><p>整理空闲空间更快。</p></li><li><p>需要 GC 停顿时间更好预测。</p></li><li><p>不会像 CMS 那样牺牲大量的吞吐性能。</p></li><li><p>不需要更大的 Java Heap</p></li></ul><p>与 CMS 相比，它在以下两个方面表现更出色</p><ol><li>运作期间不会产生内存碎片，G1 从整体上看采用的是标记-整理法，局部（两个 Region）上看是基于复制算法实现的，两个算法都不会产生内存碎片，收集后提供规整的可用内存，这样有利于程序的长时间运行。</li><li>在 STW 上建立了<strong>可预测</strong>的停顿时间模型，用户可以指定期望停顿时间，G1 会将停顿时间控制在用户设定的停顿时间以内。</li></ol><p>为什么G1能建立可预测的停顿模型呢，主要原因在于 G1 对堆空间的分配与传统的垃圾收集器不一器，传统的内存分配就像我们前文所述，是连续的，分成新生代，老年代，新生代又分 Eden,S0,S1,如下</p><p><img src="840.png" alt="img"><br>而 G1 各代的存储地址不是连续的，每一代都使用了 n 个不连续的大小相同的 Region，每个Region占有一块连续的虚拟内存地址，如图示</p><p><img src="850.png" alt="img"><br>除了和传统的新老生代，幸存区的空间区别，Region还多了一个H，它代表Humongous，这表示这些Region存储的是巨大对象（humongous object，H-obj），即大小大于等于region一半的对象，这样超大对象就直接分配到了老年代，防止了反复拷贝移动。那么 G1 分配成这样有啥好处呢？</p><p>传统的收集器如果发生 Full GC 是对整个堆进行全区域的垃圾收集，而分配成各个 Region 的话，方便 G1 跟踪各个 Region 里垃圾堆积的价值大小（回收所获得的空间大小及回收所需经验值），这样根据价值大小维护一个优先列表，根据允许的收集时间，优先收集回收价值最大的 Region,也就避免了整个老年代的回收，也就减少了 STW 造成的停顿时间。同时由于只收集部分 Region,可就做到了 STW 时间的可控。</p><p>G1 收集器的工作步骤如下</p><ol><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ol><p><img src="860.png" alt="img"></p><p>可以看到整体过程与 CMS 收集器非常类似，筛选阶段会根据各个 Region 的回收价值和成本进行排序，根据用户期望的 GC 停顿时间来制定回收计划。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> GC </tag>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那些年我们学过的设计模式，你还记得几个（一）</title>
      <link href="2020/09/25/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E5%AD%A6%E8%BF%87%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E8%BF%98%E8%AE%B0%E5%BE%97%E5%87%A0%E4%B8%AA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2020/09/25/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E5%AD%A6%E8%BF%87%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E8%BF%98%E8%AE%B0%E5%BE%97%E5%87%A0%E4%B8%AA%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>最近在忙着面试，趁着没工作的空闲期，想把设计模式好好整理一遍。话不多说，我们直接上第一个设计模式—-<code>单例模式</code></p><h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>这也是面试时面试官经常问我的问题，什么是单例模式？脑海中是不是立即浮现出两种单例模式。然后准备滔滔不绝的说给面试官听？面试官在问我们这个问题的时候，我们最好不要答非所问。最好根据单例模式的定义去正面回答面试官。</p><p>单例模式是指在内存中只会创建且仅创建一次对象的设计模式。在程序中多次使用同一个对象且作用相同时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中创建一个对象，让所有需要调用的地方都共享这一单例对象。</p><p><img src="dlms1.jpg" alt="单例模式定义"></p><h2 id="单例模式创建类型"><a href="#单例模式创建类型" class="headerlink" title="单例模式创建类型"></a>单例模式创建类型</h2><ul><li><p><code>懒汉式</code>：在被程序第一次调用的时候才初始化该单例对象</p></li><li><p><code>饿汉式</code>：在类加载的时候就已经创建好该单例对象</p></li></ul><h3 id="懒汉式创建单例对象"><a href="#懒汉式创建单例对象" class="headerlink" title="懒汉式创建单例对象"></a>懒汉式创建单例对象</h3><p>懒汉式只在程序第一次调用的时候创建对象，所以需要调用的时候需要判断是否已经实例化该对象，如果未实例化，则实例化该对象。</p><p><img src="lhs.png" alt="懒汉式"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleTon singleTon;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon==<span class="keyword">null</span>)&#123;</span><br><span class="line">            singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面再讲这段代码的优化，我们先来看第二种单例模式的实现。</p><h3 id="饿汉式创建单例对象"><a href="#饿汉式创建单例对象" class="headerlink" title="饿汉式创建单例对象"></a>饿汉式创建单例对象</h3><p>饿汉式在类加载的时候就已经初始化好该对象，后续程序调用的都是该对象。</p><p><img src="ehs.png" alt="饿汉式"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleTon singleTon = <span class="keyword">new</span> HungrySingleTon();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样类在加载时会在堆内存中创建一个HungrySingleTon对象，当类被卸载时，HungrySingleTon对象也就会被随之死亡了。</p><h3 id="懒汉式代码如何优化"><a href="#懒汉式代码如何优化" class="headerlink" title="懒汉式代码如何优化"></a>懒汉式代码如何优化</h3><p>因为上述懒汉式的实现并不能保证在多线程环境下，对象只被创建一次的问题。因此存在存在一个线程安全的问题。我们回顾一下上面懒汉式创建的主要函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon==<span class="keyword">null</span>)&#123;</span><br><span class="line">            singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果同时存在多个线程，线程1在判断了<code>singleTon==null</code>后让出了cpu的使用权，而线程二这时候获取到了cpu的使用权，也判断了一次<code>singleTon==null</code>那么线程2就会执行<code>singleTon = new LazySingleTon()</code>,当线程1重新获取到cpu的使用权之后，因为他刚判断了<code>singleTon</code>是null，所以线程1也会创建一个LazySingleTon的实例。所以就存在了<code>线程安全</code>的问题。</p><hr><p>我们最容易想到的办法就是加锁，给类对象加锁或者给方法加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给方法加锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(singleTon==<span class="keyword">null</span>)&#123;</span><br><span class="line">singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleTon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给类对象加锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon==<span class="keyword">null</span>)&#123;</span><br><span class="line">singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleTon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但上面两种方法都存在一个问题，在获取对象之前都要先获取锁，所以并发性能就显得尤其的低下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon ==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleTon<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleTon == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的实现方式，就完美的解决了性能低下和锁资源的问题。</p><ul><li><strong>line2:</strong>当singleTon已经被实例化的时候,直接返回对象，不再获取锁资源</li><li><strong>line3</strong>:当多个线程进入第一个if时，施加同步锁，每次仅允许一个线程进去当前代码块。</li><li><strong>line4</strong>:锁内再次进行判断，因为多个线程抢夺一个资源时只有一个获取到，后进入的线程所要获取的对象已经被第一个线程实例化过。所以需要再次判断。</li></ul><p>这就是典型的DCL型懒汉单例，<code>Double Check and Lock</code>双重校验加锁。但是我们在写DCL的时候都会加入<code>volatile</code>关键词修饰singleTon。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleTon singleTon;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon ==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleTon<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleTon == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是因为JVM在创建对象的时候，可以对指令进行重排序以提高程序性能。JVM在创建对象的时候，一般会经过以下三个步骤：</p><ul><li>分配内存空间</li><li>初始化对象</li><li>将对象指向分配好的内存空间</li></ul><p>但是在2和3的时候有可能出现指令重排。比如多个线程，当线程1执行了1-3而正在初始化对象，而线程2获取对象时，就获取到了一个未初始化的对象。就会出现空指针异常了。而volatile就是为了在JVM创建对象的时候进行<code>禁止指令重排</code>的。</p><h2 id="还有其他的形式吗"><a href="#还有其他的形式吗" class="headerlink" title="还有其他的形式吗"></a>还有其他的形式吗</h2><h3 id="静态内部类实现单例"><a href="#静态内部类实现单例" class="headerlink" title="静态内部类实现单例"></a>静态内部类实现单例</h3><p>静态内部类相对于DCL模式实现更简单，对<code>静态域</code>使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在<code>实例域</code>需要延迟初始化时使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingleTon INSTANCE = <span class="keyword">new</span> SingleTon();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SingleTon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举类实现单例"><a href="#枚举类实现单例" class="headerlink" title="枚举类实现单例"></a>枚举类实现单例</h3><p>在JDK1.5中，java引入了枚举类型。枚举是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是《 Effective Java》 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象。</p><p>优点不言而喻：</p><ul><li>实现更简单</li><li>天然的线程安全</li><li>可以防止反射、反序列化创建多个枚举对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="破坏单例模式"><a href="#破坏单例模式" class="headerlink" title="破坏单例模式"></a>破坏单例模式</h2><p>枚举本身自带防止反射和反序列化的特性，那懒汉式和饿汉式又是如何被破坏的呢</p><h3 id="反射破坏单例模式"><a href="#反射破坏单例模式" class="headerlink" title="反射破坏单例模式"></a>反射破坏单例模式</h3><p>下面我们就可以用反射直接强制访问私有构造器，去创建实例对象破坏单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取类的显式构造器</span></span><br><span class="line">    Constructor&lt;HungrySingleTon&gt; construct = HungrySingleTon<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>()</span>;</span><br><span class="line">    <span class="comment">// 可访问私有构造器</span></span><br><span class="line">    construct.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 利用反射构造新对象</span></span><br><span class="line">    HungrySingleTon obj1 = construct.newInstance();</span><br><span class="line">    <span class="comment">// 通过正常方式获取单例对象</span></span><br><span class="line">    HungrySingleTon obj2 = HungrySingleTon.getInstance();</span><br><span class="line">    System.out.println(obj1 == obj2); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那如何防止单例模式被反射破坏呢，因为反射是强制访问私有构造器，对于饿汉式，在类加载的时候对象已经初始化，所以我们可以在私有构造器对当前对象进行判断来规避反射破坏单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleTon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleTon singleTon = <span class="keyword">new</span> HungrySingleTon();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleTon</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"禁止通过反射实例化对象"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化和反序列化破坏单例模式"><a href="#序列化和反序列化破坏单例模式" class="headerlink" title="序列化和反序列化破坏单例模式"></a>序列化和反序列化破坏单例模式</h3><p>下面是一个序列化和反序列化去破坏单例的例子，但是使用序列化和反序列化破坏单例时，单例对象的类必须实现Serializable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleTon</span> <span class="keyword">implements</span>  <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 创建输出流</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"Singleton.file"</span>));</span><br><span class="line">        <span class="comment">// 将单例对象写到文件中</span></span><br><span class="line">        oos.writeObject(HungrySingleTon.getInstance());</span><br><span class="line">        <span class="comment">// 从文件中读取单例对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"Singleton.file"</span>);</span><br><span class="line">        ObjectInputStream ois =  <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        HungrySingleTon newInstance = (HungrySingleTon) ois.readObject();</span><br><span class="line">        <span class="comment">// 判断是否是同一个对象</span></span><br><span class="line">        System.out.println(newInstance == HungrySingleTon.getInstance()); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleTon singleTon = <span class="keyword">new</span> HungrySingleTon();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>单例模式主要实现方式为懒汉式、饿汉式、静态内部类和枚举</li><li>大部分的单例模式可以被反射和序列化和反序列化破坏</li><li>我们可以通过人为干预来避免反射或系列化攻击</li><li>枚举自带天然的线程安全和单一实例以及防反射和防序列化和反序列破坏的特性</li><li>对于懒汉式最优雅的写法应该是DCL加volatile修饰</li><li>对内存要求高的时候我们可以选择<code>懒加载</code>的单例实现方式</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客，记录我的絮絮叨叨</title>
      <link href="2020/09/23/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%EF%BC%8C%E8%AE%B0%E5%BD%95%E6%88%91%E7%9A%84%E7%B5%AE%E7%B5%AE%E5%8F%A8%E5%8F%A8/"/>
      <url>2020/09/23/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%EF%BC%8C%E8%AE%B0%E5%BD%95%E6%88%91%E7%9A%84%E7%B5%AE%E7%B5%AE%E5%8F%A8%E5%8F%A8/</url>
      
        <content type="html"><![CDATA[<p>今天是脱口秀大会第三季的收官期，这个主题也和我想发的牢骚很契合吧。脱口秀决赛期的主题是<code>新的终点，也是新的起点</code>。</p><p><a href="https://v.qq.com/x/cover/mzc0020026ss8r8.html" target="_blank" rel="noopener">脱口秀大会收官决赛 &#10174;</a></p><p>第三季脱口秀大会我没有每期都看，但是今天的主题对我来说也有特别的意义。</p><h2 id="学校-社会"><a href="#学校-社会" class="headerlink" title="学校-社会"></a>学校-社会</h2><h3 id="毕业"><a href="#毕业" class="headerlink" title="毕业"></a>毕业</h3><p>就在两个月之前，我刚从学校拿到了我的学位证书，告别了我的<code>校园生活</code>。其实今年离开大学，没有很难舍的情怀在里面，可能是因为疫情的缘故吧，在毕业之前已经将近8个月不在校园，就连毕业也只是匆匆领证。天公不作美，毕业那天又刚好一直在下雨，以至于毕业照甚至没有一点仪式感。没有太多的小合影，没有太多时间给我留念。我就告别了我的大学，和李佳鑫一起赶当天下午的高铁一起回南京。</p><p><img src="byhz.jpg" alt="毕业合照"></p><h3 id="社会"><a href="#社会" class="headerlink" title="社会"></a>社会</h3><p>在我还没有拿到毕业证的时候，我相当于已经是一个<code>准社会人</code>了，春招的时候其实已经有很强的危机感了，想找一份待遇还不错，自己也满意的工作。其实秋招的时候，我拿到过一些公司的offer，但是秋招的时候当时都没有选择去签订三方，想等等看春招会不会有更好的机会，春招的时候面了几家，但是总体待遇都不是很好。我最后还是选择去了华宇信息去入职。最后因为工资待遇问题提出了离职。就这样我新的起点，又变成了终点。</p><hr><h2 id="工作-工作"><a href="#工作-工作" class="headerlink" title="工作-工作"></a>工作-工作</h2><p>好像做IT行业，给人的工作就是一份工作最多干个两三年。而我的第一份正式工作，却只坚持了短短三个月。</p><h3 id="第一份工作"><a href="#第一份工作" class="headerlink" title="第一份工作"></a>第一份工作</h3><p>上面所提到的，我的第一份正式工作选择了华宇这个平台。而我也因为生活成本和劳动回报比的问题和公司产生了分歧。最终在和领导沟通的过程中，领导说转正重新定薪的可能性很小。我只想和自己比，当时的我连房租都付不起，我和领导沟通的时候，希望涨1k，我不管其他跟我一起入职的比我高多少，我只想先生存下来，领导说重新定薪基本不可能。后来几天我思考之后选择离职，领导又突然说帮我跟上级沟通，应该可以涨2k，我想了一下前几天的话，突然像个笑话。没有留恋，没有回头。从此，你我江湖是路人。</p><h3 id="第二份工作"><a href="#第二份工作" class="headerlink" title="第二份工作"></a>第二份工作</h3><p>因为选择的裸辞，压力还是挺大的，又加上我8月工资扣了7、8、9、10四个月的社保和7、8、9三个月的公积金，所以到手工资只有<code>1.3k</code>,让我本不富裕的生活又更加窘迫起来，需要在短时间内找到工作。应届生裸辞带来的第一个风险就是简历社招很难过，没有工作经验。所幸，过简历的都成功拿到了offer。也拒绝了一部分offer。以后日子再苦，都要坚持吧，未来可期。有点毒鸡汤，也是对自己的激励。</p><h1 id="新的终点，新的起点"><a href="#新的终点，新的起点" class="headerlink" title="新的终点，新的起点"></a>新的终点，新的起点</h1><p>我写这篇博客之前，重新搭建了一下自己的博客，把以前的文章删掉。也是之前颓废的自己的一个终点吧，立一个flag，至少每周记录一下自己所学，有所文字产出。未来还很长，大家都需要努力。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
