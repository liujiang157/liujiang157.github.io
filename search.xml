<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[译] JAVA16带给开发者的新特性</title>
      <link href="2021/03/29/%E8%AF%91-JAVA16%E5%B8%A6%E7%BB%99%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>2021/03/29/%E8%AF%91-JAVA16%E5%B8%A6%E7%BB%99%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="https://levelup.gitconnected.com/features-java-16-brings-to-developers-b0edd1a1ed28" target="_blank" rel="noopener">Features Java 16 Brings to Developers</a></li><li>原文作者：<a href="https://zivce.medium.com/" target="_blank" rel="noopener">Živković Miloš</a></li><li>译    者：<a href="https://maybelence.cn/">maybelence</a></li></ul></blockquote><p>Java不需要再做过多介绍。它作为一种编程语言，已经有很多年的发展历史。最近的更新也为该语言带来了几个新的特性：</p><ul><li>密封类</li><li>模式匹配</li><li>其他安全措施。</li></ul><h3 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h3><p><a href="https://openjdk.java.net/jeps/397" target="_blank" rel="noopener">JEP-397</a></p><p><code>密封</code>背后的动机是限制具体的类。密封将实现控制模式匹配，并提供对模式匹配的支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里可以许可的关键字已经密封 </span></span><br><span class="line"><span class="comment">// 允许列出可以扩展密封等级的等级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">    <span class="title">permits</span> <span class="title">Circle</span>, <span class="title">Rectangle</span>, <span class="title">Square</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>如果使用基本的接口，那你将不会得到反射，您不会对这些有限的具体实现有细致了解。</p><p>当使用密封类的话，你将获取到这个反射行为，您知道自己域中可以拥有的类型。</p><p>枚举表明了一组有限的值。密封类表明了一组数量有限的一种值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sealed <span class="class"><span class="keyword">interface</span> <span class="title">Celestial</span> </span></span><br><span class="line"><span class="class">    <span class="title">permits</span> <span class="title">Planet</span>, <span class="title">Star</span>, <span class="title">Comet</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Planet</span> <span class="keyword">implements</span> <span class="title">Celestial</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Star</span>   <span class="keyword">implements</span> <span class="title">Celestial</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Comet</span>  <span class="keyword">implements</span> <span class="title">Celestial</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是，这种层次结构并不会反映出重要的领域知识，即我们的模型中只有三种。<br>在这些情况下，限制子类或者子接口的集合可以简化建模。 — JEP-397</p></blockquote><h3 id="对基于值的类的值发出警告"><a href="#对基于值的类的值发出警告" class="headerlink" title="对基于值的类的值发出警告"></a>对基于值的类的值发出警告</h3><p><a href="https://openjdk.java.net/jeps/390" target="_blank" rel="noopener">JEP-390</a></p><p>基本类型的包装类是基于值的类，例如：<code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>Boolean</code>,和 <code>Character</code>。有关基于值的类的更多信息，请参见<a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/doc-files/ValueBased.html" target="_blank" rel="noopener">此处</a>。</p><p>由于它们是不可变的对象，因此构造函数对于它们来言是没有任何意义的。</p><p>为防止滥用构造函数，提供<code>@jdk.internal.ValueBased</code>来用于标注作为value-based的类。每次编译器找到基于值的类构造函数时，这都会发出警告。</p><h3 id="默认强封装JDK内部元素"><a href="#默认强封装JDK内部元素" class="headerlink" title="默认强封装JDK内部元素"></a>默认强封装JDK内部元素</h3><p><a href="https://openjdk.java.net/jeps/396" target="_blank" rel="noopener">JEP-396</a></p><p>这是为了鼓励用户使用标准的Java API。不过，如果您如果需要使用宽松的封装。请尽量避免使用该特性。</p><p>您需要将参数添加到JVM的启动器中。在下面您可以看到可能的参数，您可以传入。有关参数的更多信息，请参见<a href="https://openjdk.java.net/jeps/396#Description" target="_blank" rel="noopener">此处</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--illegal-access&#x3D; permit | deny | debug | warn</span><br></pre></td></tr></table></figure><p>尽管JAVA16包含了此功能，但是您可能在更早的<a href="https://stackoverflow.com/questions/53790182/get-the-current-value-of-illegal-access-setting-in-java" target="_blank" rel="noopener">版本</a>就遇到了这种问题，这个更改是在JAVA9<a href="https://jaxenter.com/jdk-9-replace-permit-illegal-access-134180.html" target="_blank" rel="noopener">发布</a>之后提出的。</p><blockquote><p>直至今日，某些构建工具在构建Java项目(Java&gt; = 9)时仍会打印出<a href="https://issues.apache.org/jira/browse/GROOVY-8339" target="_blank" rel="noopener">“反射访问”警告</a>，即使已经成功构建，它们也会感觉“尚未就绪”。 - <a href="https://www.marcobehler.com/guides/a-guide-to-java-versions-and-features" target="_blank" rel="noopener">出处</a></p></blockquote><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p><a href="https://openjdk.java.net/jeps/394" target="_blank" rel="noopener">JEP-394</a></p><p>模式匹配已经存在很长时间了，你可以在很多编程语言中发现它，例如Elixir。</p><p>在JAVA中，存在许多<code>instanceof</code>条件。因为有减少操作的动机从而衍生出了模式匹配。</p><blockquote><p>模式匹配允许简明地表达对象的所需“形状”（模式），并允许各种语句和表达式针对其输入（匹配）来测试“形状”。 — JEP-394</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很多样板代码</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    String s = (String) obj;    <span class="comment">// grr...</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用模式匹配，我们可以获得此代码。减少样板，进行转换，并声明变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">    <span class="comment">// Let pattern matching do the work!</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模式变量在它匹配的范围内。因此，这样的代码是有效的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a <span class="keyword">instanceof</span> Point p) &#123;</span><br><span class="line">    <span class="comment">// p在范围内</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p不再范围内</span></span><br><span class="line"><span class="keyword">if</span> (b <span class="keyword">instanceof</span> Point p) &#123;     <span class="comment">// Sure!</span></span><br><span class="line">        ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您不必担心变量名。如果范围不同，则可以重用现有名称。</p><p><em>模式匹配改善了什么？？？</em></p><p>可以避免很多显示的转换，让我们用相同的方法，写出可读性更高的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (o <span class="keyword">instanceof</span> CaseInsensitiveString) &amp;&amp;</span><br><span class="line">        ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</span><br><span class="line"><span class="comment">// to this </span></span><br><span class="line"><span class="keyword">return</span> (o <span class="keyword">instanceof</span> CaseInsensitiveString cis) &amp;&amp;</span><br><span class="line">        cis.s.equalsIgnoreCase(s);</span><br></pre></td></tr></table></figure><p>现在看下一个例子，如果instanceof String s的条件为true，则为s分配一个值。相反，如果模式匹配失败，那么s将没有任何值。</p><p>因此这个代码完全可以正常执行，不存在<a href="https://docs.oracle.com/javase/specs/jls/se15/html/jls-14.html#jls-14.22" target="_blank" rel="noopener">语句不可达</a>的情况。如果有条件通过，则s分配值；如果没有通过，则s被安全丢弃。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onlyForStrings</span><span class="params">(Object o)</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> String s))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyException();</span><br><span class="line">    <span class="comment">// s has value at this point</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Java在不断发展。导致很多重大更改。同时也入很多<a href="https://medium.com/dev-genius/8-problems-every-java-developer-knows-4f65339e0c00" target="_blank" rel="noopener">问题</a>。</p><p><img src="0_MzIcNjgSR9uVS3yb.png" alt="Constant Java updates"></p><p>即使这样，我们仍然需要进行调整。使用新特性，以便我们创建更好的软件。这些是我提出的几个新特性。您可以在下面的部分中阅读更多内容。</p><hr><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>JEP草案：开关的模式匹配（preview）<a href="https://openjdk.java.net/jeps/406" target="_blank" rel="noopener">点此查看</a></p><p>JDK16：JAVA16中的新特性 <a href="https://www.infoworld.com/article/3569150/jdk-16-the-new-features-in-java-16.html" target="_blank" rel="noopener">点此查看</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA16 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切面编程--springAOP</title>
      <link href="2021/03/24/%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B-springAOP/"/>
      <url>2021/03/24/%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B-springAOP/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>AOP意为<code>面向切面编程</code>，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术，是OOP面向对象编程的一种补足。它是软件开发中的一个热点技术，Spring AOP 也是Spring框架的核心特性之一（另一个核心特性是IOC）</p><h4 id="为什么要引入AOP"><a href="#为什么要引入AOP" class="headerlink" title="为什么要引入AOP"></a>为什么要引入AOP</h4><ul><li>分离功能性需求和非功能性需求</li><li>集中处理某一关注点</li><li>侵入性少，增强代码可读性及可维护性</li></ul><h4 id="AOP应用场景"><a href="#AOP应用场景" class="headerlink" title="AOP应用场景"></a>AOP应用场景</h4><p>权限控制、缓存控制、事务控制、分布式追踪、异常处理等</p><p>举个例子，比如一个后台管理系统，每次修改元素信息的时候，都需要校验操作人是否拥有该操作权限，在传统的OOP中，我们需要写一个<code>基类</code>，声明鉴权方法，在子类中调用super.checkPriv();来返回结果。如果Service很多，每个Service都需要继承BaseService,就会导致耦合度过高，代码冗余。<br>而AOP可以直接通过一个单一的切面类，对需要权限验证的方法统一织入。就好像一个包租婆，她其实关心的只是跟用户签合同和收房租，如果每来一个用户，她都要带着看房、谈价格。对她而言显然是不乐意的。所以中介就出现了，这种重复且非核心的事情，直接交给中介。她就可以专注于签合同和收租。</p><p><img src="1.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Landlady1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 仅仅只是实现了核心的业务功能</span></span><br><span class="line">        System.out.println(<span class="string">"签合同"</span>);</span><br><span class="line">        System.out.println(<span class="string">"收租"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Landlady2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 仅仅只是实现了核心的业务功能</span></span><br><span class="line">        System.out.println(<span class="string">"签合同"</span>);</span><br><span class="line">        System.out.println(<span class="string">"收租"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Intermediary</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.example.*.service())"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPointCut</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"logPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//重复且非核心的事情</span></span><br><span class="line">        System.out.println(<span class="string">"带租客看房"</span>);</span><br><span class="line">        System.out.println(<span class="string">"谈价格"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册过程"><a href="#注册过程" class="headerlink" title="注册过程"></a>注册过程</h3><h4 id="AopAutoConfiguration"><a href="#AopAutoConfiguration" class="headerlink" title="AopAutoConfiguration"></a>AopAutoConfiguration</h4><p>AopAutoConfiguration 这个配置类主要是配置aop的代理类型，默认spring.aop.auto=true。看注释的意思，<code>spring.aop.auto=true</code>为true的时候，通过为配置类添加<code>@EnableAspectJAutoProxy</code>，spring默认就会开启AOP功能。springboot2.0之后AOP代理有三种策略：</p><ul><li>jdk动态代理：当spring.aop.proxy-target-class=false, 引入了aspectjweaver依赖时生效</li><li>cglib代理：当spring.aop.proxy-target-class=true, 引入了aspectjweaver依赖时生效</li><li>基础代理：当spring.aop.proxy-target-class=true, 若没有aspectjweaver依赖时生效，只作用于框架内部的advisors<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.boot.autoconfigure.EnableAutoConfiguration</span></span><br><span class="line"><span class="comment"> * Auto-configuration&#125; for Spring's AOP support. Equivalent to enabling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> EnableAspectJAutoProxy <span class="doctag">@EnableAspectJAutoProxy</span>&#125; in your configuration.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The configuration will not be activated if &#123;<span class="doctag">@literal</span> spring.aop.auto=false&#125;. The</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@literal</span> proxyTargetClass&#125; attribute will be &#123;<span class="doctag">@literal</span> true&#125;, by default, but can be</span></span><br><span class="line"><span class="comment"> * overridden by specifying &#123;<span class="doctag">@literal</span> spring.aop.proxy-target-class=false&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Josh Long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableAspectJAutoProxy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"auto"</span>, havingValue = <span class="string">"true"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为该注解的这个默认值是true，这些都不能省略，我好痛苦</span></span><br><span class="line">    <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>) </span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(Advice<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">class</span> <span class="title">AspectJAutoProxyingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"false"</span>,</span><br><span class="line">matchIfMissing = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAutoProxyConfiguration</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"true"</span>,</span><br><span class="line">matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibAutoProxyConfiguration</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnMissingClass</span>(<span class="string">"org.aspectj.weaver.Advice"</span>)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"true"</span>,</span><br><span class="line">matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassProxyingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ClassProxyingConfiguration(BeanFactory beanFactory) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h4><p>从代码可以看出 @EnableAspectJAutoProxy 引入了 AspectJAutoProxyRegister.class 对象 ，AspectJAutoProxyRegister 给容器中注册一个 AnnotationAwareAspectJAutoProxyCreator：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(AspectJAutoProxyRegistrar<span class="class">.<span class="keyword">class</span>) //引入<span class="title">AspectJAutoProxyRegister</span>.<span class="title">class</span>对象</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAspectJAutoProxy</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//默认使用java接口创建代理，当值为true的时候采用CGlib基于类代理</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//是否通过aop框架暴露该代理对象，AopContext能够访问.</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AspectJAutoProxyRegistrar"><a href="#AspectJAutoProxyRegistrar" class="headerlink" title="AspectJAutoProxyRegistrar"></a>AspectJAutoProxyRegistrar</h4><p>这个类的作用注释写的也很明白， 基于<code>@EnableAspectJAutoProxy</code>注解的情况下，对当前的<code>BeanDefinitionRegistry</code>注册一个<code>AnnotationAwareAspectJAutoProxyCreator</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Registers an org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line"><span class="comment"> * AnnotationAwareAspectJAutoProxyCreator against the current BeanDefinitionRegistry</span></span><br><span class="line"><span class="comment"> * as appropriate based on a given <span class="doctag">@EnableAspectJAutoProxy</span> annotation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">    <span class="comment">//下面的代码是判断是否采用CGlib和通过AOP暴露该代理对象的代码</span></span><br><span class="line">    <span class="comment">//全省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>直接接着看<code>AopConfigUtils</code>, registerAspectJAnnotationAutoProxyCreatorIfNecessary 这个方法，这个方法最后调用到了<code>registerOrEscalateApcAsRequired</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Class&lt;?&gt; cls, BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123; <span class="comment">//如果registry已经包含目标bean</span></span><br><span class="line">        BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">        <span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">            <span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line">            <span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">                apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">    beanDefinition.setSource(source);</span><br><span class="line">    beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    <span class="comment">//否则将beanDefinition注册进registry中,注册名为 AUTO_PROXY_CREATOR_BEAN_NAME</span></span><br><span class="line">    registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">    <span class="keyword">return</span> beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AnnotationAwareAspectJAutoProxyCreator对目标对象进行代理对象的创建，创建代理对象过程中，会先创建一个代理工厂，获取到所有的增强器（通知方法），将这些增强器和目标类注入代理工厂，再用代理工厂创建对象；<br>代理对象执行目标方法，得到目标方法的拦截器链，利用拦截器的链式机制，依次进入每一个拦截器进行执行。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 切面编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题--StrStr()</title>
      <link href="2021/03/23/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-StrStr/"/>
      <url>2021/03/23/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-StrStr/</url>
      
        <content type="html"><![CDATA[<p>昨天和朋友劳(da)逸(you)结(xi)合的时候，朋友告诉我他实现了一个Strstr()。然后我去看了一下，题目难度属于Easy。想着做出来还是简单的，于是立马动手操作了一把。</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>实现 strStr() 函数。</p><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p><p>示例 1:</p><blockquote><p>输入: haystack = “hello”, needle = “ll”<br>输出: 2<br>示例 2:</p><p>输入: haystack = “aaaaa”, needle = “bba”<br>输出: -1</p></blockquote><blockquote id="fn_链接：https://leetcode-cn.com/problems/implement-strstr"><sup>链接：https://leetcode-cn.com/problems/implement-strstr</sup>. 来源：力扣（LeetCode）<a href="#reffn_链接：https://leetcode-cn.com/problems/implement-strstr" title="Jump back to footnote [链接：https://leetcode-cn.com/problems/implement-strstr] in the text."> &#8617;</a></blockquote><p>因为我是一个java党，我拿到这个题目一看，这不就是indexOf吗，于是我优雅的写下了第一行代码。。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> haystack.indexOf(needle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="临界情况"><a href="#临界情况" class="headerlink" title="临界情况"></a>临界情况</h4><p>但是题目的本意显然不是让我们之间调用API，strStr()是C++的API，题目的本意是让我们实现他，短暂思索一下。我就开始了我接下来的思路。<br>既然要返回初始下标，那我直接将字符串转为char[]，通过判断数组下标，返回起始位置,当needle是空串的时候按照API的返回结果默认应该返回0，因此加了一层特殊的条件判断。然后开始思考indexOf如何实现。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] sources = haystack.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] targets = needle.toCharArray();</span><br><span class="line">    <span class="keyword">return</span> indexOf(sources, targets, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来思考临界条件。当targets的长度大于sources长度的时候。那肯定是匹配不上的。因此直接返回-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] sources, <span class="keyword">char</span>[] targets, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (targets.length &gt; sources.length)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理思路"><a href="#处理思路" class="headerlink" title="处理思路"></a>处理思路</h4><p>当满足targets的长度小于等于sources的长度的时候，我需要去寻找targets中第一个元素作为sources第一次出现的位置。如果从头至尾我都找不到这个元素，那么说明匹配不是，直接返回-1，如果我能找到这个元素的下标，则看后面能否完全匹配，若能这个第一次出现的位置就是返回下标。如果后面不完全匹配，那么我可以截取sources中这个<code>下标</code>到<code>sources.length</code>生成一个新的数组，我定义为newsources，重复这个匹配逻辑，如果匹配上，那么返回坐标就是sources中第一次出现的位置加上newsources中第一次出现的位置，如果没匹配上，就重复分割数组，直至<code>匹配成功</code>或者出现上面<code>临界情况</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] sources = haystack.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] targets = needle.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> indexOf(sources, targets, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] sources, <span class="keyword">char</span>[] targets, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (targets.length &gt; sources.length)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//先找到第一个位置</span></span><br><span class="line">        <span class="keyword">char</span> Item = targets[<span class="number">0</span>];</span><br><span class="line">        BREAK:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sources.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sources[i] == Item) &#123;</span><br><span class="line">                fromIndex = i; <span class="comment">//预设定</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; targets.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i == sources.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//这里其实可以优化，当找到第一个位置之后，</span></span><br><span class="line">                    <span class="comment">//直接判断sources剩余长度是不是大于等于targets长度可省略很多次if判断</span></span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (sources[i++] != targets[j]) &#123;</span><br><span class="line">                        fromIndex++;</span><br><span class="line">                        <span class="keyword">break</span> BREAK;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fromIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//全部遍历都找不到第一个元素，返回-1</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> == sources.length)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">int</span> thenIndex = indexOf(Arrays.copyOfRange(sources, fromIndex, sources.length), targets, fromIndex);</span><br><span class="line">        <span class="keyword">return</span> thenIndex == -<span class="number">1</span> ? -<span class="number">1</span> : fromIndex + thenIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面在遍历匹配的时候，我加了一层判断，因为可能sources剩余长度如果小于targets长度，i++之后 sources[i++]有可能会数组越界。这种处理其实不好，可以直接在遍历targets之前判断sources.length-fromIndex是不是比targets.length大。这样可以省略很多次if判断，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sources.length-fromIndex&lt;targets.length)&#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; targets.length; j++) &#123;</span><br><span class="line">    <span class="comment">// if (i != 0 &amp;&amp; i == sources.length - 1) &#123;</span></span><br><span class="line">    <span class="comment">// //这里其实可以优化，当找到第一个位置之后，</span></span><br><span class="line">    <span class="comment">// //直接判断sources剩余长度是不是大于等于targets长度可省略很多次if判断</span></span><br><span class="line">    <span class="comment">//     return -1; </span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">if</span> (sources[i++] != targets[j]) &#123;</span><br><span class="line">        fromIndex++;</span><br><span class="line">        <span class="keyword">break</span> BREAK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其实类似字符串的匹配算法还有很多，比较有名的KMP算法，或者利用哈希表来处理，都是一些解决方案，仅此记录一下我的解法，勿喷勿喷。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百问不厌的乐观锁和悲观锁</title>
      <link href="2021/01/28/%E7%99%BE%E9%97%AE%E4%B8%8D%E5%8E%8C%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/"/>
      <url>2021/01/28/%E7%99%BE%E9%97%AE%E4%B8%8D%E5%8E%8C%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>乐观锁和悲观锁一直都是面试中高频考察点，面试官也喜欢从这类问题去考察面试者的基本功。今天我们就来聊一下乐观锁和悲观锁的实现：<br><code>CAS，Synchronized，ReentrantLock</code>。</p><p>首先要对乐观锁和悲观锁，我们要有一定的概念：</p><ul><li>悲观锁：悲观的认为只要不做正确的数据同步措施，它就一定会出问题</li><li>乐观锁：乐观的认为不需要去采取同步措施也不会出问题，如果出现问题，再去补救</li></ul><p>那具体通过哪些方式去才取同步呢，在多线程中，同步机制主要分为以下四种，具体的区别以后再讲：</p><ul><li>互斥量：为协调共同对一个共享资源的单独访问而设计的。</li><li>临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。</li><li>临界量：为控制一个具有有限数量用户资源而设计。</li><li>事件：用来通知线程有一些事件已发生，从而启动后继任务的开始。</li></ul><h3 id="互斥（同步阻塞）悲观锁"><a href="#互斥（同步阻塞）悲观锁" class="headerlink" title="互斥（同步阻塞）悲观锁"></a>互斥（同步阻塞）悲观锁</h3><p>互斥只是同步机制的其中一个手段，也是很常见的保障并发正确性的手段<br>我们知道传统的锁（如<code>synchronized</code>或者<code>ReentrantLock</code>）之所以被称为重量级锁，就是因为他使用操作系统互斥量来实现同步。</p><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>synchronized能实现同步的基础：也是因为在java中，所有对象都可以作为锁。</p><p>具体表现为以下3种形式。</p><ul><li>对于普通同步方法，锁是当前实例对象。</li><li>对于静态同步方法，锁是当前类的Class对象。</li><li>对于同步方法块，锁是Synchonized括号里配置的对象。</li><li>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</li></ul><p>synchronized是基于<code>Monitor</code>来实现同步的。当<code>synchronized</code>经过编译之后，<strong>会在<code>同步块</code>的前后分别形成<code>monitorenter</code>和<code>monitorexit</code>指令</strong>。</p><ul><li>每个monitor维护着一个记录着拥有次数的计数器。未被拥有的monitor的该计数器为0</li><li>当执行进入monitorenter时，锁计数器就会+1，当执行到monitorexit,锁计数器就会-1。当锁计数器为0的时候，锁就会被释放</li><li>synchronized不会出现自己死锁自己的情况，因为对于已经进入同步块的线程，synchronized锁是可重入的</li><li>在synchronized同步代码块执行完，会阻塞其他线程进入同步锁（排他锁）</li><li>对于<code>同步方法</code>，<code>synchronized</code>同步方式是通过方法中的access_flags中设置<code>ACC_SYNCHRONIZED</code>标志来实现</li></ul><p>并且，随着JDK6对<code>synchronized</code>进行了各种优化之后，有些情况下synchronized就并不那么重,JDK6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁。<br>针对<code>synchronized</code>获取锁的方式，JVM 使用了锁升级的优化方式，就是先使用偏向锁优先同一线程然后再次获取锁，如果失败，就升级为 CAS 轻量级锁，如果失败就会短暂自旋，防止线程被系统挂起。最后如果以上都失败就升级为重量级锁。并且锁只能向上升级，不能降级。</p><p><img src="11.png" alt=""></p><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>实现ReentrantLock的基础是AQS( AbstractQueuedSynchronizer 队列同步器)，AQS 有一个 state 标记位，值为<code>1</code>时表示有线程占用，其他线程需要进入到同步队列等待，同步队列是一个双向链表。<br>当获得锁需要等待某个条件时，会进入condition队列，进入等待队列的可以有很多个。当满足condition的条件的时候，线程就会重新竞争锁资源。<br>ReentrantLock 内部有公平锁和非公平锁两种实现，差别就在于新来的线程是否比已经在同步队列中的等待线程更早获得锁。</p><p><img src="12.png" alt=""></p><p>ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。<br>它有公平锁FairSync和非公平锁NonfairSync两个子类。<br>ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p><h3 id="非阻塞同步（乐观锁）"><a href="#非阻塞同步（乐观锁）" class="headerlink" title="非阻塞同步（乐观锁）"></a>非阻塞同步（乐观锁）</h3><h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>CAS(Compare And Swap)是一种乐观锁的实现方式。是一种轻量级锁，JUC 中很多工具类的实现都是基于<code>CAS</code>的。CAS操作包含三个操作数—— 内存位置的值（V）、预期原值（A）和新值（B）。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值。</p><p><img src="13.png" alt=""></p><p>但是这种情况，当数据被其他线程修改，就会出现一直循环。导致CPU资源一直消耗过多。除此之外<code>CAS</code>本身还存在<code>ABA问题</code>。即线程一读取数据A，线程二也读取数据A，线程二通过CAS比较发现数据是A，于是将A写回B，线程三读取B，线程三通过CAS比较发现数据是B没有被操作过，又将数据写回A，此时线程一读到的是A，会以为数据没有改变过。对于ABA问题，通过控制变量值的<code>版本号</code>（自增字段或者时间戳）来保证CAS的正确性。具体解决思路就是在变量前追加上版本号，每次变量更新的时候把版本号加一，那么A - B - A就会变成1A - 2B - 3A。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>今日偷懒，不写总结。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单聊一下volatile</title>
      <link href="2021/01/06/%E7%AE%80%E5%8D%95%E8%81%8A%E4%B8%80%E4%B8%8Bvolatile/"/>
      <url>2021/01/06/%E7%AE%80%E5%8D%95%E8%81%8A%E4%B8%80%E4%B8%8Bvolatile/</url>
      
        <content type="html"><![CDATA[<p>开始讲这个题目之前，先来聊一下什么是线程安全。多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是<code>线程安全</code>的。</p><p>这是一个很常见的面试题，再接着往下深入一点，如何保证线程安全呢？线程安全一般是从三个方面考虑：</p><ul><li>原子性: <code>synchronized</code>确保同一时间只有一个线程能拿到锁,进入当前代码块</li><li>可见性：<code>volatile</code>保证不同线程对共享变量操作的可见性,<code>synchronized</code>获得锁后会清空工作内存，从主存拷贝最新的变量到工作内存(副本)，再将修改后的副本重新刷到主存中，然后释放锁，其他没有获得锁的线程都处于阻塞状态，因此也能保证数据可见性。</li><li>有序性：<code>volatile</code>本身就具有指令重排序，<code>synchronized</code>和<code>Lock</code>保证每个时刻是有一个线程执行同步代码，自然就保证了有序性。</li></ul><p>说完这些我们开始看一个控制台小程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> maybelence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@descrpition</span> a demo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-01-05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; fun = System.out::println;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.start();</span><br><span class="line">        <span class="keyword">while</span> (!test.isFlag())&#123; &#125;</span><br><span class="line">        fun.accept(<span class="string">"你真厉害"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">"flag is "</span>+ flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台打印的是<code>flag is true</code>，现在应该不足为奇了。那如何让计算机对你说“你真厉害”呢。这时候应该可以胸有成竹的选择volatile或者synchronized。<br>先来看一下synchronized实现。<br>我这里大致写了一下,这里只有第一种会打印“你真厉害”，但是第二种并不会打印。第一种每循环一次都会获取一次锁，当执行完成之后，会将flag值从工作内存刷新到主存中。但是第二种，他在获取锁的时候，flag仍然是false的，然后就进入了无限死循环。并不会将flag值更新到主存中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; fun = System.out::println;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.start();</span><br><span class="line">        <span class="keyword">while</span> (!test.isFlag()) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (test) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fun.accept(<span class="string">"你真厉害"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testmain</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; fun = System.out::println;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.start();</span><br><span class="line">        <span class="keyword">synchronized</span> (test) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!test.isFlag()) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fun.accept(<span class="string">"你真厉害"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>现在来看一下加volatile修饰的方式,每个线程在操作数据的时候，会将数据从主内存中拷贝一份副本到当前线程的工作内存，如果该线程对于副本操作，并且写回了。<br>那么其他线程所取得的副本就失效了。需要对数据操作的话就又得从主存中重新读取。而volatile可以保证不同线程对于该变量的可见性，也就是当一个线程对于该数据操作之后，并写回主存，其他线程就可以立即获得该变量最新的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">"flag is "</span>+ flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那当有多个线程同时对<code>flag</code>进行操作，那刷新到主存中以谁的数据为准呢？对于这种缓存不一致性问题，通常有两种方式：</p><ul><li>通过在总线加LOCK#锁的方式（锁总线）</li><li>通过某些缓存一致性协议（锁缓存）</li></ul><h3 id="锁总线"><a href="#锁总线" class="headerlink" title="锁总线"></a>锁总线</h3><p>CPU总线是CPU与所有芯片连接的主干道，当一个CPU要操作数据的时候，它向总线发送一个<code>LOCK#</code>的信号，其他处理器就会处于阻塞状态。从而使该CPU可以独享此共享内存。但是锁总线会导致其他CPU与共享内存之间的通信被锁住，导致对其他共享内存的数据也无法操作，因此开销较大。</p><h3 id="锁缓存"><a href="#锁缓存" class="headerlink" title="锁缓存"></a>锁缓存</h3><p>以在Intel系列中广泛使用的MESI协议为例，当CPU操作数据的时候，如果发现该变量是一个共享变量，即在其他处理器中也存在该变量的副本。那么就会发信号告知该CPU将该变量的缓存行置为无效状态。当其他CPU需要读取这个数据的时候，会查看该变量是否是失效状态，如果是失效状态，会重新从共享内存中重新读取该变量的值。至于CPU是如何发现数据是否已经过期。是CPU通过<code>嗅探</code>在总线上传播的数据来检查自己的缓存是否过期。当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行置为失效状态，当处理器需要对这个数据进行<code>读取(操作)</code>的时候，会重新从系统内存中读取该数据。</p><blockquote><p>由于volatile的mesi缓存一致性协议需要不断的从主内存嗅探和cas不断循环无效交互导致总线带宽达到峰值<code>(总线风暴)</code>。因此不要大量使用volatile。</p></blockquote><h2 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h2><blockquote><p>为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。</p></blockquote><p>一段源码，到最后执行，需要经历那些重排序规则呢？</p><p><img src="00.png" alt="源码到执行指令经历的重排序"></p><p>一个好的内存模型，会尽可能小的去约束处理器和编译器，在不改变程序执行结果的情况下，尽可能提高程序的执行效率。因此JMM会尽量减少对底层的约束，使其能够发挥自身优势。</p><p>一般重排序分为以下三种：</p><ul><li>编译器的重排序：编译器在不改变单线程语义的情况下，可以重新定义语句执行顺序</li><li>指令集并行的重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</li><li>内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的</li></ul><p>这里要提到一个概念：<code>as-if-serial</code>。</p><blockquote><p>不管怎么重排序，单线程下的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p></blockquote><h3 id="Volatile如何禁止重排序"><a href="#Volatile如何禁止重排序" class="headerlink" title="Volatile如何禁止重排序"></a>Volatile如何禁止重排序</h3><p>java编译器会在生成指令系列时在适当的位置会插入<code>内存屏障</code>指令来禁止特定类型的处理器重排序。并且为了实现volatile的内存语义，为了实现volatile的内存语义，JMM会限制特定类型的编译器和处理器重排序，JMM会针对编译器制定volatile重排序规则表：</p><div class="table-container"><table><thead><tr><th>能否重排序</th><th></th><th><strong>第二个操作</strong></th><th></th></tr></thead><tbody><tr><td><strong>第一个操作</strong></td><td>普通读（写）</td><td>volatile（读）</td><td>volatile（写）</td></tr><tr><td>普通读（写）</td><td></td><td></td><td>NO</td></tr><tr><td>volatile（读）</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>volatile（写）</td><td></td><td>NO</td><td>NO</td></tr></tbody></table></div><blockquote><p>volatile<code>写</code>是在<code>前面和后面</code>分别插入内存屏障，而volatile<code>读</code>操作是在<code>后面插入两个</code>内存屏障。</p></blockquote><p><img src="01.png" alt="volatile写"></p><p><img src="02.png" alt="volatile读"></p><p>上述重排序规则，为了提高处理速度，JVM往往会对代码进行指令重排序优化。并发编程下指令重排序会带来一些安全隐患：如指令重排序导致的多个线程操作之间的不可见性。</p><p>从JDK5开始，提出了<code>happens-before</code>的概念，通过这个概念来阐述操作之间的内存可见性。</p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。<br><code>volatile域规则：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读。</code><br>如果现在我的变了flag变成了false，那么后面的那个操作，一定要知道我变了。</p><p>一定要记住<code>volatile无法保证原子性</code>，如果非要保证原子性，可以采用concurrent包下的一些原子类或者给加锁。关于volatile的应用，可以看之前有一篇讲单例的文章<a href="/2020/09/25/那些年我们学过的设计模式，你还记得几个（一）/">2020-09-25-那些年我们学过的设计模式，你还记得几个（一）</a>。</p><h3 id="volatile和synchronized的区别"><a href="#volatile和synchronized的区别" class="headerlink" title="volatile和synchronized的区别"></a>volatile和synchronized的区别</h3><ul><li>volatile只能修饰实例变量和类变量，而synchronized可以修饰方法，以及代码块。</li><li>volatile保证数据的可见性，但是不保证原子性(多线程进行写操作，不保证线程安全);而synchronized是一种排他(互斥)的机制。</li><li>volatile用于禁止指令重排序：可以解决单例双重检查对象初始化代码执行乱序问题。</li><li>volatile可以看做是轻量版的synchronized，volatile不保证原子性，但是如果是对一个共享变量进行多个线程的赋值，而没有其他的操作，那么就可以用volatile来代替synchronized，因为赋值本身是有原子性的，而volatile又保证了可见性，所以就可以保证线程安全了。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>volatile修饰符适用于以下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值，比如booleanflag;或者作为触发器，实现轻量级同步。</p></li><li><p>volatile属性的读写操作都是无锁的，它不能替代synchronized，因为它没有提供原子性和互斥性。因为无锁，不需要花费时间在获取锁和释放锁_上，所以说它是低成本的。</p></li><li><p>volatile只能作用于属性，我们用volatile修饰属性，这样compilers就不会对这个属性做指令重排序。</p></li><li><p>volatile提供了可见性，任何一个线程对其的修改将立马对其他线程可见，volatile属性不会被线程缓存，始终从主存中读取。</p></li><li><p>volatile提供了happens-before保证，对volatile变量v的写入happens-before所有其他线程后续对v的读操作。</p></li><li><p>volatile可以使得long和double的赋值是原子的。</p></li><li><p>volatile可以在单例双重检查中实现可见性和禁止指令重排序，从而保证安全性。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈红黑树</title>
      <link href="2020/11/05/%E6%B5%85%E8%B0%88%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>2020/11/05/%E6%B5%85%E8%B0%88%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>在网上很多博客上面看到有些讲红黑树的文章都不能完整描述它的体系，对于树的调平染色也没有很详细的介绍，因此让很多人觉得红黑树很难理解。但红黑树的应用场景还是很常见的。</p><p>JAVA8中HashMap的底层实现，就为了解决过度哈希冲突而造成的长链表，从而将链表转换为红黑树；Linux中的CFS进程调度算法，vruntime利用红黑树来存储；多路复用EPoll核心结构也是采用红黑树和双向链表来存储。</p><p>了解红黑树的结构，有助于我们去理解一些底层实现，并且红黑树本身也是对树结构的一种高度应用。包括多叉树、树平衡调整、树节点旋转。其实红黑树的本质就是对2-3-4树的概念模型一种具体实现。</p><h3 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h3><p>2-3-4树是<code>阶数</code>为4的B树，B树，全名BalanceTree，平衡树。这种结构主要用来做查找。它最重要的特性在于平衡，这使得我们能够在最坏情况下也保持O(LogN)的时间复杂度实现查找（一个不具备平衡性的查找树可能退化成单链表，时间复杂度会到O（N））。</p><blockquote><p>平衡的定义是说从空链接到根节点距离相等，此处一定要用心理解。（也就是说非叶子节点是不会存在空链接的）</p></blockquote><p>因为2-3-4是一个<code>阶数</code>为4的数，所以他会存在以下几个节点：</p><ul><li>2结点 2节点中存放着一个key[X]，两个指针，分别指向小于X的子节点和大于X的子节点；</li><li>3结点 3节点中存放在两个key[X,Y],三个指针，分别指向小于X的子节点，介于X~Y之间的子节点和大于Y的子节点；</li><li>4结点 4节点中存放在两个key[X,Y,Z],四个指针，理论同上</li></ul><p><img src="49.png" alt="2-3-4数图解"></p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是对概念模型2-3-4树的一种实现，由于直接进行不同节点间的转化会造成较大的开销，所以选择以二叉树为基础，在二叉树的属性中加入一个<code>颜色</code>属性来表示2-3-4树中不同的节点。<br>2-3-4树中的2节点对应着红黑树中的<code>黑色节点</code>，而2-3-4树中的非2节点是以<code>红节点+黑节点</code>的方式存在，红节点的意义是与黑色父节点结合，表达着2-3-4树中的3，4节点。</p><p>我们先看2-3-4树到红黑树的节点转换。2节点直接转化为黑色节点；3节点这里可以有两种表现形式，左倾红节点或者右倾红节点。而4节点被强制要求转化为一个黑父带着左右两个红色儿子。</p><p><img src="50.png" alt="2-3-4树转红黑树"></p><p>本文主要针对2-3树的左倾红黑树进行探讨，也就是说，如果一个树中出现了<code>红色</code>结点，那么这个结点一定是<code>左儿子</code>，这也是<code>算法4</code>中给出的红黑树的实现方式。</p><ul><li>这种实现方式不用考虑2-3-4树中复杂的4节点分裂</li><li>这种限定能够很大的减少红黑树调整过程中的复杂性</li></ul><p><img src="51.png" alt="2-3树转红黑树"></p><p>如果说这样还是比较抽象的话，那下面这个左倾红黑树转2-3树应该能够清晰的描绘他们之间的关系了。</p><p><img src="52.png" alt="左倾红黑树转2-3树"></p><p>在了解红黑树的插入删除操作之前，我们需要先了解2-3树的插入删除操作，才能理解红黑树中染色和旋转背后的意义。插入操作需要遵循一个原则：</p><blockquote><p>先将这个元素尝试性地放在已经存在的节点中，如果要存放的节点是2节点，那么插入后会变成3节点，如果要存放的节点是3节点，那么插入后会变成4节点（临时）。<br>然后对可能生成的临时4节点进行分裂处理，使得临时4节点消失。</p></blockquote><p><img src="53.jpg" alt="2-3-4树插入(1)"><br><img src="54.jpg" alt="2-3-4树插入(2)"></p><p>正对应了红黑树在插入的时候一定会把待插入节点涂成红色，因为红色节点的意义是与<code>父节点</code>进行关联，形成概念模型2-3树中的3节点或者临时4节点。</p><p>而红黑树之所以需要在插入后进行调整，正是因为可能存在着概念模型中的临时4节点（反应在红黑树中是双红的情况）。</p><p>试想在2-3树中如果待插入节点是个2节点，那么反应在红黑树中，不正好对应着黑色父节点吗，在黑色父节点下面增加一个红色儿子，确实不会违背红黑树的任何规则，这也对应着我们向2-3树中的2节点插入一个元素，只需要简单的把2节点变成3节点。</p><p>接下来让我们来看一下对于2-3树的删除。对于2-3树的删除我们主要要考虑待删除元素在2节点这种情况，因为如果待删除元素在3节点，那么可以直接将这个元素删除，而不会破坏2-3树的任何性质（删除这个元素不会引起高度的变化）。</p><p>当待删除元素在2节点的时候，由于删除这个元素会导致2节点失去自己唯一的元素，引发2节点自身的删除，会使得树中某条路径的高度发生变化，树变得不平衡。<br>因此我们有两种方案去解决这个问题：</p><ul><li>先删除这个2节点，然后对树进行平衡调整。</li><li>想办法让这个被删除的元素不可能出现在2节点中。</li></ul><p>这里选择第二种方案，我们在搜索到这个节点的路径中，不断地判断当前节点是否为2节点，如果是，就从它的兄弟节点或者它的父节点借一个元素，使得当前节点由2节点成为一个3节点或者一个临时4节点（视具体情况而定，在后面的红黑树部分会详细介绍）。</p><p>这种操作会产生一种结果：除非当前节点是根节点，否则当前节点的父节点一定是一个非2节点（因为搜索的路径是自上而下，父节点已经进行过了这种操作，所以不可能是2节点），那么我们可以保证到达叶子节点的时候，也能顺利的从父节点或者兄弟节点处借到元素，使得自己成为非2节点。从而能够直接删除某个元素（现在这个元素不在2节点中了）。</p><p><img src="55.jpg" alt="2-3树的删除"></p><h3 id="再品红黑树"><a href="#再品红黑树" class="headerlink" title="再品红黑树"></a>再品红黑树</h3><p><img src="56.png" alt="红黑树中的红黑结点"></p><p>来品一下红黑树的5条定义</p><ul><li><p>红黑树结点颜色的有黑色和红色</p><blockquote><p>2-3树到红黑树的转化已经详细说明</p></blockquote></li><li><p>根结点一定是黑色</p><blockquote><p>2-3树中如果根节点为2节点，那么它本来就对应红黑树中黑节点；如果根节点为3节点，也可以用黑色节点表示较大的那个元素，然后较小的元素作为左倾红节点存在于红黑树中</p></blockquote></li><li><p>所有叶子节点都是黑色</p><blockquote><p>这里的叶子其实是空链接</p></blockquote></li><li><p>任意节点到叶子节点经过的黑色节点数目相同</p><blockquote><p>红黑树中的红节点是和黑色父节点绑定的，在2-3树中本来就是同一层的，只有黑色节点才会在2-3树中真正贡献高度，由于2-3树的任一节点到空链接距离相同，因此反应在红黑树中就是<code>黑色完美平衡</code></p></blockquote></li><li><p>不会有连续的红色节点</p><blockquote><p>2-3树中本来就规定没有4节点，2-3-4树中虽然有4节点，但是要求在红黑树中体现为一黑色节点带两红色儿子，分布左右，所以也不会有连续红节点</p></blockquote></li></ul><hr><blockquote><p>现在就能看的出来红黑树的定义背后正浮现着一颗2-3树概念模型。虽然我们已经有了这样的认识，但是红黑树作为真正的实现模型，我们还是要回到这个实现本身来探究它的一系列操作</p></blockquote><h4 id="作为二叉查找树"><a href="#作为二叉查找树" class="headerlink" title="作为二叉查找树"></a>作为二叉查找树</h4><p>二叉查找树的节点有一个元素X和两个指针域，左指针指向小于X的元素，右指针指向大于X的元素。</p><p>假设我们的插入序列是1~10，那么这颗树会演变成只有右链接的形式，树高会增加到10层，这个时候已经不具备O(LogN)的查找时间复杂度，因为这颗树退化成了链表。</p><p>因此对二叉树进行平衡调整是很重要的一个环节，无论是AVL还是红黑树，它们本质上都是希望尽可能保证这颗二叉查找树中的元素尽量均衡的分布在树的两侧。</p><p>当我们向一颗二叉查找树中插入一个元素Y的时候，我们会一直与树中的节点进行大小比较，如果Y小于当前元素，就往左走，如果Y大于当前元素，就往右走，直到达到叶子节点，这个时候我们可以把Y插入这颗二叉查找树了。</p><p>由于这次的插入动作，整棵树可能会发生一些不平衡，因此我们需要在插入后进行一次平衡调整，使得整棵树恢复到平衡的状态（具体如何调整，要看树是AVL还是红黑树亦或是其他的平衡树）。</p><p>二叉查找树的删除是一个很有意思的问题，不同于插入的是，待删除的元素并不能保证一定出现在树中的叶子节点。这将带来一个棘手的情景，即我们需要从树的中间部分取走一个元素，而且在取走后还需要经过调整来使得整颗树满足平衡的性质。从树的中间部分直接取走一个节点的场景实在是太多，也牵扯到了太多相关的节点，这种操作很难实现。</p><p>好在有人提出了一个观点，我们对查找树中一个节点的删除，其实可以不必真的改动这个节点的位置。由于查找树的特殊性质，将某个元素节点删除后，它有两个最佳替代者，分别是有序序列中的前驱元素和后继元素。</p><p>我们还是以一个包含元素1~10的二叉查找树为例，如果我们希望删除5所在的节点，那么让4或者6替代它的位置都是可行的。作为前驱元素的4，会存放在5所在节点的左子树的最右侧；作为后继元素的6，会存放在5所在节点的右子树的最左侧。</p><p>关于这个结论，大家只需稍加思索便可以明白。</p><p>现在我们又让问题简化了，也就是说，删除某个节点的时候，我们先找到它的前驱元素或者后继元素（随便选一个），将它的前驱元素直接填到待删除的节点，然后再把它的前驱元素或者后继元素删除。</p><p>这个时候问题就转化成了在二叉查找树中删除一个没有左子树的节点（或者是一个没有右子树的节点），我们只需要将这个节点删除再进行对应的平衡调整即可（虽然还是需要调平，但是比直接在树中层删除一个同时具备左右儿子的节点要容易很多）。</p><p>注意，此处并没有强调是针对红黑树的操作，因为红黑树和AVL都是二叉查找树，它们都适用这个方法。</p><h4 id="树的旋转"><a href="#树的旋转" class="headerlink" title="树的旋转"></a>树的旋转</h4><p>为了调平一颗二叉树，使得其左右节点数目分布均匀，通常会选择旋转的手段。你可以把一颗二叉树某节点的左右子树想象成天平上待称量的物品，如果哪边重了，我们就从重的那边拿出一部分，加到轻的那边，以此保持相对的平均。</p><p>以X为旋转点的左旋</p><p><img src="58.png" alt="左旋调平"></p><p>以X为旋转点的右旋</p><p><img src="59.png" alt="右旋调平"></p><p>理解了这些之后，再去看红黑树的插入删除，就能够理解旋转和染色背后的意义了。我们仍然选择算法4中的左倾红黑树作演示：首先看<code>插入</code></p><h4 id="左倾红黑树的插入"><a href="#左倾红黑树的插入" class="headerlink" title="左倾红黑树的插入"></a>左倾红黑树的插入</h4><p><img src="60.png" alt="红黑树基树"></p><p>对于上述左倾红黑树的插入一共有三种可能的情况：</p><ul><li>待插入元素比黑父大，插在了黑父的右边，而黑父左边是红色儿子。这种情况会导致在红黑树中出现右倾红节点。</li></ul><p>这种情况对应着2-3树中出现了临时4节点，我们在2-3树中的处理是将这个临时4节点分裂，左右元素各自形成一个2节点，中间元素上升到上层跟父节点结合。所以，我们在红黑树中的动作是，将原本红色的左右儿子染黑（左右分裂），将黑父染红（等待上升结合）。</p><p><img src="61.png" alt="红黑树基于黑叔插入图1"></p><ul><li>待插入元素比红父小，且红父自身就是左倾。听起来有点绕，看图就会明白，其实就是说红父和待插入元素同时靠在了左边，形成了连续的红节点。</li></ul><p>这种情况我们需要用两步来调整。由于我们插入的是红色节点，其实不会破坏黑色完美平衡，所以要注意的是在旋转和染色的过程种继续保持这种完美黑色平衡。<br>首先对红父的父亲进行一次右旋，这次右旋不会破坏黑色平衡，但是也没有解决连续红色的问题。<br>接下来将12所在节点与15所在节点交换颜色，这样的目的是为了消除连续红色，并且这个操作依旧维持了黑色平衡。现在我们已经得到了情况1的场景，直接按情况1处理即可。</p><p><img src="62.png" alt="红黑树基于黑叔插入图2"></p><ul><li>待插入元素比红父大，且红父自身就是左倾。</li></ul><p>也就是说插入的这个节点形成了一个右倾的红色节点，对右倾的处理很简单，将红父进行一次左旋，就能使得右倾红节点变为左倾，现在出现了连续的左倾红节点，直接按情况2处理即可。</p><p><img src="63.png" alt="红黑树基于黑叔插入图3"></p><p>在插入时，可以体会到左倾红黑树对于左倾的限制带来的好处，因为在原树符合红黑树定义的情况下，如果父亲是红的，那么它一定左倾，同时也不用考虑可能存在的右倾兄弟（如果有，那说明原树不满足红黑树定义）。</p><p>这种限制消除了很多需要考虑的场景，让插入变得更加简单。</p><h4 id="左倾红黑树的删除"><a href="#左倾红黑树的删除" class="headerlink" title="左倾红黑树的删除"></a>左倾红黑树的删除</h4><p>左倾红黑树的删除需要借鉴之前提到的<code>二叉查找树通用的删除</code>策略，当我们要删除某个节点的时候选择它的前驱节点或者后继节点元素来替代它，转而删除它的前驱/后继节点。</p><p>这里我们用<code>后继节点</code>来替代被删除节点。</p><p>假设我们需要删除的节点它的右子树如图所示，那么对该节点的删除实际上转为了对2的删除。</p><p>我们从当前的根节点出发，利于2-3树中预合并的策略逐层对红黑树进行调整。具体的做法是，每次都保证当前的节点是2-3树中的非2节点，如果当前节点已经是非2节点，那么直接跳过；如果当前节点是2节点，那么根据兄弟节点的状况来进行调整：</p><ul><li><p>如果兄弟是2节点，那么从父节点借一个元素给当前节点，然后与兄弟节点一起形成一个临时4节点。</p></li><li><p>如果兄弟是非2节点，那么兄弟上升一个元素到父节点，同时父节点下降一个元素到当前节点，使得当前节点成为一个3节点。</p></li></ul><p>这样的策略能够保证最后走到待删除节点的时候，它一定是一个非2节点，我们可以直接将其元素删除。</p><p><img src="64.png" alt="左倾红黑树的删除"></p><p>接下来要考虑的是修复工作，由于红黑树定义的限制，我们在调整的过程中出现了一些本不该存在的<code>红色右倾节点</code>（因为生成了概念模型中的临时4节点），于是我们顺着搜索的方向向上<code>回溯</code>，如果遇到当前节点具备右倾的红色儿子，那么对当前节点进行一次左旋，这时原本的右儿子会来到当前节点的位置，然后将右儿子与当前节点交换颜色，我们就将右倾红节点修复成了左倾红节点，同时我们并没有破坏黑色节点的平衡。</p><p><img src="65.png" alt="左倾红黑树修复"></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul><li>你知道了红黑树的五条定义，如果我构造一颗只有黑色节点的红黑树，这样子可行吗？因为这样子没有破坏任何一条红黑树的规则。</li><li>那么请问红黑树中要红节点干什么呢？红节点的真实意义是什么呢？</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红黑树 </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一下最近刷题的一些小想法</title>
      <link href="2020/10/30/%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%AF%E6%80%A7%E6%80%9D%E7%BB%B4/"/>
      <url>2020/10/30/%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%AF%E6%80%A7%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<p>事情的起因还是要从我昨天上班赚（mo）钱（yu）开始说起，最近项目比较闲，于是我在intelij上面装了一个leetcode插件，每天日常刷一刷leetcode题。就在昨天，我刷到了这样一题</p><hr><p>给定一个较长字符串<code>big</code>和一个包含较短字符串的数组<code>smalls</code>，设计一个方法，根据<code>smalls</code>中的每一个较短字符串，对<code>big</code>进行搜索。输出<code>smalls</code>中的字符串在<code>big</code>里出现的所有位置<code>positions</code>，其中<code>positions[i]</code>为<code>smalls[i]</code>出现的所有位置。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">big &#x3D; &quot;mississippi&quot;</span><br><span class="line">smalls &#x3D; [&quot;is&quot;,&quot;ppi&quot;,&quot;hi&quot;,&quot;sis&quot;,&quot;i&quot;,&quot;ssippi&quot;]</span><br><span class="line">输出： [[1,4],[8],[],[3],[1,4,7,10],[5]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= len(big) &lt;= 1000</code></li><li><code>0 &lt;= len(smalls[i]) &lt;= 1000</code></li><li><code>smalls</code>的总字符数不会超过 100000。</li><li>你可以认为<code>smalls</code>中没有重复字符串。</li><li>所有出现的字符均为英文小写字母。</li></ul><p><strong>解法：</strong></p><p>看到判断字符串在母串的位置，很容易让人想到indexOf(str)，我们可以记录indexOf(str)返回值，但<code>smalls</code>中特定位的字符在<code>big</code>出现的次数是未知数x，所以可以用一个可变数组List来存储这个字符在<code>big</code>中出现的次数。而indexOf(str)默认返回的是str在母串中第一次的索引值，String还提供了indexOf(str,index)来记录从第一个开始的索引值，因此可以采用indexOf(str,index+1)来避免记录重复值。<br>所以解法就很简单，先用indexOf获取索引值，然后存储在一个长度可变的数组List中，接着讲List再转成固定长度数组，返回给result[i]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] multiSearch(String big, String[] smalls) &#123;</span><br><span class="line">        <span class="keyword">int</span> [][] result = <span class="keyword">new</span> <span class="keyword">int</span> [smalls.length][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; smalls.length ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">""</span>.equals(big))&#123;</span><br><span class="line">                result[i] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!smalls[i].equals(<span class="string">""</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> index = big.indexOf(smalls[i]);</span><br><span class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span> (index&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    list.add(index);</span><br><span class="line">                    index = big.indexOf(smalls[i],index+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                result[i] = parseList2Array(list);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                result[i] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parseList2Array(List&lt;Integer&gt; list)&#123;</span><br><span class="line">        <span class="keyword">int</span> [] index = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size() ; i++) &#123;</span><br><span class="line">            index[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题很简答，但是我越刷(mo yu)越开心，又刷到了这样一题。</p><hr><p> 给定字符串<code>J</code> 代表石头中宝石的类型，和字符串 <code>S</code>代表你拥有的石头。 <code>S</code> 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p><p><code>J</code> 中的字母不重复，<code>J</code> 和 <code>S</code>中的所有字符都是字母。字母区分大小写，因此<code>&quot;a&quot;</code>和<code>&quot;A&quot;</code>是不同类型的石头。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J &#x3D; &quot;aA&quot;, S &#x3D; &quot;aAAbbbb&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J &#x3D; &quot;z&quot;, S &#x3D; &quot;ZZ&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>S</code> 和 <code>J</code> 最多含有50个字母。</li><li><code>J</code> 中的字符不重复。</li></ul><p>我直接一波惯性思维，想到了indexOf真香(主要简单)，把<code>J</code>拆成char[],那每个char[i],不就相当于上一题里面的small[i]吗，这样一想，其实还是在母串里找每个字符出现的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] charArray = J.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> item: charArray) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = S.indexOf(item);</span><br><span class="line">        <span class="keyword">while</span> (index&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            result++;</span><br><span class="line">            index = S.indexOf(item,index+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答出来之后，我就开始思考有没有其他方法可以更简单或者更快的解决这个题目。还是从刚刚这个思路切入，把<code>J</code>切成char[]，因为<code>S</code>中的char[i]可能是多个，所以还需要像上一题这样多次搜索，但是<code>J</code>中的元素是不会重复的，如果把<code>S</code>拆成char[]，那么对应可以直接在<code>J</code>中进行一次搜索，而且因为不需要取索引值，所以可以直接用J.contains(char[i])，看返回的布尔值，实现计数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] charArray = S.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> item: charArray) &#123;</span><br><span class="line">        <span class="keyword">if</span>(J.contains(item+<span class="string">""</span>))&#123;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步思考，既然<code>J</code>的每个元素都不相同，那么我们可以采用元素都不重复的集合Set来存储J的每一个元素。不过这样需要对两个字符串都转数组，虽然简单但是感觉不如上述代码简洁。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] chars = J.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> item: chars) &#123;</span><br><span class="line">        set.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(S.charAt(i)))</span><br><span class="line">            result++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完这些，是不是突然发现，既然是用<code>J</code>中的每一个字符去挨个遍历<code>S</code>中的每一个字符。那么最粗暴的方法当然是双重for循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> Jitem : J.toCharArray())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> Sitem : S.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(Jitem == Sitem)&#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法虽然简单，但是这样效率极低极低，这样的写法相当于是把整个<code>J</code>和整个<code>S</code>都遍历了一遍，相当于执行了<code>J.length*S.length</code>次。因为这里<code>J</code>的每一个字符都是唯一不重复的。那么我们可以用<code>S</code>去匹配<code>J</code>,找到自己break当前小循环直接进入下一次大循环，就会少一些遍历<code>J</code>中剩下的字符次数，相对而言就会少执行很多次循环体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> Sitem : S.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> Jitem : J.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span>(Jitem == Sitem)&#123;</span><br><span class="line">                    result++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>快乐的上班(mo yu)时光总是很短暂，下班啦~~~~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收与内存分配</title>
      <link href="2020/09/27/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>2020/09/27/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，外面的人想进来，里面的人想出去。</p><blockquote id="fn_引用"><sup>引用</sup>. 《深入理解JAVA虚拟机》<a href="#reffn_引用" title="Jump back to footnote [引用] in the text."> &#8617;</a></blockquote><p>JAVA相对于C/C++而言引入了GC机制，使程序员更加去关注程序本身，不需要再对每个new的对象去进行delete/free操作。C++就好像你在家里自己恰饭，需要去自己做好。吃完之后还要自己收拾。而JAVA更像是在餐厅中吃饭，你不需要去关注饭是如何做好的，以及吃完以后服务员是如何收拾的，你只要负责享用美食就可以了。</p><hr><h2 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h2><p>了解GC之前，我们需要先了解JVM的内存模型，搞清楚被回收的数据一般存在在哪些区域。</p><p><img src="jvmncqy.png" alt="JVM内存区域"></p><ul><li>虚拟机栈：描述方法执行时的内存模型，属于线程私有，生命周期同线程一样。主要保存执行方法时的局部变量表、操作数栈、动态连接和方法返回地址等信息,方法执行时入栈，方法执行完出栈，出栈之后数据清空，不需要GC。</li><li>本地方法栈：主要存储虚拟机调用native方法/服务相关信息。大体逻辑和虚拟机栈相同，也不需要GC。</li><li>程序技术器：主要记录当前线程执行字节码的行号。是<code>唯一一个</code>在 Java 虚拟机规范中没有规定任何 OOM 情况的区域，所以也不需要GC。</li><li>本地内存：线程共享区域。在JAVA8之前，方法区是在堆内的实现的。受GC管理，JAVA8把方法区的实现移到了本地内存中的元空间。这样方法区就不受JVM控制，也不会进行GC，也提升了性能，因为发生 GC 会发生 Stop The Word,造成性能受到一定影响，也方便在元空间中统一管理。</li><li>堆：堆是GC 发生的主要区域，对象实例和数组都是在堆上分配的，GC 也主要对这两类数据进行回收。接下来我们也终点分析这块区域。</li></ul><h2 id="如何判断垃圾"><a href="#如何判断垃圾" class="headerlink" title="如何判断垃圾"></a>如何判断垃圾</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>简单来说就是对每个对象去添加一个引用计数器，每当有一个地方引用他，计数器就加一，当引用失效就减一。如果没有被引用（引用次数为 0），则此对象可回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String ref = <span class="keyword">new</span> String(<span class="string">"Java"</span>);</span><br></pre></td></tr></table></figure><p><img src="630.png" alt="引用计数"></p><p>ref 引用了右侧定义的对象，所以引用次数是 1 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref &#x3D; null;</span><br></pre></td></tr></table></figure><p>对象没被引用，引用次数置为 0，由于不被任何变量引用，此时即被回收</p><p><img src="640.gif" alt="引用计数"></p><p>但单纯的引用计数无法解决对象之间的相互循环引用的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRCGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TestRCGC instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestRCGC</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步</span></span><br><span class="line">    A a = <span class="keyword">new</span> TestRCGC(<span class="string">"a"</span>);</span><br><span class="line">    B b = <span class="keyword">new</span> TestRCGC(<span class="string">"b"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步</span></span><br><span class="line">    a.instance = b;</span><br><span class="line">    b.instance = a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步</span></span><br><span class="line">    a = <span class="keyword">null</span>;</span><br><span class="line">    b = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="650.png" alt="循环引用"></p><p>虽然最后 a，b 都被置为 null 了，但是由于之前它们指向的对象互相指向了对方（引用计数都为 1），所以无法回收，也正是由于无法解决循环引用的问题，所以现代JAVA虚拟机都不用引用计数法来判断对象是否应该被回收。</p><h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p>当前主流的内存管理系统基本都是采用的可达性分析算法来判定对象是否存活。它的原理是通过一系列“GC Roots”的根对象作为起始节点集。从这个节点开始，通过引用向下搜索，搜索过程走的路被称为“引用链”，如果对象到“GC Roots”之间没有引用链相连的话，则说明这个对象是不可达的，也就是死亡的。</p><p><img src="660.png" alt="可达性分析"></p><p>如图所示：对象a和对象b之间，虽然存在循环引用，但是a，b之间不存在与GC Root想关联的引用，因此a,b是可回收的。<br>但是此时a,b并没有真正的死亡，而是处于一个“缓刑”的阶段。一个对象真正死亡需要同时满足两个条件，一个是对象与GC Roots没有相连接的引用链。另一个是对象是否有必要执行finallize()方法。如果对象未执行，则会先执行finallize()方法。如果执行该方法后对象仍不可达，则回收该对象，反之不回收该对象。<br>但是finallize只会被执行<code>一次</code>，如果在第一次执行了finallize之后对象仍然是可达的。那么下一次对象再被GC的时候会忽略finallize方法，会被回收。</p><p>那么这些 GC Roots 到底是什么东西呢，哪些对象可以作为 GC Root 呢，有以下几类</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li></ul><h4 id="虚拟机栈中引用的对象"><a href="#虚拟机栈中引用的对象" class="headerlink" title="虚拟机栈中引用的对象"></a>虚拟机栈中引用的对象</h4><p>a 是栈帧中的本地变量，当 a = null 时，由于此时 a 充当了 <strong>GC Root</strong> 的作用，a 与原来指向的实例 <strong>new Test()</strong> 断开了连接，所以对象会被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Test a = <span class="keyword">new</span> Test();</span><br><span class="line">    a = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法区中类静态属性引用对象"><a href="#方法区中类静态属性引用对象" class="headerlink" title="方法区中类静态属性引用对象"></a>方法区中类静态属性引用对象</h4><p>当栈帧中的本地变量 a = null 时，由于 a 原来指向的对象与 GC Root (变量 a) 断开了连接，所以 a 原来指向的对象会被回收，而由于我们给 s 赋值了变量的引用，s 在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Test s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Test a = <span class="keyword">new</span> Test();</span><br><span class="line">    a.s = <span class="keyword">new</span> Test();</span><br><span class="line">    a = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法区中常量引用对象"><a href="#方法区中常量引用对象" class="headerlink" title="方法区中常量引用对象"></a>方法区中常量引用对象</h4><p>常量 s 指向的对象并不会因为 a 指向的对象被回收而回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Test s = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test a = <span class="keyword">new</span> Test();</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="本地方法栈中-JNI-引用的对象"><a href="#本地方法栈中-JNI-引用的对象" class="headerlink" title="本地方法栈中 JNI 引用的对象"></a>本地方法栈中 JNI 引用的对象</h4><p>本地方法就是一个 java 调用非 java 代码的接口，该方法并非 Java 实现的，可能由 C 或 Python等其他语言实现的， Java 通过 JNI 来调用本地方法， 而本地方法是以库文件的形式存放的（在 WINDOWS 平台上是 DLL 文件形式，在 UNIX 机器上是 SO 文件形式）。通过调用本地的库文件的内部方法，使 JAVA 可以实现和本地机器的紧密联系，调用系统级的各接口方法。</p><p>当调用 Java 方法时，虚拟机会创建一个栈桢并压入 Java 栈，而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不会在 Java 栈祯中压入新的祯，虚拟机只是简单地动态连接并直接调用指定的本地方法。</p><p><img src="670.png" alt="栈帧"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_pecuyu_jnirefdemo_MainActivity_newStringNative</span><span class="params">(JNIEnv *env, jobject instance，jstring jmsg)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">   <span class="comment">// 缓存String的class</span></span><br><span class="line">   jclass jc = (*env)-&gt;FindClass(env, STRING_PATH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 java 调用以上本地方法时，jc 会被本地方法栈压入栈中, jc 就是我们说的本地方法栈中 JNI 的对象引用，因此只会在此本地方法执行完成后才会被释放。</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>先根据可达性算法<strong>标记</strong>出相应的可回收对象，对可回收的对象进行回收。</p><p><img src="680.png" alt="标记清除"></p><p>这种方式很简单，但是会有一个特别明显的问题，当大量的小对象死亡时，标记清除出来的碎片化空间就特别多。那么我们如何能获得一个连续内存空间呢？</p><h3 id="标记整理法"><a href="#标记整理法" class="headerlink" title="标记整理法"></a>标记整理法</h3><p>两步和标记清除法一样，不同的是它在标记清除法的基础上添加了一个整理的过程 ，即将所有的存活对象都往一端移动,紧邻排列，这样就可以解决碎片化空间的问题。</p><p><img src="690.png" alt="标记整理"></p><p>这种算法的缺点是每进一次垃圾清除都要频繁地移动存活的对象，效率十分低下。</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>把堆等分成两块区域, A 和 B，区域 A 负责分配对象，区域 B 不分配, 对区域 A 使用以上所说的标记法把存活的对象标记出来（下图有误无需清除），然后把区域 A 中存活的对象都复制到区域 B（存活对象都依次<strong>紧邻排列</strong>）最后把 A 区对象全部清理掉释放出空间。</p><p><img src="700.png" alt="标记整理"></p><p>复制算法的缺点是比如给堆分配分配的内存只有一半是可用的，另外每次回收也要把存活对象移动到另一半，效率低下。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>分代收集算法整合了以上算法，综合了这些算法的优点，最大程度避免了它们的缺点，所以是现代虚拟机采用的首选算法,与其说它是算法，倒不是说它是一种策略，因为它是把上述几种算法整合在了一起，为啥需要分代收集呢，来看一下对象的分配有啥规律</p><p><img src="710.png" alt="对象存活时间"></p><p><em>如图示：纵轴代表已分配的字节，而横轴代表程序运行时间</em></p><p>由图可知，大部分的对象都很短命，都在很短的时间内都被回收了（IBM 专业研究表明，一般来说，98% 的对象都是朝生夕死的，经过一次 Minor GC 后就会被回收），所以分代收集算法根据<strong>对象存活周期的不同</strong>将堆分成新生代和老生代（Java8以前还有个永久代）,默认比例为 1 : 2，新生代又分为 Eden 区， from Survivor 区（简称S0），to Survivor 区(简称 S1),三者的比例为 8: 1 : 1，这样就可以根据新老生代的特点选择最合适的垃圾回收算法，我们把新生代发生的 GC 称为 Young GC（也叫 Minor GC）,老年代发生的 GC 称为 Old GC（也称为 Full GC）。</p><p><img src="720.png" alt="新生代老年代"></p><h4 id="分代收集工作原理"><a href="#分代收集工作原理" class="headerlink" title="分代收集工作原理"></a>分代收集工作原理</h4><p><strong>1、对象在新生代的分配与回收</strong></p><p>由以上的分析可知，大部分对象在很短的时间内都会被回收，对象一般分配在 Eden 区</p><p><img src="730.png" alt="img"></p><p>当 Eden 区将满时，触发 Minor GC<img src="740.png" alt="img"></p><p>我们之前怎么说来着，大部分对象在短时间内都会被回收, 所以经过 Minor GC 后只有少部分对象会存活，它们会被移到 S0 区（这就是为啥空间大小  Eden: S0: S1 = 8:1:1, Eden 区远大于 S0,S1 的原因，因为在 Eden 区触发的 Minor GC 把大部对象（接近98%）都回收了,只留下少量存活的对象，此时把它们移到 S0 或 S1 绰绰有余）同时对象年龄加一（对象的年龄即发生 Minor GC 的次数），最后把 Eden 区对象全部清理以释放出空间,动图如下</p><p><img src="750.gif" alt="img"></p><p>当触发下一次 Minor GC 时，会把 Eden 区的存活对象和 S0（或S1） 中的存活对象（S0 或 S1 中的存活对象经过每次 Minor GC 都可能被回收）一起移到 S1（Eden 和 S0 的存活对象年龄+1）, 同时清空 Eden 和 S0 的空间。<img src="760.gif" alt="img"></p><p>若再触发下一次 Minor GC，则重复上一步，只不过此时变成了 从 Eden，S1 区将存活对象复制到 S0 区,每次垃圾回收, S0, S1 角色互换，都是从 Eden ,S0(或S1) 将存活对象移动到 S1(或S0)。也就是说在 Eden 区的垃圾回收我们采用的是<strong>复制算法</strong>，因为在 Eden 区分配的对象大部分在 Minor GC 后都消亡了，只剩下极少部分存活对象（这也是为啥 Eden:S0:S1 默认为 8:1:1 的原因），S0,S1 区域也比较小，所以最大限度地降低了复制算法造成的对象频繁拷贝带来的开销。</p><p><strong>2、对象何时晋升老年代</strong></p><ul><li>当对象的年龄达到了我们设定的阈值，则会从S0（或S1）晋升到老年代<img src="770.gif" alt="img">如图示：年龄阈值设置为 15， 当发生下一次 Minor GC 时，S0 中有个对象年龄达到 15，达到我们的设定阈值，晋升到老年代！</li><li>大对象 当某个对象分配需要大量的连续内存时，此时对象的创建不会分配在 Eden 区，会直接分配在老年代，因为如果把大对象分配在 Eden 区, Minor GC 后再移动到 S0,S1 会有很大的开销（对象比较大，复制会比较慢，也占空间），也很快会占满 S0,S1 区，所以干脆就直接移到老年代.</li><li>还有一种情况也会让对象晋升到老年代，即在 S0（或S1） 区相同年龄的对象大小之和大于 S0（或S1）空间一半以上时，则年龄大于等于该年龄的对象也会晋升到老年代。</li></ul><p><strong>3、空间分配担保</strong></p><p>在发生 MinorGC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，那么Minor GC 可以确保是安全的,如果不大于，那么虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行 Minor GC，否则可能进行一次 Full GC。</p><p><strong>4、Stop The World</strong></p><p>如果老年代满了，会触发 Full GC, Full GC 会同时回收新生代和老年代（即对整个堆进行GC），它会导致 Stop The World（简称 STW）,造成挺大的性能开销。</p><p>什么是 STW ？所谓的 STW, 即在 GC（minor GC 或 Full GC）期间，只有垃圾回收器线程在工作，其他工作线程则被挂起。</p><p><img src="780.png" alt="img"></p><p><em>画外音：为啥在垃圾收集期间其他工作线程会被挂起？想象一下，你一边在收垃圾，另外一群人一边丢垃圾，垃圾能收拾干净吗。</em></p><p>一般 Full GC 会导致工作线程停顿时间过长（因为Full GC 会清理<strong>整个堆</strong>中的不可用对象，一般要花较长的时间），如果在此 server 收到了很多请求，则会被拒绝服务！所以我们要尽量减少 Full GC（Minor GC 也会造成 STW,但只会触发轻微的 STW,因为 Eden 区的对象大部分都被回收了，只有极少数存活对象会通过复制算法转移到 S0 或 S1 区，所以相对还好）。</p><p>现在我们应该明白把新生代设置成 Eden, S0，S1区或者给对象设置年龄阈值或者默认把新生代与老年代的空间大小设置成 1:2 都是为了<strong>尽可能地避免对象过早地进入老年代，尽可能晚地触发 Full GC</strong>。想想新生代如果只设置 Eden 会发生什么，后果就是每经过一次 Minor GC，存活对象会过早地进入老年代，那么老年代很快就会装满，很快会触发 Full GC，而对象其实在经过两三次的 Minor GC 后大部分都会消亡，所以有了 S0,S1的缓冲，只有少数的对象会进入老年代，老年代大小也就不会这么快地增长，也就避免了过早地触发 Full GC。</p><p>由于 Full GC（或Minor GC） 会影响性能，所以我们要在一个合适的时间点发起 GC，这个时间点被称为 Safe Point，这个时间点的选定既不能太少以让 GC 时间太长导致程序过长时间卡顿，也不能过于频繁以至于过分增大运行时的负荷。一般当线程在这个时间点上状态是可以确定的，如确定 GC Root 的信息等，可以使 JVM 开始安全地 GC。Safe Point 主要指的是以下特定位置：</p><ul><li>循环的末尾</li><li>方法返回前</li><li>调用方法的 call 之后</li><li>抛出异常的位置 另外需要注意的是由于新生代的特点（大部分对象经过 Minor GC后会消亡）， Minor GC 用的是复制算法，而在老生代由于对象比较多，占用的空间较大，使用复制算法会有较大开销（复制算法在对象存活率较高时要进行多次复制操作，同时浪费一半空间）所以根据老生代特点，在老年代进行的 GC 一般采用的是标记整理法来进行回收。</li></ul><h2 id="垃圾收集器种类"><a href="#垃圾收集器种类" class="headerlink" title="垃圾收集器种类"></a>垃圾收集器种类</h2><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java 虚拟机规范并没有规定垃圾收集器应该如何实现，因此一般来说不同厂商，不同版本的虚拟机提供的垃圾收集器实现可能会有差别，一般会给出参数来让用户根据应用的特点来组合各个年代使用的收集器，主要有以下垃圾收集器</p><p><img src="790.png" alt="img"></p><ul><li>在新生代工作的垃圾回收器：Serial, ParNew, ParallelScavenge</li><li>在老年代工作的垃圾回收器：CMS，Serial Old, Parallel Old</li><li>同时在新老生代工作的垃圾回收器：G1</li></ul><p>图片中的垃圾收集器如果存在连线，则代表它们之间可以配合使用，接下来我们来看看各个垃圾收集器的具体功能。</p><h3 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h3><h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><p>Serial 收集器是工作在新生代的，单线程的垃圾收集器，单线程意味着它只会使用一个 CPU 或一个收集线程来完成垃圾回收，不仅如此，还记得我们上文提到的 STW 了吗，它在进行垃圾收集时，其他用户线程会暂停，直到垃圾收集结束，也就是说在 GC 期间，此时的应用不可用。</p><p>看起来单线程垃圾收集器不太实用，不过我们需要知道的任何技术的使用都不能脱离场景，在 <strong>Client 模式</strong>下，它简单有效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 单线程模式无需与其他线程交互，减少了开销，专心做 GC 能将其单线程的优势发挥到极致，另外在用户的桌面应用场景，分配给虚拟机的内存一般不会很大，收集几十甚至一两百兆（仅是新生代的内存，桌面应用基本不会再大了），STW 时间可以控制在一百多毫秒内，只要不是频繁发生，这点停顿是可以接受的，所以对于运行在 Client 模式下的虚拟机，Serial 收集器是新生代的默认收集器</p><h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><p>ParNew 收集器是 Serial 收集器的多线程版本，除了使用多线程，其他像收集算法,STW,对象分配规则，回收策略与 Serial 收集器完成一样，在底层上，这两种收集器也共用了相当多的代码，它的垃圾收集过程如下<img src="800.png" alt="img"></p><p>ParNew 主要工作在 Server 模式，我们知道服务端如果接收的请求多了，响应时间就很重要了，多线程可以让垃圾回收得更快，也就是减少了 STW 时间，能提升响应时间，所以是许多运行在 Server 模式下的虚拟机的首选新生代收集器，另一个与性能无关的原因是因为除了 Serial  收集器，<strong>只有它能与 CMS 收集器配合工作</strong>，CMS 是一个划时代的垃圾收集器，是真正意义上的<strong>并发收集器</strong>，它第一次实现了垃圾收集线程与用户线程（基本上）同时工作，它采用的是传统的 GC 收集器代码框架，与 Serial,ParNew 共用一套代码框架，所以能与这两者一起配合工作，而后文提到的 Parallel Scavenge 与 G1 收集器没有使用传统的 GC 收集器代码框架，而是另起炉灶独立实现的，另外一些收集器则只是共用了部分的框架代码,所以无法与 CMS 收集器一起配合工作。</p><p>在多 CPU 的情况下，由于 ParNew 的多线程回收特性，毫无疑问垃圾收集会更快，也能有效地减少 STW 的时间，提升应用的响应速度。</p><h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>Parallel Scavenge 收集器也是一个使用<strong>复制算法</strong>，<strong>多线程</strong>，工作于新生代的垃圾收集器，看起来功能和 ParNew 收集器一样，它有啥特别之处吗</p><p><strong>关注点不同</strong>，CMS 等垃圾收集器关注的是尽可能缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 目标是达到一个可控制的吞吐量（吞吐量 = 运行用户代码时间 / （运行用户代码时间+垃圾收集时间）），也就是说 CMS 等垃圾收集器更适合用到与用户交互的程序，因为停顿时间越短，用户体验越好，而 Parallel Scavenge 收集器关注的是吞吐量，所以更适合做后台运算等不需要太多用户交互的任务。</p><p>Parallel Scavenge 收集器提供了两个参数来精确控制吞吐量，分别是控制最大垃圾收集时间的 -XX:MaxGCPauseMillis 参数及直接设置吞吐量大小的 -XX:GCTimeRatio（默认99%）</p><p>除了以上两个参数，还可以用 Parallel Scavenge 收集器提供的第三个参数 -XX:UseAdaptiveSizePolicy，开启这个参数后，就不需要手工指定新生代大小,Eden 与 Survivor 比例（SurvivorRatio）等细节，只需要设置好基本的堆大小（-Xmx 设置最大堆）,以及最大垃圾收集时间与吞吐量大小，虚拟机就会根据当前系统运行情况收集监控信息，动态调整这些参数以尽可能地达到我们设定的最大垃圾收集时间或吞吐量大小这两个指标。自适应策略也是 Parallel Scavenge  与 ParNew 的重要区别！</p><h3 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h3><h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p>上文我们知道， Serial 收集器是工作于新生代的单线程收集器，与之相对地，Serial Old 是工作于老年代的单线程收集器，此收集器的主要意义在于给 Client 模式下的虚拟机使用，如果在 Server 模式下，则它还有两大用途：一种是在 JDK 1.5 及之前的版本中与 Parallel Scavenge 配合使用，另一种是作为 CMS 收集器的后备预案,在并发收集发生 Concurrent Mode Failure 时使用（后文讲述）,它与 Serial 收集器配合使用示意图如下</p><p><img src="810.png" alt="img"></p><h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><p>Parallel Old 是相对于 Parallel Scavenge 收集器的老年代版本，使用多线程和标记整理法，两者组合示意图如下,这两者的组合由于都是多线程收集器，真正实现了「吞吐量优先」的目标</p><p><img src="820.png" alt="img"></p><h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><p>CMS 收集器是以实现最短 STW 时间为目标的收集器，如果应用很重视服务的响应速度，希望给用户最好的体验，则 CMS 收集器是个很不错的选择！</p><p>我们之前说老年代主要用标记整理法，而 CMS 虽然工作于老年代，但采用的是标记清除法，主要有以下四个步骤</p><ol><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ol><p><img src="830.png" alt="img"></p><p>从图中可以的看到初始标记和重新标记两个阶段会发生 STW，造成用户线程挂起，不过初始标记仅标记 GC Roots 能关联的对象，速度很快，并发标记是进行 GC Roots  Tracing 的过程，重新标记是为了修正并发标记期间因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录，这一阶段停顿时间一般比初始标记阶段稍长，但<strong>远比并发标记时间短</strong>。</p><p>整个过程中耗时最长的是并发标记和标记清理，不过这两个阶段用户线程都可工作，所以不影响应用的正常使用，所以总体上看，可以认为 CMS 收集器的内存回收过程是与用户线程一起并发执行的。</p><p>但是 CMS 收集器远达不到完美的程度，主要有以下三个缺点</p><ul><li>CMS 收集器对 CPU 资源非常敏感  原因也可以理解，比如本来我本来可以有 10 个用户线程处理请求，现在却要分出 3 个作为回收线程，吞吐量下降了30%，CMS 默认启动的回收线程数是 （CPU数量+3）/ 4, 如果 CPU 数量只有一两个，那吞吐量就直接下降 50%,显然是不可接受的</li><li>CMS 无法处理浮动垃圾（Floating Garbage）,可能出现 「Concurrent Mode Failure」而导致另一次 Full GC 的产生，由于在并发清理阶段用户线程还在运行，所以清理的同时新的垃圾也在不断出现，这部分垃圾只能在下一次 GC 时再清理掉（即浮云垃圾），同时在垃圾收集阶段用户线程也要继续运行，就需要预留足够多的空间要确保用户线程正常执行，这就意味着 CMS 收集器不能像其他收集器一样等老年代满了再使用，JDK 1.5 默认当老年代使用了68%空间后就会被激活，当然这个比例可以通过 -XX:CMSInitiatingOccupancyFraction 来设置，但是如果设置地太高很容易导致在 CMS 运行期间预留的内存无法满足程序要求，会导致 <strong>Concurrent Mode Failure</strong> 失败，这时会启用 Serial Old 收集器来重新进行老年代的收集，而我们知道 Serial Old 收集器是单线程收集器，这样就会导致 STW 更长了。</li><li>CMS 采用的是标记清除法，上文我们已经提到这种方法会产生大量的内存碎片，这样会给大内存分配带来很大的麻烦，如果无法找到足够大的连续空间来分配对象，将会触发 Full GC，这会影响应用的性能。当然我们可以开启 -XX:+UseCMSCompactAtFullCollection（默认是开启的），用于在 CMS 收集器顶不住要进行 FullGC 时开启内存碎片的合并整理过程，内存整理会导致 STW，停顿时间会变长，还可以用另一个参数 -XX:CMSFullGCsBeforeCompation 用来设置执行多少次不压缩的 Full GC 后跟着带来一次带压缩的。</li></ul><h4 id="G1（Garbage-First）-收集器"><a href="#G1（Garbage-First）-收集器" class="headerlink" title="G1（Garbage First） 收集器"></a>G1（Garbage First） 收集器</h4><p>G1 收集器是面向服务端的垃圾收集器，被称为驾驭一切的垃圾回收器，主要有以下几个特点</p><ul><li><p>像 CMS 收集器一样，能与应用程序线程并发执行。</p></li><li><p>整理空闲空间更快。</p></li><li><p>需要 GC 停顿时间更好预测。</p></li><li><p>不会像 CMS 那样牺牲大量的吞吐性能。</p></li><li><p>不需要更大的 Java Heap</p></li></ul><p>与 CMS 相比，它在以下两个方面表现更出色</p><ol><li>运作期间不会产生内存碎片，G1 从整体上看采用的是标记-整理法，局部（两个 Region）上看是基于复制算法实现的，两个算法都不会产生内存碎片，收集后提供规整的可用内存，这样有利于程序的长时间运行。</li><li>在 STW 上建立了<strong>可预测</strong>的停顿时间模型，用户可以指定期望停顿时间，G1 会将停顿时间控制在用户设定的停顿时间以内。</li></ol><p>为什么G1能建立可预测的停顿模型呢，主要原因在于 G1 对堆空间的分配与传统的垃圾收集器不一器，传统的内存分配就像我们前文所述，是连续的，分成新生代，老年代，新生代又分 Eden,S0,S1,如下</p><p><img src="840.png" alt="img"><br>而 G1 各代的存储地址不是连续的，每一代都使用了 n 个不连续的大小相同的 Region，每个Region占有一块连续的虚拟内存地址，如图示</p><p><img src="850.png" alt="img"><br>除了和传统的新老生代，幸存区的空间区别，Region还多了一个H，它代表Humongous，这表示这些Region存储的是巨大对象（humongous object，H-obj），即大小大于等于region一半的对象，这样超大对象就直接分配到了老年代，防止了反复拷贝移动。那么 G1 分配成这样有啥好处呢？</p><p>传统的收集器如果发生 Full GC 是对整个堆进行全区域的垃圾收集，而分配成各个 Region 的话，方便 G1 跟踪各个 Region 里垃圾堆积的价值大小（回收所获得的空间大小及回收所需经验值），这样根据价值大小维护一个优先列表，根据允许的收集时间，优先收集回收价值最大的 Region,也就避免了整个老年代的回收，也就减少了 STW 造成的停顿时间。同时由于只收集部分 Region,可就做到了 STW 时间的可控。</p><p>G1 收集器的工作步骤如下</p><ol><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ol><p><img src="860.png" alt="img"></p><p>可以看到整体过程与 CMS 收集器非常类似，筛选阶段会根据各个 Region 的回收价值和成本进行排序，根据用户期望的 GC 停顿时间来制定回收计划。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> GC </tag>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那些年我们学过的设计模式，你还记得几个（一）</title>
      <link href="2020/09/25/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E5%AD%A6%E8%BF%87%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E8%BF%98%E8%AE%B0%E5%BE%97%E5%87%A0%E4%B8%AA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2020/09/25/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E5%AD%A6%E8%BF%87%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E8%BF%98%E8%AE%B0%E5%BE%97%E5%87%A0%E4%B8%AA%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>最近在忙着面试，趁着没工作的空闲期，想把设计模式好好整理一遍。话不多说，我们直接上第一个设计模式—-<code>单例模式</code></p><h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>这也是面试时面试官经常问我的问题，什么是单例模式？脑海中是不是立即浮现出两种单例模式。然后准备滔滔不绝的说给面试官听？面试官在问我们这个问题的时候，我们最好不要答非所问。最好根据单例模式的定义去正面回答面试官。</p><p>单例模式是指在内存中只会创建且仅创建一次对象的设计模式。在程序中多次使用同一个对象且作用相同时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中创建一个对象，让所有需要调用的地方都共享这一单例对象。</p><p><img src="dlms1.jpg" alt="单例模式定义"></p><h2 id="单例模式创建类型"><a href="#单例模式创建类型" class="headerlink" title="单例模式创建类型"></a>单例模式创建类型</h2><ul><li><p><code>懒汉式</code>：在被程序第一次调用的时候才初始化该单例对象</p></li><li><p><code>饿汉式</code>：在类加载的时候就已经创建好该单例对象</p></li></ul><h3 id="懒汉式创建单例对象"><a href="#懒汉式创建单例对象" class="headerlink" title="懒汉式创建单例对象"></a>懒汉式创建单例对象</h3><p>懒汉式只在程序第一次调用的时候创建对象，所以需要调用的时候需要判断是否已经实例化该对象，如果未实例化，则实例化该对象。</p><p><img src="lhs.png" alt="懒汉式"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleTon singleTon;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon==<span class="keyword">null</span>)&#123;</span><br><span class="line">            singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面再讲这段代码的优化，我们先来看第二种单例模式的实现。</p><h3 id="饿汉式创建单例对象"><a href="#饿汉式创建单例对象" class="headerlink" title="饿汉式创建单例对象"></a>饿汉式创建单例对象</h3><p>饿汉式在类加载的时候就已经初始化好该对象，后续程序调用的都是该对象。</p><p><img src="ehs.png" alt="饿汉式"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleTon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleTon singleTon = <span class="keyword">new</span> HungrySingleTon();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样类在加载时会在堆内存中创建一个HungrySingleTon对象，当类被卸载时，HungrySingleTon对象也就会被随之死亡了。</p><h3 id="懒汉式代码如何优化"><a href="#懒汉式代码如何优化" class="headerlink" title="懒汉式代码如何优化"></a>懒汉式代码如何优化</h3><p>因为上述懒汉式的实现并不能保证在多线程环境下，对象只被创建一次的问题。因此存在一个线程安全的问题。我们回顾一下上面懒汉式创建的主要函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon==<span class="keyword">null</span>)&#123;</span><br><span class="line">            singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果同时存在多个线程，线程1在判断了<code>singleTon==null</code>后让出了cpu的使用权，而线程二这时候获取到了cpu的使用权，也判断了一次<code>singleTon==null</code>那么线程2就会执行<code>singleTon = new LazySingleTon()</code>,当线程1重新获取到cpu的使用权之后，因为他刚判断了<code>singleTon</code>是null，所以线程1也会创建一个LazySingleTon的实例。所以就存在了<code>线程安全</code>的问题。</p><hr><p>我们最容易想到的办法就是加锁，给类对象加锁或者给方法加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给方法加锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(singleTon==<span class="keyword">null</span>)&#123;</span><br><span class="line">singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleTon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给类对象加锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon==<span class="keyword">null</span>)&#123;</span><br><span class="line">singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleTon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但上面两种方法都存在一个问题，在获取对象之前都要先获取锁，所以并发性能就显得尤其的低下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon ==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleTon<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleTon == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的实现方式，就完美的解决了性能低下和锁资源的问题。</p><ul><li><strong>line2:</strong>当singleTon已经被实例化的时候,直接返回对象，不再获取锁资源</li><li><strong>line3</strong>:当多个线程进入第一个if时，施加同步锁，每次仅允许一个线程进去当前代码块。</li><li><strong>line4</strong>:锁内再次进行判断，因为多个线程抢夺一个资源时只有一个获取到，后进入的线程所要获取的对象已经被第一个线程实例化过。所以需要再次判断。</li></ul><p>这就是典型的DCL型懒汉单例，<code>Double Check and Lock</code>双重校验加锁。但是我们在写DCL的时候都会加入<code>volatile</code>关键词修饰singleTon。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleTon singleTon;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon ==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleTon<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleTon == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleTon = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是因为JVM在创建对象的时候，可以对指令进行重排序以提高程序性能。JVM在创建对象的时候，一般会经过以下三个步骤：</p><ul><li>分配内存空间</li><li>初始化对象</li><li>将对象指向分配好的内存空间</li></ul><p>但是在2和3的时候有可能出现指令重排。比如多个线程，当线程1执行了1-3而正在初始化对象，而线程2获取对象时，就获取到了一个未初始化的对象。就会出现空指针异常了。而volatile就是为了在JVM创建对象的时候进行<code>禁止指令重排</code>的。</p><h2 id="还有其他的形式吗"><a href="#还有其他的形式吗" class="headerlink" title="还有其他的形式吗"></a>还有其他的形式吗</h2><h3 id="静态内部类实现单例"><a href="#静态内部类实现单例" class="headerlink" title="静态内部类实现单例"></a>静态内部类实现单例</h3><p>静态内部类相对于DCL模式实现更简单，对<code>静态域</code>使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在<code>实例域</code>需要延迟初始化时使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingleTon INSTANCE = <span class="keyword">new</span> SingleTon();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SingleTon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举类实现单例"><a href="#枚举类实现单例" class="headerlink" title="枚举类实现单例"></a>枚举类实现单例</h3><p>在JDK1.5中，java引入了枚举类型。枚举是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是《 Effective Java》 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象。</p><p>优点不言而喻：</p><ul><li>实现更简单</li><li>天然的线程安全</li><li>可以防止反射、反序列化创建多个枚举对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="破坏单例模式"><a href="#破坏单例模式" class="headerlink" title="破坏单例模式"></a>破坏单例模式</h2><p>枚举本身自带防止反射和反序列化的特性，那懒汉式和饿汉式又是如何被破坏的呢</p><h3 id="反射破坏单例模式"><a href="#反射破坏单例模式" class="headerlink" title="反射破坏单例模式"></a>反射破坏单例模式</h3><p>下面我们就可以用反射直接强制访问私有构造器，去创建实例对象破坏单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取类的显式构造器</span></span><br><span class="line">    Constructor&lt;HungrySingleTon&gt; construct = HungrySingleTon<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>()</span>;</span><br><span class="line">    <span class="comment">// 可访问私有构造器</span></span><br><span class="line">    construct.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 利用反射构造新对象</span></span><br><span class="line">    HungrySingleTon obj1 = construct.newInstance();</span><br><span class="line">    <span class="comment">// 通过正常方式获取单例对象</span></span><br><span class="line">    HungrySingleTon obj2 = HungrySingleTon.getInstance();</span><br><span class="line">    System.out.println(obj1 == obj2); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那如何防止单例模式被反射破坏呢，因为反射是强制访问私有构造器，对于饿汉式，在类加载的时候对象已经初始化，所以我们可以在私有构造器对当前对象进行判断来规避反射破坏单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleTon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleTon singleTon = <span class="keyword">new</span> HungrySingleTon();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleTon</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleTon!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"禁止通过反射实例化对象"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化和反序列化破坏单例模式"><a href="#序列化和反序列化破坏单例模式" class="headerlink" title="序列化和反序列化破坏单例模式"></a>序列化和反序列化破坏单例模式</h3><p>下面是一个序列化和反序列化去破坏单例的例子，但是使用序列化和反序列化破坏单例时，单例对象的类必须实现Serializable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleTon</span> <span class="keyword">implements</span>  <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 创建输出流</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"Singleton.file"</span>));</span><br><span class="line">        <span class="comment">// 将单例对象写到文件中</span></span><br><span class="line">        oos.writeObject(HungrySingleTon.getInstance());</span><br><span class="line">        <span class="comment">// 从文件中读取单例对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"Singleton.file"</span>);</span><br><span class="line">        ObjectInputStream ois =  <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        HungrySingleTon newInstance = (HungrySingleTon) ois.readObject();</span><br><span class="line">        <span class="comment">// 判断是否是同一个对象</span></span><br><span class="line">        System.out.println(newInstance == HungrySingleTon.getInstance()); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleTon singleTon = <span class="keyword">new</span> HungrySingleTon();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>单例模式主要实现方式为懒汉式、饿汉式、静态内部类和枚举</li><li>大部分的单例模式可以被反射和序列化和反序列化破坏</li><li>我们可以通过人为干预来避免反射或系列化攻击</li><li>枚举自带天然的线程安全和单一实例以及防反射和防序列化和反序列破坏的特性</li><li>对于懒汉式最优雅的写法应该是DCL加volatile修饰</li><li>对内存要求高的时候我们可以选择<code>懒加载</code>的单例实现方式</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
